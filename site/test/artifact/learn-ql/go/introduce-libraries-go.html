
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>CodeQL library for Go &#8212; Learn CodeQL</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.25',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Abstract syntax tree classes for working with Go programs" href="ast-class-reference.html" />
    <link rel="prev" title="Basic query for Go code" href="basic-query-go.html" />
  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i) {w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var  f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true; j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);}) (window,document,'script','dataLayer','GTM-5Q9DBRM');</script>
  <!-- End Google Tag Manager -->
  
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  </head>
  <body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q9DBRM" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<div id="siteBanner">
    <div class="logocontainer">
        <a href="https://securitylab.github.com" id="Header-logo" class="">
                <svg width="100%" height="100%" viewBox="0 0 696 160" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <rect width="696" height="160" fill="white"/>
                    <path fill-rule="evenodd" clip-rule="evenodd" d="M80.0397 32.8C53.4747 32.8 32 54.4342 32 81.1965C32 102.59 45.7597 120.699 64.8483 127.109C67.2344 127.59 68.1093 126.067 68.1093 124.785C68.1093 123.664 68.0297 119.818 68.0297 115.811C54.6677 118.696 51.884 110.042 51.884 110.042C49.7365 104.433 46.5551 102.991 46.5551 102.991C42.1806 100.026 46.8732 100.026 46.8732 100.026C51.7249 100.347 54.27 104.994 54.27 104.994C58.565 112.366 65.4846 110.283 68.2684 109C68.666 105.876 69.9386 103.712 71.2907 102.51C60.6329 101.388 49.4184 97.2219 49.4184 78.6325C49.4184 73.3441 51.3272 69.0173 54.3496 65.6519C53.8724 64.45 52.2021 59.4822 54.8268 52.8317C54.8268 52.8317 58.8831 51.5496 68.0297 57.7995C71.8475 56.7579 75.9833 56.197 80.0397 56.197C84.096 56.197 88.2319 56.7579 92.0496 57.7995C101.196 51.5496 105.253 52.8317 105.253 52.8317C107.877 59.4822 106.207 64.45 105.73 65.6519C108.832 69.0173 110.661 73.3441 110.661 78.6325C110.661 97.2219 99.4464 101.308 88.7091 102.51C90.4589 104.033 91.97 106.917 91.97 111.484C91.97 117.975 91.8905 123.183 91.8905 124.785C91.8905 126.067 92.7654 127.59 95.1515 127.109C114.24 120.699 128 102.59 128 81.1965C128.079 54.4342 106.525 32.8 80.0397 32.8Z" fill="black"/>
                    <path d="M50.2139 102.27C50.1343 102.51 49.7367 102.59 49.4185 102.43C49.1004 102.27 48.8618 101.949 49.0208 101.709C49.1004 101.469 49.4981 101.388 49.8162 101.549C50.1343 101.709 50.2934 102.029 50.2139 102.27Z" fill="black"/>
                    <path d="M52.1224 104.433C51.8837 104.674 51.4065 104.513 51.1679 104.193C50.8498 103.872 50.7702 103.392 51.0089 103.151C51.2475 102.911 51.6451 103.071 51.9633 103.392C52.2814 103.792 52.361 104.273 52.1224 104.433Z" fill="black"/>
                    <path d="M54.0314 107.238C53.7132 107.478 53.236 107.238 52.9974 106.837C52.6793 106.436 52.6793 105.876 52.9974 105.715C53.3155 105.475 53.7928 105.715 54.0314 106.116C54.3495 106.517 54.3495 106.997 54.0314 107.238Z" fill="black"/>
                    <path d="M56.656 109.962C56.4174 110.283 55.8607 110.202 55.3834 109.802C54.9858 109.401 54.8267 108.84 55.1448 108.6C55.3834 108.279 55.9402 108.359 56.4174 108.76C56.8151 109.081 56.8946 109.642 56.656 109.962Z" fill="black"/>
                    <path d="M60.2354 111.484C60.1558 111.885 59.5991 112.045 59.0423 111.885C58.4856 111.725 58.1674 111.244 58.247 110.924C58.3265 110.523 58.8832 110.363 59.44 110.523C59.9967 110.683 60.3149 111.084 60.2354 111.484Z" fill="black"/>
                    <path d="M64.1324 111.805C64.1324 112.206 63.6552 112.526 63.0984 112.526C62.5417 112.526 62.0645 112.206 62.0645 111.805C62.0645 111.404 62.5417 111.084 63.0984 111.084C63.6552 111.084 64.1324 111.404 64.1324 111.805Z" fill="black"/>
                    <path d="M67.791 111.164C67.8705 111.565 67.4729 111.965 66.9161 112.045C66.3594 112.125 65.8822 111.885 65.8026 111.484C65.7231 111.084 66.1208 110.683 66.6775 110.603C67.2343 110.523 67.7115 110.763 67.791 111.164Z" fill="black"/>
                    <path d="M190.125 70.1023H198.591C198.335 60.7841 190.097 54.0227 178.278 54.0227C166.602 54.0227 157.653 60.6989 157.653 70.7273C157.653 78.8239 163.449 83.5682 172.795 86.0966L179.67 87.9716C185.892 89.6193 190.693 91.6648 190.693 96.8352C190.693 102.517 185.267 106.267 177.795 106.267C171.034 106.267 165.409 103.256 164.898 96.9205H156.091C156.659 107.46 164.812 113.966 177.852 113.966C191.517 113.966 199.386 106.778 199.386 96.9205C199.386 86.4375 190.04 82.375 182.653 80.5568L176.972 79.0796C172.426 77.9148 166.375 75.7841 166.403 70.2159C166.403 65.2727 170.92 61.608 178.079 61.608C184.756 61.608 189.5 64.733 190.125 70.1023Z" fill="black"/>
                    <path d="M227.201 113.881C236.718 113.881 243.451 109.193 245.383 102.091L237.343 100.642C235.809 104.761 232.116 106.864 227.287 106.864C220.014 106.864 215.127 102.148 214.9 93.7386H245.923V90.7273C245.923 74.9602 236.491 68.7955 226.605 68.7955C214.446 68.7955 206.434 78.0568 206.434 91.4659C206.434 105.017 214.332 113.881 227.201 113.881ZM214.929 87.375C215.27 81.1818 219.758 75.8125 226.662 75.8125C233.252 75.8125 237.571 80.6989 237.599 87.375H214.929Z" fill="black"/>
                    <path d="M272.928 113.881C283.241 113.881 289.917 107.688 290.854 99.1932H282.587C281.508 103.909 277.843 106.693 272.985 106.693C265.798 106.693 261.167 100.699 261.167 91.1818C261.167 81.8352 265.883 75.9546 272.985 75.9546C278.383 75.9546 281.678 79.3636 282.587 83.4546H290.854C289.945 74.6477 282.758 68.7955 272.843 68.7955C260.542 68.7955 252.587 78.0568 252.587 91.3807C252.587 104.534 260.258 113.881 272.928 113.881Z" fill="black"/>
                    <path d="M326.78 94.9034C326.809 102.318 321.297 105.841 316.525 105.841C311.269 105.841 307.633 102.034 307.633 96.0966V69.3636H299.138V97.1193C299.138 107.943 305.076 113.568 313.456 113.568C320.019 113.568 324.479 110.102 326.496 105.443H326.951V113H335.303V69.3636H326.78V94.9034Z" fill="black"/>
                    <path d="M345.916 113H354.411V86.3523C354.411 80.6421 358.814 76.5227 364.837 76.5227C366.598 76.5227 368.587 76.8352 369.269 77.0341V68.9091C368.416 68.7955 366.74 68.7102 365.661 68.7102C360.547 68.7102 356.172 71.608 354.581 76.2955H354.127V69.3636H345.916V113Z" fill="black"/>
                    <path d="M375.82 113H384.314V69.3636H375.82V113ZM380.109 62.6307C383.035 62.6307 385.479 60.358 385.479 57.5739C385.479 54.7898 383.035 52.4886 380.109 52.4886C377.155 52.4886 374.74 54.7898 374.74 57.5739C374.74 60.358 377.155 62.6307 380.109 62.6307Z" fill="black"/>
                    <path d="M415.311 69.3636H406.362V58.9091H397.868V69.3636H391.475V76.1818H397.868V101.949C397.839 109.875 403.89 113.71 410.595 113.568C413.294 113.54 415.112 113.028 416.106 112.659L414.572 105.642C414.004 105.756 412.953 106.011 411.589 106.011C408.833 106.011 406.362 105.102 406.362 100.188V76.1818H415.311V69.3636Z" fill="black"/>
                    <path d="M429.276 129.25C436.293 129.25 440.754 125.585 443.254 118.824L461.293 69.4489L452.117 69.3636L441.066 103.227H440.612L429.56 69.3636H420.47L436.435 113.568L435.384 116.466C433.225 122.119 430.185 122.631 425.526 121.352L423.481 128.313C424.504 128.795 426.72 129.25 429.276 129.25Z" fill="black"/>
                    <path d="M489.551 113H524.693V105.443H498.33V54.8182H489.551V113Z" fill="black"/>
                    <path d="M545.925 113.966C553.141 113.966 557.203 110.301 558.822 107.034H559.163V113H567.459V84.0227C567.459 71.3239 557.459 68.7955 550.527 68.7955C542.629 68.7955 535.356 71.9773 532.516 79.9318L540.498 81.75C541.748 78.6534 544.93 75.6705 550.641 75.6705C556.123 75.6705 558.936 78.5398 558.936 83.483V83.6818C558.936 86.7784 555.754 86.7216 547.913 87.6307C539.646 88.5966 531.18 90.7557 531.18 100.67C531.18 109.25 537.629 113.966 545.925 113.966ZM547.771 107.148C542.97 107.148 539.504 104.989 539.504 100.784C539.504 96.2386 543.538 94.6193 548.453 93.9659C551.209 93.5966 557.743 92.858 558.964 91.6364V97.2614C558.964 102.432 554.845 107.148 547.771 107.148Z" fill="black"/>
                    <path d="M578.654 113H586.95V106.21H587.66C589.194 108.994 592.319 113.852 600.274 113.852C610.842 113.852 618.512 105.386 618.512 91.2671C618.512 77.1193 610.728 68.7955 600.189 68.7955C592.092 68.7955 589.166 73.7386 587.66 76.4375H587.149V54.8182H578.654V113ZM586.978 91.1818C586.978 82.0625 590.956 76.0114 598.37 76.0114C606.069 76.0114 609.933 82.5171 609.933 91.1818C609.933 99.9318 605.956 106.608 598.37 106.608C591.069 106.608 586.978 100.358 586.978 91.1818Z" fill="black"/>
                </svg>
                  
        </a>
    </div>            
        <div class="linkcontainer" id="linkcontainermenu">
                <div class="linkbar">
                    <a href="https://help.semmle.com/QL/learn-ql/">Learn CodeQL</a>
                    <a href="https://help.semmle.com/codeql/codeql-tools.html">CodeQL tools</a>
                    <a href="https://github.com/github/codeql">CodeQL repository</a>
                    <a href="https://help.semmle.com/QL/ql-libraries.html">CodeQL libraries</a>
                    <a href="javascript:void(0);" class="icon" onclick="myFunction()">
                        <i class="fa fa-bars"></i>
                      </a>
                </div>
       </div>
</div>  
<div id="title-banner">
    <a href="../index.html">Learning CodeQL</a>
    <div id="searchbox-title-banner" role="search">
            <form class="search" action="../search.html" method="get">
                <div id="textfield"><input type="text" name="q" /></div>
                <div id="searchbutton"><input type="submit" value="Search" /></div>
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
            </form>
        </div>
        <script type="text/javascript">$('#searchbox').show(0);</script> 
    <div class="clearer"></div>
</div>

<div class="wrapper">
   
    <div class="navBox" > 
            <div id="searchbox-navbar"  role="search">
                    <form class="search" action="../search.html" method="get">
                        <div id="textfield"><input type="text" name="q" /></div>
                        <div id="searchbutton"><input type="submit" value="Search" /></div>
                        <input type="hidden" name="check_keywords" value="yes" />
                        <input type="hidden" name="area" value="default" />
                    </form>
                </div>
                <script type="text/javascript">$('#searchbox').show(0);</script> 
                <div class="clearer"></div>
            <div id="toc">
                <h1>Contents</h1>  
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../beginner/ql-tutorials.html">QL tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../writing-queries/writing-queries.html">CodeQL queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpp/ql-for-cpp.html">CodeQL for C and C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="../csharp/ql-for-csharp.html">CodeQL for C#</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="ql-for-go.html">CodeQL for Go</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basic-query-go.html">Basic query for Go code</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">CodeQL library for Go</a></li>
<li class="toctree-l2"><a class="reference internal" href="ast-class-reference.html">Abstract syntax tree classes for working with Go programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="library-modeling-go.html">Modeling data flow in Go libraries</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../java/ql-for-java.html">CodeQL for Java</a></li>
<li class="toctree-l1"><a class="reference internal" href="../javascript/ql-for-javascript.html">CodeQL for JavaScript</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/ql-for-python.html">CodeQL for Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ql-training.html">CodeQL training and variant analysis examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../terminology-note.html">Recent terminology changes</a></li>
</ul>

            </div>
    </div>
    <div class="mainBox">
        
  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="codeql-library-for-go">
<h1>CodeQL library for Go<a class="headerlink" href="#codeql-library-for-go" title="Permalink to this headline">¶</a></h1>
<p>When you’re analyzing a Go program, you can make use of the large collection of classes in the CodeQL library for Go.</p>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>CodeQL ships with an extensive library for analyzing Go code.  The classes in this library present
the data from a CodeQL database in an object-oriented form and provide abstractions and predicates
to help you with common analysis tasks.</p>
<p>The library is implemented as a set of QL modules, that is, files with the extension <code class="docutils literal"><span class="pre">.qll</span></code>. The
module <code class="docutils literal"><span class="pre">go.qll</span></code> imports most other standard library modules, so you can include the complete
library by beginning your query with:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="n">go</span>
</pre></div>
</div>
<p>Broadly speaking, the CodeQL library for Go provides two views of a Go code base: at the <cite>syntactic
level</cite>, source code is represented as an <a class="reference external" href="https://wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> (AST), while at the <cite>data-flow level</cite> it is
represented as a <a class="reference external" href="https://en.wikipedia.org/wiki/Data-flow_analysis">data-flow graph</a> (DFG). In
between, there is also an intermediate representation of the program as a control-flow graph (CFG),
though this representation is rarely useful on its own and mostly used to construct the higher-level
DFG representation.</p>
<p>The AST representation captures the syntactic structure of the program. You can use it to reason
about syntactic properties such as the nesting of statements within each other, but also about the
types of expressions and which variable a name refers to.</p>
<p>The DFG, on the other hand, provides an approximation of how data flows through variables and
operations at runtime. It is used, for example, by the security queries to model the way
user-controlled input can propagate through the program. Additionally, the DFG contains information
about which function may be invoked by a given call (taking virtual dispatch through interfaces into
account), as well as control-flow information about the order in which different operations may be
executed at runtime.</p>
<p>As a rule of thumb, you normally want to use the AST only for superficial syntactic queries. Any
analysis involving deeper semantic properties of the program should be done on the DFG.</p>
<p>The rest of this tutorial briefly summarizes the most important classes and predicates provided by
this library, including references to the <a class="reference external" href="https://help.semmle.com/qldoc/go/">detailed API documentation</a> where applicable. We start by giving an overview of the AST
representation, followed by an explanation of names and entities, which are used to represent
name-binding information, and of types and type information. Then we move on to control flow and the
data-flow graph, and finally the call graph and a few advanced topics.</p>
</div>
<div class="section" id="abstract-syntax">
<h2>Abstract syntax<a class="headerlink" href="#abstract-syntax" title="Permalink to this headline">¶</a></h2>
<p>The AST presents the program as a hierarchical structure of nodes, each of which corresponds to a
syntactic element of the program source text. For example, there is an AST node for each expression
and each statement in the program. These AST nodes are arranged into a parent-child relationship
reflecting the nesting of syntactic elements and the order in which inner elements appear in
enclosing ones.</p>
<p>For example, this is the AST for the expression <code class="docutils literal"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y)</span> <span class="pre">*</span> <span class="pre">z</span></code>:</p>
<p><img alt="ast" src="../_images/ast.png" /></p>
<p>It is composed of six AST nodes, representing <code class="docutils literal"><span class="pre">x</span></code>, <code class="docutils literal"><span class="pre">y</span></code>, <code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>, <code class="docutils literal"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y)</span></code>, <code class="docutils literal"><span class="pre">z</span></code> and the
entire expression <code class="docutils literal"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y)</span> <span class="pre">*</span> <span class="pre">z</span></code>, respectively. The AST nodes representing <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> are
children of the AST node representing <code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>, <code class="docutils literal"><span class="pre">x</span></code> being the zeroth child and <code class="docutils literal"><span class="pre">y</span></code> being the
first child, reflecting their order in the program text. Similarly, <code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> is the only child of
<code class="docutils literal"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y)</span></code>, which is the zeroth child of <code class="docutils literal"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y)</span> <span class="pre">*</span> <span class="pre">z</span></code>, whose first child is <code class="docutils literal"><span class="pre">z</span></code>.</p>
<p>All AST nodes belong to class <a class="reference external" href="https://help.semmle.com/qldoc/go/semmle/go/AST.qll/type.AST$AstNode.html">AstNode</a>, which defines generic
tree traversal predicates:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">getChild(i)</span></code>: returns the <code class="docutils literal"><span class="pre">i</span></code>th child of this AST node.</li>
<li><code class="docutils literal"><span class="pre">getAChild()</span></code>: returns any child of this AST node.</li>
<li><code class="docutils literal"><span class="pre">getParent()</span></code>: returns the parent node of this AST node, if any.</li>
</ul>
<p>These predicates should only be used to perform generic AST traversal. To access children of
specific AST node types, the specialized predicates introduced below should be used instead. In
particular, queries should not rely on the numeric indices of child nodes relative to their parent
nodes: these are considered an implementation detail that may change between versions of the
library.</p>
<p>The predicate <code class="docutils literal"><span class="pre">toString()</span></code> in class <code class="docutils literal"><span class="pre">AstNode</span></code> nodes gives a short description of the AST node,
usually just indicating what kind of node it is. The <code class="docutils literal"><span class="pre">toString()</span></code> predicate does <cite>not</cite> provide
access to the source text corresponding to an AST node. The source text is not stored in the
dataset, and hence is not directly accessible to CodeQL queries.</p>
<p>The predicate <code class="docutils literal"><span class="pre">getLocation()</span></code> in class <code class="docutils literal"><span class="pre">AstNode</span></code> returns a <a class="reference external" href="https://help.semmle.com/qldoc/go/semmle/go/Locations.qll/type.Locations$Location.html">Location</a> entity
describing the source location of the program element represented by the AST node. You can use its
member predicates <code class="docutils literal"><span class="pre">getFile()</span></code>, <code class="docutils literal"><span class="pre">getStartLine()</span></code>, <code class="docutils literal"><span class="pre">getStartColumn</span></code>, <code class="docutils literal"><span class="pre">getEndLine()</span></code>, and
<code class="docutils literal"><span class="pre">getEndColumn()</span></code> to obtain information about its file, start line and column, and end line and
column.</p>
<p>The most important subclasses of <a class="reference external" href="https://help.semmle.com/qldoc/go/semmle/go/AST.qll/type.AST$AstNode.html">AstNode</a> are <a class="reference external" href="https://help.semmle.com/qldoc/go/semmle/go/Stmt.qll/type.Stmt$Stmt.html">Stmt</a> and <a class="reference external" href="https://help.semmle.com/qldoc/go/semmle/go/Expr.qll/type.Expr$Expr.html">Expr</a>, which represent
statements and expressions, respectively. This section briefly discusses some of their more
important subclasses and predicates. For a full reference of all the subclasses of <a class="reference external" href="https://help.semmle.com/qldoc/go/semmle/go/Stmt.qll/type.Stmt$Stmt.html">Stmt</a> and <a class="reference external" href="https://help.semmle.com/qldoc/go/semmle/go/Expr.qll/type.Expr$Expr.html">Expr</a>, see
<a class="reference internal" href="ast-class-reference.html"><span class="doc">Abstract syntax tree classes for Go</span></a>.</p>
<div class="section" id="statements">
<h3>Statements<a class="headerlink" href="#statements" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">ExprStmt</span></code>: an expression statement; use <code class="docutils literal"><span class="pre">getExpr()</span></code> to access the expression itself</li>
<li><code class="docutils literal"><span class="pre">Assignment</span></code>: an assignment statement; use <code class="docutils literal"><span class="pre">getLhs(i)</span></code> to access the <code class="docutils literal"><span class="pre">i</span></code>th left-hand side
and <code class="docutils literal"><span class="pre">getRhs(i)</span></code> to access the <code class="docutils literal"><span class="pre">i</span></code>th right-hand side; if there is only a single left-hand side
you can use <code class="docutils literal"><span class="pre">getLhs()</span></code> instead, and similar for the right-hand side<ul>
<li><code class="docutils literal"><span class="pre">SimpleAssignStmt</span></code>: an assignment statement that does not involve a compound operator<ul>
<li><code class="docutils literal"><span class="pre">AssignStmt</span></code>: a plain assignment statement of the form <code class="docutils literal"><span class="pre">lhs</span> <span class="pre">=</span> <span class="pre">rhs</span></code></li>
<li><code class="docutils literal"><span class="pre">DefineStmt</span></code>: a short-hand variable declaration of the form <code class="docutils literal"><span class="pre">lhs</span> <span class="pre">:=</span> <span class="pre">rhs</span></code></li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">CompoundAssignStmt</span></code>: an assignment statement with a compound operator, such as <code class="docutils literal"><span class="pre">lhs</span> <span class="pre">+=</span> <span class="pre">rhs</span></code></li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">IncStmt</span></code>, <code class="docutils literal"><span class="pre">DecStmt</span></code>: an increment statement or a decrement statement, respectively; use
<code class="docutils literal"><span class="pre">getOperand()</span></code> to access the expression being incremented or decremented</li>
<li><code class="docutils literal"><span class="pre">BlockStmt</span></code>: a block of statements between curly braces; use <code class="docutils literal"><span class="pre">getStmt(i)</span></code> to access the
<code class="docutils literal"><span class="pre">i</span></code>th statement in a block</li>
<li><code class="docutils literal"><span class="pre">IfStmt</span></code>: an <code class="docutils literal"><span class="pre">if</span></code> statement; use <code class="docutils literal"><span class="pre">getInit()</span></code>, <code class="docutils literal"><span class="pre">getCond()</span></code>, <code class="docutils literal"><span class="pre">getThen()</span></code>, and
<code class="docutils literal"><span class="pre">getElse()</span></code> to access the (optional) init statement, the condition being checked, the “then”
branch to evaluate if the condition is true, and the (optional) “else” branch to evaluate
otherwise, respectively</li>
<li><code class="docutils literal"><span class="pre">LoopStmt</span></code>: a loop; use <code class="docutils literal"><span class="pre">getBody()</span></code> to access its body<ul>
<li><code class="docutils literal"><span class="pre">ForStmt</span></code>: a <code class="docutils literal"><span class="pre">for</span></code> statement; use <code class="docutils literal"><span class="pre">getInit()</span></code>, <code class="docutils literal"><span class="pre">getCond()</span></code>, and <code class="docutils literal"><span class="pre">getPost()</span></code> to access
the init statement, loop condition, and post statement, respectively, all of which are optional</li>
<li><code class="docutils literal"><span class="pre">RangeStmt</span></code>: a <code class="docutils literal"><span class="pre">range</span></code> statement; use <code class="docutils literal"><span class="pre">getDomain()</span></code> to access the iteration domain, and
<code class="docutils literal"><span class="pre">getKey()</span></code> and <code class="docutils literal"><span class="pre">getValue()</span></code> to access the expressions to which successive keys and values
are assigned, if any</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">GoStmt</span></code>: a <code class="docutils literal"><span class="pre">go</span></code> statement; use <code class="docutils literal"><span class="pre">getCall()</span></code> to access the call expression that is evaluated
in the new goroutine</li>
<li><code class="docutils literal"><span class="pre">DeferStmt</span></code>: a <code class="docutils literal"><span class="pre">defer</span></code> statement; use <code class="docutils literal"><span class="pre">getCall()</span></code> to access the call expression being
deferred</li>
<li><code class="docutils literal"><span class="pre">SendStmt</span></code>: a send statement; use <code class="docutils literal"><span class="pre">getChannel()</span></code> and <code class="docutils literal"><span class="pre">getValue()</span></code> to access the channel and
the value being sent over the channel, respectively</li>
<li><code class="docutils literal"><span class="pre">ReturnStmt</span></code>: a <code class="docutils literal"><span class="pre">return</span></code> statement; use <code class="docutils literal"><span class="pre">getExpr(i)</span></code> to access the <code class="docutils literal"><span class="pre">i</span></code>th returned
expression; if there is only a single returned expression you can use <code class="docutils literal"><span class="pre">getExpr()</span></code> instead</li>
<li><code class="docutils literal"><span class="pre">BranchStmt</span></code>: a statement that interrupts structured control flow; use <code class="docutils literal"><span class="pre">getLabel()</span></code> to get the
optional target label<ul>
<li><code class="docutils literal"><span class="pre">BreakStmt</span></code>: a <code class="docutils literal"><span class="pre">break</span></code> statement</li>
<li><code class="docutils literal"><span class="pre">ContinueStmt</span></code>: a <code class="docutils literal"><span class="pre">continue</span></code> statement</li>
<li><code class="docutils literal"><span class="pre">FallthroughStmt</span></code>: a <code class="docutils literal"><span class="pre">fallthrough</span></code> statement at the end of a switch case</li>
<li><code class="docutils literal"><span class="pre">GotoStmt</span></code>: a <code class="docutils literal"><span class="pre">goto</span></code> statement</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">DeclStmt</span></code>: a declaration statement, use <code class="docutils literal"><span class="pre">getDecl()</span></code> to access the declaration in this
statement; note that one rarely needs to deal with declaration statements directly, since
reasoning about the entities they declare is usually easier</li>
<li><code class="docutils literal"><span class="pre">SwitchStmt</span></code>: a <code class="docutils literal"><span class="pre">switch</span></code> statement; use <code class="docutils literal"><span class="pre">getInit()</span></code> to access the (optional) init statement,
and <code class="docutils literal"><span class="pre">getCase(i)</span></code> to access the <code class="docutils literal"><span class="pre">i</span></code>th <code class="docutils literal"><span class="pre">case</span></code> or <code class="docutils literal"><span class="pre">default</span></code> clause<ul>
<li><code class="docutils literal"><span class="pre">ExpressionSwitchStmt</span></code>: a <code class="docutils literal"><span class="pre">switch</span></code> statement examining the value of an expression</li>
<li><code class="docutils literal"><span class="pre">TypeSwitchStmt</span></code>: a <code class="docutils literal"><span class="pre">switch</span></code> statement examining the type of an expression</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">CaseClause</span></code>: a <code class="docutils literal"><span class="pre">case</span></code> or <code class="docutils literal"><span class="pre">default</span></code> clause in a <code class="docutils literal"><span class="pre">switch</span></code> statement; use <code class="docutils literal"><span class="pre">getExpr(i)</span></code> to
access the <code class="docutils literal"><span class="pre">i</span></code>th expression, and <code class="docutils literal"><span class="pre">getStmt(i)</span></code> to access the <code class="docutils literal"><span class="pre">i</span></code>th statement in the body
of this clause</li>
<li><code class="docutils literal"><span class="pre">SelectStmt</span></code>: a <code class="docutils literal"><span class="pre">select</span></code> statement; use <code class="docutils literal"><span class="pre">getCommClause(i)</span></code> to access the <code class="docutils literal"><span class="pre">i</span></code>th <code class="docutils literal"><span class="pre">case</span></code>
or <code class="docutils literal"><span class="pre">default</span></code> clause</li>
<li><code class="docutils literal"><span class="pre">CommClause</span></code>: a <code class="docutils literal"><span class="pre">case</span></code> or <code class="docutils literal"><span class="pre">default</span></code> clause in a <code class="docutils literal"><span class="pre">select</span></code> statement; use <code class="docutils literal"><span class="pre">getComm()</span></code> to
access the send/receive statement of this clause (not defined for <code class="docutils literal"><span class="pre">default</span></code> clauses), and
<code class="docutils literal"><span class="pre">getStmt(i)</span></code> to access the <code class="docutils literal"><span class="pre">i</span></code>th statement in the body of this clause</li>
<li><code class="docutils literal"><span class="pre">RecvStmt</span></code>: a receive statement in a <code class="docutils literal"><span class="pre">case</span></code> clause of a <code class="docutils literal"><span class="pre">select</span></code> statement; use
<code class="docutils literal"><span class="pre">getLhs(i)</span></code> to access the <code class="docutils literal"><span class="pre">i</span></code>th left-hand side of this statement, and <code class="docutils literal"><span class="pre">getExpr()</span></code> to
access the underlying receive expression</li>
</ul>
</div>
<div class="section" id="expressions">
<h3>Expressions<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a></h3>
<p>Class <code class="docutils literal"><span class="pre">Expression</span></code> has a predicate <code class="docutils literal"><span class="pre">isConst()</span></code> that holds if the expression is a compile-time
constant. For such constant expressions, <code class="docutils literal"><span class="pre">getNumericValue()</span></code> and <code class="docutils literal"><span class="pre">getStringValue()</span></code> can be used
to determine their numeric value and string value, respectively. Note that these predicates are not
defined for expressions whose value cannot be determined at compile time. Also note that the result
type of <code class="docutils literal"><span class="pre">getNumericValue()</span></code> is the QL type <code class="docutils literal"><span class="pre">float</span></code>. If an expression has a numeric value that
cannot be represented as a QL <code class="docutils literal"><span class="pre">float</span></code>, this predicate is also not defined. In such cases, you can
use <code class="docutils literal"><span class="pre">getExactValue()</span></code> to obtain a string representation of the value of the constant.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Ident</span></code>: an identifier; use <code class="docutils literal"><span class="pre">getName()</span></code> to access its name</li>
<li><code class="docutils literal"><span class="pre">SelectorExpr</span></code>: a selector of the form <code class="docutils literal"><span class="pre">base.sel</span></code>; use <code class="docutils literal"><span class="pre">getBase()</span></code> to access the part before
the dot, and <code class="docutils literal"><span class="pre">getSelector()</span></code> for the identifier after the dot</li>
<li><code class="docutils literal"><span class="pre">BasicLit</span></code>: a literal of a basic type; subclasses <code class="docutils literal"><span class="pre">IntLit</span></code>, <code class="docutils literal"><span class="pre">FloatLit</span></code>, <code class="docutils literal"><span class="pre">ImagLit</span></code>,
<code class="docutils literal"><span class="pre">RuneLit</span></code>, and <code class="docutils literal"><span class="pre">StringLit</span></code> represent various specific kinds of literals</li>
<li><code class="docutils literal"><span class="pre">FuncLit</span></code>: a function literal; use <code class="docutils literal"><span class="pre">getBody()</span></code> to access the body of the function</li>
<li><code class="docutils literal"><span class="pre">CompositeLit</span></code>: a composite literal; use <code class="docutils literal"><span class="pre">getKey(i)</span></code> and <code class="docutils literal"><span class="pre">getValue(i)</span></code> to access the
<code class="docutils literal"><span class="pre">i</span></code>th key and the <code class="docutils literal"><span class="pre">i</span></code>th value, respectively</li>
<li><code class="docutils literal"><span class="pre">ParenExpr</span></code>: a parenthesized expression; use <code class="docutils literal"><span class="pre">getExpr()</span></code> to access the expression between the
parentheses</li>
<li><code class="docutils literal"><span class="pre">IndexExpr</span></code>: an index expression <code class="docutils literal"><span class="pre">base[idx]</span></code>; use <code class="docutils literal"><span class="pre">getBase()</span></code> and <code class="docutils literal"><span class="pre">getIndex()</span></code> to access
<code class="docutils literal"><span class="pre">base</span></code> and <code class="docutils literal"><span class="pre">idx</span></code>, respectively</li>
<li><code class="docutils literal"><span class="pre">SliceExpr</span></code>: a slice expression <code class="docutils literal"><span class="pre">base[lo:hi:max]</span></code>; use <code class="docutils literal"><span class="pre">getBase()</span></code>, <code class="docutils literal"><span class="pre">getLow()</span></code>,
<code class="docutils literal"><span class="pre">getHigh()</span></code>, and <code class="docutils literal"><span class="pre">getMax()</span></code> to access <code class="docutils literal"><span class="pre">base</span></code>, <code class="docutils literal"><span class="pre">lo</span></code>, <code class="docutils literal"><span class="pre">hi</span></code>, and <code class="docutils literal"><span class="pre">max</span></code>, respectively;
note that <code class="docutils literal"><span class="pre">lo</span></code>, <code class="docutils literal"><span class="pre">hi</span></code>, and <code class="docutils literal"><span class="pre">max</span></code> can be omitted, in which case the corresponding predicates are not defined</li>
<li><code class="docutils literal"><span class="pre">ConversionExpr</span></code>: a conversion expression <code class="docutils literal"><span class="pre">T(e)</span></code>; use <code class="docutils literal"><span class="pre">getTypeExpr()</span></code> and <code class="docutils literal"><span class="pre">getOperand()</span></code>
to access <code class="docutils literal"><span class="pre">T</span></code> and <code class="docutils literal"><span class="pre">e</span></code>, respectively</li>
<li><code class="docutils literal"><span class="pre">TypeAssertExpr</span></code>: a type assertion <code class="docutils literal"><span class="pre">e.(T)</span></code>; use <code class="docutils literal"><span class="pre">getExpr()</span></code> and <code class="docutils literal"><span class="pre">getTypeExpr()</span></code> to access
<code class="docutils literal"><span class="pre">e</span></code> and <code class="docutils literal"><span class="pre">T</span></code>, respectively</li>
<li><code class="docutils literal"><span class="pre">CallExpr</span></code>: a call expression <code class="docutils literal"><span class="pre">callee(arg0,</span> <span class="pre">...,</span> <span class="pre">argn)</span></code>; use <code class="docutils literal"><span class="pre">getCalleeExpr()</span></code> to access
<code class="docutils literal"><span class="pre">callee</span></code>, and <code class="docutils literal"><span class="pre">getArg(i)</span></code> to access the <code class="docutils literal"><span class="pre">i</span></code>th argument</li>
<li><code class="docutils literal"><span class="pre">StarExpr</span></code>: a star expression, which may be either a pointer-type expression or a
pointer-dereference expression, depending on context; use <code class="docutils literal"><span class="pre">getBase()</span></code> to access the operand of
the star</li>
<li><code class="docutils literal"><span class="pre">TypeExpr</span></code>: an expression that denotes a type</li>
<li><code class="docutils literal"><span class="pre">OperatorExpr</span></code>: an expression with a unary or binary operator; use <code class="docutils literal"><span class="pre">getOperator()</span></code> to access
the operator<ul>
<li><code class="docutils literal"><span class="pre">UnaryExpr</span></code>: an expression with a unary operator; use <code class="docutils literal"><span class="pre">getAnOperand()</span></code> to access the operand
of the operator</li>
<li><code class="docutils literal"><span class="pre">BinaryExpr</span></code>: an expression with a binary operator; use <code class="docutils literal"><span class="pre">getLeftOperand()</span></code> and
<code class="docutils literal"><span class="pre">getRightOperand()</span></code> to access the left and the right operand, respectively<ul>
<li><code class="docutils literal"><span class="pre">ComparisonExpr</span></code>: a binary expression that performs a comparison, including both equality
tests and relational comparisons<ul>
<li><code class="docutils literal"><span class="pre">EqualityTestExpr</span></code>: an equality test, that is, either <code class="docutils literal"><span class="pre">==</span></code> or <code class="docutils literal"><span class="pre">!=</span></code>; the predicate
<code class="docutils literal"><span class="pre">getPolarity()</span></code> has result <code class="docutils literal"><span class="pre">true</span></code> for the former and <code class="docutils literal"><span class="pre">false</span></code> for the latter</li>
<li><code class="docutils literal"><span class="pre">RelationalComparisonExpr</span></code>: a relational comparison; use <code class="docutils literal"><span class="pre">getLesserOperand()</span></code> and
<code class="docutils literal"><span class="pre">getGreaterOperand()</span></code> to access the lesser and greater operand of the comparison,
respectively; <code class="docutils literal"><span class="pre">isStrict()</span></code> holds if this is a strict comparison using <code class="docutils literal"><span class="pre">&lt;</span></code> or <code class="docutils literal"><span class="pre">&gt;</span></code>,
as opposed to <code class="docutils literal"><span class="pre">&lt;=</span></code> or <code class="docutils literal"><span class="pre">&gt;=</span></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="names">
<h3>Names<a class="headerlink" href="#names" title="Permalink to this headline">¶</a></h3>
<p>While <code class="docutils literal"><span class="pre">Ident</span></code> and <code class="docutils literal"><span class="pre">SelectorExpr</span></code> are very useful classes, they are often too general: <code class="docutils literal"><span class="pre">Ident</span></code>
covers all identifiers in a program, including both identifiers appearing in a declaration as well
as references, and does not distinguish between names referring to packages, types, variables,
constants, functions, or statement labels. Similarly, a <code class="docutils literal"><span class="pre">SelectorExpr</span></code> might refer to a package, a
type, a function, or a method.</p>
<p>Class <code class="docutils literal"><span class="pre">Name</span></code> and its subclasses provide a more fine-grained mapping of this space, organized along
the two axes of structure and namespace. In terms of structure, a name can be a <code class="docutils literal"><span class="pre">SimpleName</span></code>,
meaning that it is a simple identifier (and hence an <code class="docutils literal"><span class="pre">Ident</span></code>), or it can be a <code class="docutils literal"><span class="pre">QualifiedName</span></code>,
meaning that it is a qualified identifier (and hence a <code class="docutils literal"><span class="pre">SelectorExpr</span></code>). In terms of namespacing, a
<code class="docutils literal"><span class="pre">Name</span></code> can be a <code class="docutils literal"><span class="pre">PackageName</span></code>, <code class="docutils literal"><span class="pre">TypeName</span></code>, <code class="docutils literal"><span class="pre">ValueName</span></code>, or <code class="docutils literal"><span class="pre">LabelName</span></code>. A <code class="docutils literal"><span class="pre">ValueName</span></code>,
in turn, can be either a <code class="docutils literal"><span class="pre">ConstantName</span></code>, a <code class="docutils literal"><span class="pre">VariableName</span></code>, or a <code class="docutils literal"><span class="pre">FunctionName</span></code>, depending on
what sort of entity the name refers to.</p>
<p>A related abstraction is provided by class <code class="docutils literal"><span class="pre">ReferenceExpr</span></code>: a reference expression is an
expression that refers to a variable, a constant, a function, a field, or an element of an array or
a slice. Use predicates <code class="docutils literal"><span class="pre">isLvalue()</span></code> and <code class="docutils literal"><span class="pre">isRvalue()</span></code> to determine whether a reference
expression appears in a syntactic context where it is assigned to or read from, respectively.</p>
<p>Finally, <code class="docutils literal"><span class="pre">ValueExpr</span></code> generalizes <code class="docutils literal"><span class="pre">ReferenceExpr</span></code> to include all other kinds of expressions that
can be evaluated to a value (as opposed to expressions that refer to a package, a type, or a
statement label).</p>
</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<p>At the syntactic level, functions appear in two forms: in function declarations (represented by
class <code class="docutils literal"><span class="pre">FuncDecl</span></code>) and as function literals (represented by class <code class="docutils literal"><span class="pre">FuncLit</span></code>). Since it is often
convenient to reason about functions of either kind, these two classes share a common superclass
<code class="docutils literal"><span class="pre">FuncDef</span></code>, which defines a few useful member predicates:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">getBody()</span></code> provides access to the function body</li>
<li><code class="docutils literal"><span class="pre">getName()</span></code> gets the function name; it is undefined for function literals, which do not have a
name</li>
<li><code class="docutils literal"><span class="pre">getParameter(i)</span></code> gets the <code class="docutils literal"><span class="pre">i</span></code>th parameter of the function</li>
<li><code class="docutils literal"><span class="pre">getResultVar(i)</span></code> gets the <code class="docutils literal"><span class="pre">i</span></code>th result variable of the function; if there is only
one result, <code class="docutils literal"><span class="pre">getResultVar()</span></code> can be used to access it</li>
<li><code class="docutils literal"><span class="pre">getACall()</span></code> gets a data-flow node (see below) representing a call to this function</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="entities-and-name-binding">
<h2>Entities and name binding<a class="headerlink" href="#entities-and-name-binding" title="Permalink to this headline">¶</a></h2>
<p>Not all elements of a code base can be represented as AST nodes. For example, functions defined in
the standard library or in a dependency do not have a source-level definition within the source code
of the program itself, and built-in functions like <code class="docutils literal"><span class="pre">len</span></code> do not have a definition at all. Hence
functions cannot simplify be identified with their definition, and similarly for variables, types,
and so on.</p>
<p>To smooth over this difference and provide a unified view of functions no matter where they are
defined, the Go library introduces the concept of an <cite>entity</cite>. An entity is a named program element,
that is, a package, a type, a constant, a variable, a field, a function, or a label. All entities
belong to class <code class="docutils literal"><span class="pre">Entity</span></code>, which defines a few useful predicates:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">getName()</span></code> gets the name of the entity</li>
<li><code class="docutils literal"><span class="pre">hasQualifiedName(pkg,</span> <span class="pre">n)</span></code> holds if this entity is declared in package <code class="docutils literal"><span class="pre">pkg</span></code> and has name
<code class="docutils literal"><span class="pre">n</span></code>; this predicate is only defined for types, functions, and package-level variables and
constants (but not for methods or local variables)</li>
<li><code class="docutils literal"><span class="pre">getDeclaration()</span></code> connects an entity to its declaring identifier, if any</li>
<li><code class="docutils literal"><span class="pre">getAReference()</span></code> gets a <code class="docutils literal"><span class="pre">Name</span></code> that refers to this entity</li>
</ul>
</div></blockquote>
<p>Conversely, class <code class="docutils literal"><span class="pre">Name</span></code> defines a predicate <code class="docutils literal"><span class="pre">getTarget()</span></code> that gets the entity to which the
name refers.</p>
<p>Class <code class="docutils literal"><span class="pre">Entity</span></code> has several subclasses representing specific kinds of entities: <code class="docutils literal"><span class="pre">PackageEntity</span></code>
for packages; <code class="docutils literal"><span class="pre">TypeEntity</span></code> for types; <code class="docutils literal"><span class="pre">ValueEntity</span></code> for constants (<code class="docutils literal"><span class="pre">Constant</span></code>), variables
(<code class="docutils literal"><span class="pre">Variable</span></code>), and functions (<code class="docutils literal"><span class="pre">Function</span></code>); and <code class="docutils literal"><span class="pre">Label</span></code> for statement labels.</p>
<p>Class <code class="docutils literal"><span class="pre">Variable</span></code>, in turn, has a few subclasses representing specific kinds of variables: a
<code class="docutils literal"><span class="pre">LocalVariable</span></code> is a variable declared in a local scope, that is, not at package level;
<code class="docutils literal"><span class="pre">ReceiverVariable</span></code>, <code class="docutils literal"><span class="pre">Parameter</span></code> and <code class="docutils literal"><span class="pre">ResultVariable</span></code> describe receivers, parameters and
results, respectively, and define a predicate <code class="docutils literal"><span class="pre">getFunction()</span></code> to access the corresponding
function. Finally, class <code class="docutils literal"><span class="pre">Field</span></code> represents struct fields, and provides a member predicate
<code class="docutils literal"><span class="pre">hasQualifiedName(pkg,</span> <span class="pre">tp,</span> <span class="pre">f)</span></code> that holds if this field has name <code class="docutils literal"><span class="pre">f</span></code> and belongs to type <code class="docutils literal"><span class="pre">tp</span></code>
in package <code class="docutils literal"><span class="pre">pkg</span></code>. (Note that due to embedding the same field can belong to multiple types.)</p>
<p>Class <code class="docutils literal"><span class="pre">Function</span></code> has a subclass <code class="docutils literal"><span class="pre">Method</span></code> representing methods (including both interface methods
and methods defined on a named type). Similar to <code class="docutils literal"><span class="pre">Field</span></code>, <code class="docutils literal"><span class="pre">Method</span></code> provides a member predicate
<code class="docutils literal"><span class="pre">hasQualifiedName(pkg,</span> <span class="pre">tp,</span> <span class="pre">m)</span></code> that holds if this method has name <code class="docutils literal"><span class="pre">m</span></code> and belongs to type <code class="docutils literal"><span class="pre">tp</span></code>
in package <code class="docutils literal"><span class="pre">pkg</span></code>. Predicate <code class="docutils literal"><span class="pre">implements(m2)</span></code> holds if this method implements method <code class="docutils literal"><span class="pre">m2</span></code>, that
is, it has the same name and signature as <code class="docutils literal"><span class="pre">m2</span></code> and it belongs to a type that implements the
interface to which <code class="docutils literal"><span class="pre">m2</span></code> belongs. For any function, <code class="docutils literal"><span class="pre">getACall()</span></code> provides access to call sites
that may call this function, possibly through virtual dispatch.</p>
<p>Finally, module <code class="docutils literal"><span class="pre">Builtin</span></code> provides a convenient way of looking up the entities corresponding to
built-in functions and types. For example, <code class="docutils literal"><span class="pre">Builtin::len()</span></code> is the entity representing the
built-in function <code class="docutils literal"><span class="pre">len</span></code>, <code class="docutils literal"><span class="pre">Builtin::bool()</span></code> is the <code class="docutils literal"><span class="pre">bool</span></code> type, and <code class="docutils literal"><span class="pre">Builtin::nil()</span></code> is the
value <code class="docutils literal"><span class="pre">nil</span></code>.</p>
</div>
<div class="section" id="type-information">
<h2>Type information<a class="headerlink" href="#type-information" title="Permalink to this headline">¶</a></h2>
<p>Types are represented by class <code class="docutils literal"><span class="pre">Type</span></code> and its subclasses, such as <code class="docutils literal"><span class="pre">BoolType</span></code> for the built-in
type <code class="docutils literal"><span class="pre">bool</span></code>; <code class="docutils literal"><span class="pre">NumericType</span></code> for the various numeric types including <code class="docutils literal"><span class="pre">IntType</span></code>, <code class="docutils literal"><span class="pre">Uint8Type</span></code>,
<code class="docutils literal"><span class="pre">Float64Type</span></code> and others; <code class="docutils literal"><span class="pre">StringType</span></code> for the type <code class="docutils literal"><span class="pre">string</span></code>; <code class="docutils literal"><span class="pre">NamedType</span></code>, <code class="docutils literal"><span class="pre">ArrayType</span></code>,
<code class="docutils literal"><span class="pre">SliceType</span></code>, <code class="docutils literal"><span class="pre">StructType</span></code>, <code class="docutils literal"><span class="pre">InterfaceType</span></code>, <code class="docutils literal"><span class="pre">PointerType</span></code>, <code class="docutils literal"><span class="pre">MapType</span></code>, <code class="docutils literal"><span class="pre">ChanType</span></code> for
named types, arrays, slices, structs, interfaces, pointers, maps, and channels, respectively.
Finally, <code class="docutils literal"><span class="pre">SignatureType</span></code> represents function types.</p>
<p>Note that the type <code class="docutils literal"><span class="pre">BoolType</span></code> is distinct from the entity <code class="docutils literal"><span class="pre">Builtin::bool()</span></code>: the latter views
<code class="docutils literal"><span class="pre">bool</span></code> as a declared entity, the former as a type. You can, however, map from types to their
corresponding entity (if any) using the predicate <code class="docutils literal"><span class="pre">getEntity()</span></code>.</p>
<p>Class <code class="docutils literal"><span class="pre">Expr</span></code> and class <code class="docutils literal"><span class="pre">Entity</span></code> both define a predicate <code class="docutils literal"><span class="pre">getType()</span></code> to determine the type of
an expression or entity. If the type of an expression or entity cannot be determined (for example
because some dependency could not be found during extraction), it will be associated with an invalid
type of class <code class="docutils literal"><span class="pre">InvalidType</span></code>.</p>
</div>
<div class="section" id="control-flow">
<h2>Control flow<a class="headerlink" href="#control-flow" title="Permalink to this headline">¶</a></h2>
<p>Most CodeQL query writers will rarely use the control-flow representation of a program directly, but
it is nevertheless useful to understand how it works.</p>
<p>Unlike the abstract syntax tree, which views the program as a hierarchy of AST nodes, the
control-flow graph views it as a collection of <cite>control-flow nodes</cite>, each representing a single
operation performed at runtime. These nodes are connected to each other by (directed) edges
representing the order in which operations are performed.</p>
<p>For example, consider the following code snippet:</p>
<div class="highlight-go"><div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">x</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">f</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nx">x</span>
</pre></div>
</div>
<p>In the AST, this is represented as an <code class="docutils literal"><span class="pre">IfStmt</span></code> and a <code class="docutils literal"><span class="pre">ReturnStmt</span></code>, with the former having an
<code class="docutils literal"><span class="pre">NeqExpr</span></code> and a <code class="docutils literal"><span class="pre">BlockStmt</span></code> as its children, and so on. This provides a very detailed picture of
the syntactic structure of the code, but it does not immediately help us reason about the order
in which the various operations such as the comparison and the assignment are performed.</p>
<p>In the CFG, there are nodes corresponding to <code class="docutils literal"><span class="pre">x</span> <span class="pre">:=</span> <span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">p</span> <span class="pre">!=</span> <span class="pre">nil</span></code>, <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">p.f</span></code>, and <code class="docutils literal"><span class="pre">return</span>
<span class="pre">x</span></code>, as well as a few others. The edges between these nodes model the possible execution orders of
these statements and expressions, and look as follows (simplified somewhat for presentational
purposes):</p>
<p><img alt="cfg" src="../_images/cfg.png" /></p>
<p>For example, the edge from <code class="docutils literal"><span class="pre">p</span> <span class="pre">!=</span> <span class="pre">nil</span></code> to <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">p.f</span></code> models the case where the comparison
evaluates to <code class="docutils literal"><span class="pre">true</span></code> and the “then” branch is evaluated, while the edge from <code class="docutils literal"><span class="pre">p</span> <span class="pre">!=</span> <span class="pre">nil</span></code> to
<code class="docutils literal"><span class="pre">return</span> <span class="pre">x</span></code> models the case where the comparison evaluates to <code class="docutils literal"><span class="pre">false</span></code> and the “then” branch is
skipped.</p>
<p>Note, in particular, that a CFG node can have multiple outgoing edges (like from <code class="docutils literal"><span class="pre">p</span> <span class="pre">!=</span> <span class="pre">nil</span></code>) as
well as multiple incoming edges (like into <code class="docutils literal"><span class="pre">return</span> <span class="pre">x</span></code>) to represent control-flow branching at
runtime.</p>
<p>Also note that only AST nodes that perform some kind of operation on values have a corresponding CFG
node. This includes expressions (such as the comparison <code class="docutils literal"><span class="pre">p</span> <span class="pre">!=</span> <span class="pre">nil</span></code>), assignment statements (such
as <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">p.f</span></code>) and return statements (such as <code class="docutils literal"><span class="pre">return</span> <span class="pre">x</span></code>), but not statements that serve a purely
syntactic purpose (such as block statements) and statements whose semantics is already reflected by
the CFG edges (such as <code class="docutils literal"><span class="pre">if</span></code> statements).</p>
<p>It is important to point out that the control-flow graph provided by the CodeQL libraries for Go
only models <cite>local</cite> control flow, that is, flow within a single function. Flow from function calls
to the function they invoke, for example, is not represented by control-flow edges.</p>
<p>In CodeQL, control-flow nodes are represented by class <code class="docutils literal"><span class="pre">ControlFlow::Node</span></code>, and the edges between
nodes are captured by the member predicates <code class="docutils literal"><span class="pre">getASuccessor()</span></code> and <code class="docutils literal"><span class="pre">getAPredecessor()</span></code> of
<code class="docutils literal"><span class="pre">ControlFlow::Node</span></code>. In addition to control-flow nodes representing runtime operations, each
function also has a synthetic entry node and an exit node, representing the start and end of an
execution of the function, respectively. These exist to ensure that the control-flow graph
corresponding to a function has a unique entry node and a unique exit node, which is required for
many standard control-flow analysis algorithms.</p>
</div>
<div class="section" id="data-flow">
<h2>Data flow<a class="headerlink" href="#data-flow" title="Permalink to this headline">¶</a></h2>
<p>At the data-flow level, the program is thought of as a collection of <cite>data-flow nodes</cite>. These nodes
are connected to each other by (directed) edges representing the way data flows through the program
at runtime.</p>
<p>For example, there are data-flow nodes corresponding to expressions and other data-flow nodes
corresponding to variables (<a class="reference external" href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA variables</a>, to be precise). Here is the
data-flow graph corresponding to the code snippet shown above, ignoring SSA conversion for
simplicity:</p>
<p><img alt="dfg" src="../_images/dfg.png" /></p>
<p>Note that unlike in the control-flow graph, the assignments <code class="docutils literal"><span class="pre">x</span> <span class="pre">:=</span> <span class="pre">0</span></code> and <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">p.f</span></code> are not
represented as nodes. Instead, they are expressed as edges between the node representing the
right-hand side of the assignment and the node representing the variable on the left-hand side. For
any subsequent uses of that variable, there is a data-flow edge from the variable to that use, so by
following the edges in the data-flow graph we can trace the flow of values through variables at
runtime.</p>
<p>It is important to point out that the data-flow graph provided by the CodeQL libraries for Go only
models <cite>local</cite> flow, that is, flow within a single function. Flow from arguments in a function call
to the corresponding function parameters, for example, is not represented by data-flow edges.</p>
<p>In CodeQL, data-flow nodes are represented by class <code class="docutils literal"><span class="pre">DataFlow::Node</span></code>, and the edges between nodes
are captured by the predicate <code class="docutils literal"><span class="pre">DataFlow::localFlowStep</span></code>. The predicate <code class="docutils literal"><span class="pre">DataFlow::localFlow</span></code>
generalizes this from a single flow step to zero or more flow steps.</p>
<p>Most expressions have a corresponding data-flow node; exceptions include type expressions, statement
labels and other expressions that do not have a value, as well as short-circuiting operators. To map
from the AST node of an expression to the corresponding DFG node, use <code class="docutils literal"><span class="pre">DataFlow::exprNode</span></code>. Note
that the AST node and the DFG node are different entities and cannot be used interchangeably.</p>
<p>There is also a predicate <code class="docutils literal"><span class="pre">asExpr()</span></code> on <code class="docutils literal"><span class="pre">DataFlow::Node</span></code> that allows you to recover the
expression underlying a DFG node. However, this predicate should be used with caution, since many
data-flow nodes do not correspond to an expression, and so this predicate will not be defined for
them.</p>
<p>Similar to <code class="docutils literal"><span class="pre">Expr</span></code>, <code class="docutils literal"><span class="pre">DataFlow::Node</span></code> has a member predicate <code class="docutils literal"><span class="pre">getType()</span></code> to determine the type
of a node, as well as predicates <code class="docutils literal"><span class="pre">getNumericValue()</span></code>, <code class="docutils literal"><span class="pre">getStringValue()</span></code>, and
<code class="docutils literal"><span class="pre">getExactValue()</span></code> to retrieve the value of a node if it is constant.</p>
<p>Important subclasses of <code class="docutils literal"><span class="pre">DataFlow::Node</span></code> include:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">DataFlow::CallNode</span></code>: a function call or method call; use <code class="docutils literal"><span class="pre">getArgument(i)</span></code> and
<code class="docutils literal"><span class="pre">getResult(i)</span></code> to obtain the data-flow nodes corresponding to the <code class="docutils literal"><span class="pre">i</span></code>th argument and the
<code class="docutils literal"><span class="pre">i</span></code>th result of this call, respectively; if there is only a single result, <code class="docutils literal"><span class="pre">getResult()</span></code>
will return it</li>
<li><code class="docutils literal"><span class="pre">DataFlow::ParameterNode</span></code>: a parameter of a function; use <code class="docutils literal"><span class="pre">asParameter()</span></code> to access the
corresponding AST node</li>
<li><code class="docutils literal"><span class="pre">DataFlow::BinaryOperationNode</span></code>: an operation involving a binary operator; each <code class="docutils literal"><span class="pre">BinaryExpr</span></code>
has a corresponding <code class="docutils literal"><span class="pre">BinaryOperationNode</span></code>, but there are also binary operations that are not
explicit at the AST level, such as those arising from compound assignments and
increment/decrement statements; at the AST level, <code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">1</span></code>, and <code class="docutils literal"><span class="pre">x++</span></code> are
represented by different kinds of AST nodes, while at the DFG level they are all modeled as a
binary operation node with operands <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">1</span></code></li>
<li><code class="docutils literal"><span class="pre">DataFlow::UnaryOperationNode</span></code>: analogous, but for unary operators<ul>
<li><code class="docutils literal"><span class="pre">DataFlow::PointerDereferenceNode</span></code>: a pointer dereference, either explicit in an expression
of the form <code class="docutils literal"><span class="pre">*p</span></code>, or implicit in a field or method reference through a pointer</li>
<li><code class="docutils literal"><span class="pre">DataFlow::AddressOperationNode</span></code>: analogous, but for taking the address of an entity</li>
<li><code class="docutils literal"><span class="pre">DataFlow::RelationalComparisonNode</span></code>, <code class="docutils literal"><span class="pre">DataFlow::EqualityTestNode</span></code>: data-flow nodes
corresponding to <code class="docutils literal"><span class="pre">RelationalComparisonExpr</span></code> and <code class="docutils literal"><span class="pre">EqualityTestExpr</span></code> AST nodes</li>
</ul>
</li>
</ul>
</div></blockquote>
<p>Finally, classes <code class="docutils literal"><span class="pre">Read</span></code> and <code class="docutils literal"><span class="pre">Write</span></code> represent, respectively, a read or a write of a variable, a
field, or an element of an array, a slice or a map. Use their member predicates <code class="docutils literal"><span class="pre">readsVariable</span></code>,
<code class="docutils literal"><span class="pre">writesVariable</span></code>, <code class="docutils literal"><span class="pre">readsField</span></code>, <code class="docutils literal"><span class="pre">writesField</span></code>, <code class="docutils literal"><span class="pre">readsElement</span></code>, and <code class="docutils literal"><span class="pre">writesElement</span></code> to
determine what the read/write refers to.</p>
</div>
<div class="section" id="call-graph">
<h2>Call graph<a class="headerlink" href="#call-graph" title="Permalink to this headline">¶</a></h2>
<p>The call graph connects function (and method) calls to the functions they invoke. Call graph
information is made available by two member predicates on <code class="docutils literal"><span class="pre">DataFlow::CallNode</span></code>: <code class="docutils literal"><span class="pre">getTarget()</span></code>
returns the declared target of a call, while <code class="docutils literal"><span class="pre">getACallee()</span></code> returns all possible actual functions
a call may invoke at runtime.</p>
<p>These two predicates differ in how they handle calls to interface methods: while <code class="docutils literal"><span class="pre">getTarget()</span></code>
will return the interface method itself, <code class="docutils literal"><span class="pre">getACallee()</span></code> will return all concrete methods that
implement the interface method.</p>
</div>
<div class="section" id="global-data-flow-and-taint-tracking">
<h2>Global data flow and taint tracking<a class="headerlink" href="#global-data-flow-and-taint-tracking" title="Permalink to this headline">¶</a></h2>
<p>The predicates <code class="docutils literal"><span class="pre">DataFlow::localFlowStep</span></code> and <code class="docutils literal"><span class="pre">DataFlow::localFlow</span></code> are useful for reasoning
about the flow of values in a single function. However, more advanced use cases, particularly in
security analysis, will invariably require reasoning about global data flow, including flow into,
out of, and across function calls, and through fields.</p>
<p>In CodeQL, such reasoning is expressed in terms of <cite>data-flow configurations</cite>. A data-flow
configuration has three ingredients: sources, sinks, and barriers (also called sanitizers), all of
which are sets of data-flow nodes. Given these three sets, CodeQL provides a general mechanism for
finding paths from a source to a sink, possibly going into and out of functions and fields, but
never flowing through a barrier.</p>
<p>To define a data-flow configuration, you can define a subclass of <code class="docutils literal"><span class="pre">DataFlow::Configuration</span></code>,
overriding the member predicates <code class="docutils literal"><span class="pre">isSource</span></code>, <code class="docutils literal"><span class="pre">isSink</span></code>, and <code class="docutils literal"><span class="pre">isBarrier</span></code> to define the sets of
sources, sinks, and barriers.</p>
<p>Going beyond pure data flow, many security analyses need to perform more general <cite>taint tracking</cite>,
which also considers flow through value-transforming operations such as string operations. To track
taint, you can define a subclass of <code class="docutils literal"><span class="pre">TaintTracking::Configuration</span></code>, which works similar to
data-flow configurations.</p>
<p>A detailed exposition of global data flow and taint tracking is out of scope for this brief
introduction. For a general overview of data flow and taint tracking, see “<a class="reference external" href="https://help.semmle.com/QL/learn-ql/intro-to-data-flow.html">About data flow analysis</a>.”</p>
</div>
<div class="section" id="advanced-libraries">
<h2>Advanced libraries<a class="headerlink" href="#advanced-libraries" title="Permalink to this headline">¶</a></h2>
<p>Finally, we briefly describe a few concepts and libraries that are useful for advanced query
writers.</p>
<div class="section" id="basic-blocks-and-dominance">
<h3>Basic blocks and dominance<a class="headerlink" href="#basic-blocks-and-dominance" title="Permalink to this headline">¶</a></h3>
<p>Many important control-flow analyses organize control-flow nodes into <a class="reference external" href="https://en.wikipedia.org/wiki/Basic_block">basic blocks</a>, which are maximal straight-line sequences of
control-flow nodes without any branching. In the CodeQL libraries, basic blocks are represented by
class <code class="docutils literal"><span class="pre">BasicBlock</span></code>. Each control-flow node belongs to a basic block. You can use the predicate
<code class="docutils literal"><span class="pre">getBasicBlock()</span></code> in class <code class="docutils literal"><span class="pre">ControlFlow::Node</span></code> and the predicate <code class="docutils literal"><span class="pre">getNode(i)</span></code> in
<code class="docutils literal"><span class="pre">BasicBlock</span></code> to move from one to the other.</p>
<p>Dominance is a standard concept in control-flow analysis: a basic block <code class="docutils literal"><span class="pre">dom</span></code> is said to
<cite>dominate</cite> a basic block <code class="docutils literal"><span class="pre">bb</span></code> if any path through the control-flow graph from the entry node to
the first node of <code class="docutils literal"><span class="pre">bb</span></code> must pass through <code class="docutils literal"><span class="pre">dom</span></code>. In other words, whenever program execution
reaches the beginning of <code class="docutils literal"><span class="pre">bb</span></code>, it must have come through <code class="docutils literal"><span class="pre">dom</span></code>. Each basic block is moreover
considered to dominate itself.</p>
<p>Dually, a basic block <code class="docutils literal"><span class="pre">postdom</span></code> is said to <cite>post-dominate</cite> a basic block <code class="docutils literal"><span class="pre">bb</span></code> if any path
through the control-flow graph from the last node of <code class="docutils literal"><span class="pre">bb</span></code> to the exit node must pass through
<code class="docutils literal"><span class="pre">postdom</span></code>. In other words, after program execution leaves <code class="docutils literal"><span class="pre">bb</span></code>, it must eventually reach
<code class="docutils literal"><span class="pre">postdom</span></code>.</p>
<p>These two concepts are captured by two member predicates <code class="docutils literal"><span class="pre">dominates</span></code> and <code class="docutils literal"><span class="pre">postDominates</span></code> of class
<code class="docutils literal"><span class="pre">BasicBlock</span></code>.</p>
</div>
<div class="section" id="condition-guard-nodes">
<h3>Condition guard nodes<a class="headerlink" href="#condition-guard-nodes" title="Permalink to this headline">¶</a></h3>
<p>A condition guard node is a synthetic control-flow node that records the fact that at some point in
the control-flow graph the truth value of a condition is known. For example, consider again the code snippet we saw above:</p>
<div class="highlight-go"><div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">x</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">f</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nx">x</span>
</pre></div>
</div>
<p>At the beginning of the “then” branch <code class="docutils literal"><span class="pre">p</span></code> is known not be <code class="docutils literal"><span class="pre">nil</span></code>. This knowledge is encoded in
the control-flow graph by a condition guard node preceding the assignment to <code class="docutils literal"><span class="pre">x</span></code>, recording the
fact that <code class="docutils literal"><span class="pre">p</span> <span class="pre">!=</span> <span class="pre">nil</span></code> is <code class="docutils literal"><span class="pre">true</span></code> at this point:</p>
<p><img alt="cfg2" src="../_images/cfg2.png" /></p>
<p>A typical use of this information would be in an analysis that looks for <code class="docutils literal"><span class="pre">nil</span></code> dereferences: such
an analysis would be able to conclude that the field read <code class="docutils literal"><span class="pre">p.f</span></code> is safe because it is immediately
preceded by a condition guard node guaranteeing that <code class="docutils literal"><span class="pre">p</span></code> is not <code class="docutils literal"><span class="pre">nil</span></code>.</p>
<p>In CodeQL, condition guard nodes are represented by class <code class="docutils literal"><span class="pre">ControlFlow::ConditionGuardNode</span></code> which
offers a variety of member predicates to reason about which conditions a guard node guarantees.</p>
</div>
<div class="section" id="static-single-assignment-form">
<h3>Static single-assignment form<a class="headerlink" href="#static-single-assignment-form" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Static_single_assignment_form">Static single-assignment form</a> (SSA
form for short) is a program representation in which the original program variables are mapped onto
more fine-grained <cite>SSA variables</cite>. Each SSA variable has exactly one definition, so program
variables with multiple assignments correspond to multiple SSA variables.</p>
<p>Most of the time query authors do not have to deal with SSA form directly. The data-flow graph uses
it under the hood, and so most of the benefits derived from SSA can be gained by simply using the
data-flow graph.</p>
<p>For example, the data-flow graph for our running example actually looks more like this:</p>
<p><img alt="ssa" src="../_images/ssa.png" /></p>
<p>Note that the program variable <code class="docutils literal"><span class="pre">x</span></code> has been mapped onto three distinct SSA variables <code class="docutils literal"><span class="pre">x1</span></code>,
<code class="docutils literal"><span class="pre">x2</span></code>, and <code class="docutils literal"><span class="pre">x3</span></code>. In this case there is not much benefit to such a representation, but in general
SSA form has well-known advantages for data-flow analysis for which we refer to the literature.</p>
<p>If you do need to work with raw SSA variables, they are represented by the class <code class="docutils literal"><span class="pre">SsaVariable</span></code>.
Class <code class="docutils literal"><span class="pre">SsaDefinition</span></code> represents definitions of SSA variables, which have a one-to-one
correspondence with <code class="docutils literal"><span class="pre">SsaVariable</span></code>s. Member predicates <code class="docutils literal"><span class="pre">getDefinition()</span></code> and <code class="docutils literal"><span class="pre">getVariable()</span></code>
exist to map from one to the other. You can use member predicate <code class="docutils literal"><span class="pre">getAUse()</span></code> of <code class="docutils literal"><span class="pre">SsaVariable</span></code> to
look for uses of an SSA variable. To access the program variable underlying an SSA variable, use
member predicate <code class="docutils literal"><span class="pre">getSourceVariable()</span></code>.</p>
</div>
<div class="section" id="global-value-numbering">
<h3>Global value numbering<a class="headerlink" href="#global-value-numbering" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Value_numbering">Global value numbering</a> is a technique for
determining when two computations in a program are guaranteed to yield the same result. This is done
by associating with each data-flow node an abstract representation of its value (conventionally
called a <cite>value number</cite>, even though in practice it is not usually a number) such that identical
computations are represented by identical value numbers.</p>
<p>Since this is an undecidable problem, global value numbering is <cite>conservative</cite> in the sense that if
two data-flow nodes have the same value number they are guaranteed to have the same value at
runtime, but not conversely. (That is, there may be data-flow nodes that do, in fact, always
evaluate to the same value, but their value numbers are different.)</p>
<p>In the CodeQL libraries for Go, you can use the <code class="docutils literal"><span class="pre">globalValueNumber(nd)</span></code> predicate to compute the
global value number for a data-flow node <code class="docutils literal"><span class="pre">nd</span></code>. Value numbers are represented as an opaque QL type
<code class="docutils literal"><span class="pre">GVN</span></code> that provides very little information. Usually, all you need to do with global value numbers
is to compare them to each other to determine whether two data-flow nodes have the same value.</p>
</div>
</div>
<div class="section" id="further-reading">
<h2>Further reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://github.com/github/codeql-go/tree/main/ql/src">CodeQL queries for Go</a></li>
<li><a class="reference external" href="https://github.com/github/codeql-go/tree/main/ql/examples">Example queries for Go</a></li>
<li><a class="reference external" href="https://help.semmle.com/qldoc/go/">CodeQL library reference for Go</a></li>
</ul>
<ul class="simple">
<li>“<a class="reference external" href="https://help.semmle.com/QL/ql-handbook">QL language reference</a>”</li>
<li>“<a class="reference external" href="https://help.semmle.com/codeql/codeql-tools.html">CodeQL tools</a>”</li>
</ul>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    </div>
    <div class="privacy">
            <a target="_blank" href="https://help.semmle.com/privacy-policy.html" alt="Privacy policy and tracking preferences" title="Privacy policy and tracking preferences">Privacy policy</a>
    </div>
    
</div>


 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .name").show();
        $(".toggle .name").click(function() {
            $(this).parent().children().not(".name").toggle(400);
            $(this).parent().children(".name").toggleClass("open");
        })
    });
</script>

  </body>
</html>