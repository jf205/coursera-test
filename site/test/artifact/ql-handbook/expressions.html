
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Expressions &#8212; QL language reference</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.25',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Formulas" href="formulas.html" />
    <link rel="prev" title="Variables" href="variables.html" />
  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i) {w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var  f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true; j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);}) (window,document,'script','dataLayer','GTM-5Q9DBRM');</script>
  <!-- End Google Tag Manager -->
  
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  </head>
  <body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q9DBRM" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<div id="siteBanner">
    <div class="logocontainer">
        <a href="https://securitylab.github.com" id="Header-logo" class="">
                <svg width="100%" height="100%" viewBox="0 0 696 160" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <rect width="696" height="160" fill="white"/>
                    <path fill-rule="evenodd" clip-rule="evenodd" d="M80.0397 32.8C53.4747 32.8 32 54.4342 32 81.1965C32 102.59 45.7597 120.699 64.8483 127.109C67.2344 127.59 68.1093 126.067 68.1093 124.785C68.1093 123.664 68.0297 119.818 68.0297 115.811C54.6677 118.696 51.884 110.042 51.884 110.042C49.7365 104.433 46.5551 102.991 46.5551 102.991C42.1806 100.026 46.8732 100.026 46.8732 100.026C51.7249 100.347 54.27 104.994 54.27 104.994C58.565 112.366 65.4846 110.283 68.2684 109C68.666 105.876 69.9386 103.712 71.2907 102.51C60.6329 101.388 49.4184 97.2219 49.4184 78.6325C49.4184 73.3441 51.3272 69.0173 54.3496 65.6519C53.8724 64.45 52.2021 59.4822 54.8268 52.8317C54.8268 52.8317 58.8831 51.5496 68.0297 57.7995C71.8475 56.7579 75.9833 56.197 80.0397 56.197C84.096 56.197 88.2319 56.7579 92.0496 57.7995C101.196 51.5496 105.253 52.8317 105.253 52.8317C107.877 59.4822 106.207 64.45 105.73 65.6519C108.832 69.0173 110.661 73.3441 110.661 78.6325C110.661 97.2219 99.4464 101.308 88.7091 102.51C90.4589 104.033 91.97 106.917 91.97 111.484C91.97 117.975 91.8905 123.183 91.8905 124.785C91.8905 126.067 92.7654 127.59 95.1515 127.109C114.24 120.699 128 102.59 128 81.1965C128.079 54.4342 106.525 32.8 80.0397 32.8Z" fill="black"/>
                    <path d="M50.2139 102.27C50.1343 102.51 49.7367 102.59 49.4185 102.43C49.1004 102.27 48.8618 101.949 49.0208 101.709C49.1004 101.469 49.4981 101.388 49.8162 101.549C50.1343 101.709 50.2934 102.029 50.2139 102.27Z" fill="black"/>
                    <path d="M52.1224 104.433C51.8837 104.674 51.4065 104.513 51.1679 104.193C50.8498 103.872 50.7702 103.392 51.0089 103.151C51.2475 102.911 51.6451 103.071 51.9633 103.392C52.2814 103.792 52.361 104.273 52.1224 104.433Z" fill="black"/>
                    <path d="M54.0314 107.238C53.7132 107.478 53.236 107.238 52.9974 106.837C52.6793 106.436 52.6793 105.876 52.9974 105.715C53.3155 105.475 53.7928 105.715 54.0314 106.116C54.3495 106.517 54.3495 106.997 54.0314 107.238Z" fill="black"/>
                    <path d="M56.656 109.962C56.4174 110.283 55.8607 110.202 55.3834 109.802C54.9858 109.401 54.8267 108.84 55.1448 108.6C55.3834 108.279 55.9402 108.359 56.4174 108.76C56.8151 109.081 56.8946 109.642 56.656 109.962Z" fill="black"/>
                    <path d="M60.2354 111.484C60.1558 111.885 59.5991 112.045 59.0423 111.885C58.4856 111.725 58.1674 111.244 58.247 110.924C58.3265 110.523 58.8832 110.363 59.44 110.523C59.9967 110.683 60.3149 111.084 60.2354 111.484Z" fill="black"/>
                    <path d="M64.1324 111.805C64.1324 112.206 63.6552 112.526 63.0984 112.526C62.5417 112.526 62.0645 112.206 62.0645 111.805C62.0645 111.404 62.5417 111.084 63.0984 111.084C63.6552 111.084 64.1324 111.404 64.1324 111.805Z" fill="black"/>
                    <path d="M67.791 111.164C67.8705 111.565 67.4729 111.965 66.9161 112.045C66.3594 112.125 65.8822 111.885 65.8026 111.484C65.7231 111.084 66.1208 110.683 66.6775 110.603C67.2343 110.523 67.7115 110.763 67.791 111.164Z" fill="black"/>
                    <path d="M190.125 70.1023H198.591C198.335 60.7841 190.097 54.0227 178.278 54.0227C166.602 54.0227 157.653 60.6989 157.653 70.7273C157.653 78.8239 163.449 83.5682 172.795 86.0966L179.67 87.9716C185.892 89.6193 190.693 91.6648 190.693 96.8352C190.693 102.517 185.267 106.267 177.795 106.267C171.034 106.267 165.409 103.256 164.898 96.9205H156.091C156.659 107.46 164.812 113.966 177.852 113.966C191.517 113.966 199.386 106.778 199.386 96.9205C199.386 86.4375 190.04 82.375 182.653 80.5568L176.972 79.0796C172.426 77.9148 166.375 75.7841 166.403 70.2159C166.403 65.2727 170.92 61.608 178.079 61.608C184.756 61.608 189.5 64.733 190.125 70.1023Z" fill="black"/>
                    <path d="M227.201 113.881C236.718 113.881 243.451 109.193 245.383 102.091L237.343 100.642C235.809 104.761 232.116 106.864 227.287 106.864C220.014 106.864 215.127 102.148 214.9 93.7386H245.923V90.7273C245.923 74.9602 236.491 68.7955 226.605 68.7955C214.446 68.7955 206.434 78.0568 206.434 91.4659C206.434 105.017 214.332 113.881 227.201 113.881ZM214.929 87.375C215.27 81.1818 219.758 75.8125 226.662 75.8125C233.252 75.8125 237.571 80.6989 237.599 87.375H214.929Z" fill="black"/>
                    <path d="M272.928 113.881C283.241 113.881 289.917 107.688 290.854 99.1932H282.587C281.508 103.909 277.843 106.693 272.985 106.693C265.798 106.693 261.167 100.699 261.167 91.1818C261.167 81.8352 265.883 75.9546 272.985 75.9546C278.383 75.9546 281.678 79.3636 282.587 83.4546H290.854C289.945 74.6477 282.758 68.7955 272.843 68.7955C260.542 68.7955 252.587 78.0568 252.587 91.3807C252.587 104.534 260.258 113.881 272.928 113.881Z" fill="black"/>
                    <path d="M326.78 94.9034C326.809 102.318 321.297 105.841 316.525 105.841C311.269 105.841 307.633 102.034 307.633 96.0966V69.3636H299.138V97.1193C299.138 107.943 305.076 113.568 313.456 113.568C320.019 113.568 324.479 110.102 326.496 105.443H326.951V113H335.303V69.3636H326.78V94.9034Z" fill="black"/>
                    <path d="M345.916 113H354.411V86.3523C354.411 80.6421 358.814 76.5227 364.837 76.5227C366.598 76.5227 368.587 76.8352 369.269 77.0341V68.9091C368.416 68.7955 366.74 68.7102 365.661 68.7102C360.547 68.7102 356.172 71.608 354.581 76.2955H354.127V69.3636H345.916V113Z" fill="black"/>
                    <path d="M375.82 113H384.314V69.3636H375.82V113ZM380.109 62.6307C383.035 62.6307 385.479 60.358 385.479 57.5739C385.479 54.7898 383.035 52.4886 380.109 52.4886C377.155 52.4886 374.74 54.7898 374.74 57.5739C374.74 60.358 377.155 62.6307 380.109 62.6307Z" fill="black"/>
                    <path d="M415.311 69.3636H406.362V58.9091H397.868V69.3636H391.475V76.1818H397.868V101.949C397.839 109.875 403.89 113.71 410.595 113.568C413.294 113.54 415.112 113.028 416.106 112.659L414.572 105.642C414.004 105.756 412.953 106.011 411.589 106.011C408.833 106.011 406.362 105.102 406.362 100.188V76.1818H415.311V69.3636Z" fill="black"/>
                    <path d="M429.276 129.25C436.293 129.25 440.754 125.585 443.254 118.824L461.293 69.4489L452.117 69.3636L441.066 103.227H440.612L429.56 69.3636H420.47L436.435 113.568L435.384 116.466C433.225 122.119 430.185 122.631 425.526 121.352L423.481 128.313C424.504 128.795 426.72 129.25 429.276 129.25Z" fill="black"/>
                    <path d="M489.551 113H524.693V105.443H498.33V54.8182H489.551V113Z" fill="black"/>
                    <path d="M545.925 113.966C553.141 113.966 557.203 110.301 558.822 107.034H559.163V113H567.459V84.0227C567.459 71.3239 557.459 68.7955 550.527 68.7955C542.629 68.7955 535.356 71.9773 532.516 79.9318L540.498 81.75C541.748 78.6534 544.93 75.6705 550.641 75.6705C556.123 75.6705 558.936 78.5398 558.936 83.483V83.6818C558.936 86.7784 555.754 86.7216 547.913 87.6307C539.646 88.5966 531.18 90.7557 531.18 100.67C531.18 109.25 537.629 113.966 545.925 113.966ZM547.771 107.148C542.97 107.148 539.504 104.989 539.504 100.784C539.504 96.2386 543.538 94.6193 548.453 93.9659C551.209 93.5966 557.743 92.858 558.964 91.6364V97.2614C558.964 102.432 554.845 107.148 547.771 107.148Z" fill="black"/>
                    <path d="M578.654 113H586.95V106.21H587.66C589.194 108.994 592.319 113.852 600.274 113.852C610.842 113.852 618.512 105.386 618.512 91.2671C618.512 77.1193 610.728 68.7955 600.189 68.7955C592.092 68.7955 589.166 73.7386 587.66 76.4375H587.149V54.8182H578.654V113ZM586.978 91.1818C586.978 82.0625 590.956 76.0114 598.37 76.0114C606.069 76.0114 609.933 82.5171 609.933 91.1818C609.933 99.9318 605.956 106.608 598.37 106.608C591.069 106.608 586.978 100.358 586.978 91.1818Z" fill="black"/>
                </svg>
                  
        </a>
    </div>            
        <div class="linkcontainer" id="linkcontainermenu">
                <div class="linkbar">
                    <a href="https://help.semmle.com/QL/learn-ql/">Learn CodeQL</a>
                    <a href="https://help.semmle.com/codeql/codeql-tools.html">CodeQL tools</a>
                    <a href="https://github.com/github/codeql">CodeQL repository</a>
                    <a href="https://help.semmle.com/QL/ql-libraries.html">CodeQL libraries</a>
                    <a href="javascript:void(0);" class="icon" onclick="myFunction()">
                        <i class="fa fa-bars"></i>
                      </a>
                </div>
       </div>
</div>  
<div id="title-banner">
    <a href="index.html">QL language reference</a>
    <div id="searchbox-title-banner" role="search">
            <form class="search" action="search.html" method="get">
                <div id="textfield"><input type="text" name="q" /></div>
                <div id="searchbutton"><input type="submit" value="Search" /></div>
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
            </form>
        </div>
        <script type="text/javascript">$('#searchbox').show(0);</script> 
    <div class="clearer"></div>
</div>

<div class="wrapper">
   
    <div class="navBox" > 
            <div id="searchbox-navbar"  role="search">
                    <form class="search" action="search.html" method="get">
                        <div id="textfield"><input type="text" name="q" /></div>
                        <div id="searchbutton"><input type="submit" value="Search" /></div>
                        <input type="hidden" name="check_keywords" value="yes" />
                        <input type="hidden" name="area" value="default" />
                    </form>
                </div>
                <script type="text/javascript">$('#searchbox').show(0);</script> 
                <div class="clearer"></div>
            <div id="toc">
                <h1>Contents</h1>  
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="about-the-ql-language.html">About the QL language</a></li>
<li class="toctree-l1"><a class="reference internal" href="predicates.html">Predicates</a></li>
<li class="toctree-l1"><a class="reference internal" href="queries.html">Queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="aliases.html">Aliases</a></li>
<li class="toctree-l1"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Expressions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#variable-references">Variable references</a></li>
<li class="toctree-l2"><a class="reference internal" href="#literals">Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parenthesized-expressions">Parenthesized expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ranges">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="#set-literal-expressions">Set literal expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#super-expressions">Super expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#calls-to-predicates-with-result">Calls to predicates (with result)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#aggregations">Aggregations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#any">Any</a></li>
<li class="toctree-l2"><a class="reference internal" href="#unary-operations">Unary operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#binary-operations">Binary operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#casts">Casts</a></li>
<li class="toctree-l2"><a class="reference internal" href="#don-t-care-expressions">Don’t-care expressions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="formulas.html">Formulas</a></li>
<li class="toctree-l1"><a class="reference internal" href="annotations.html">Annotations</a></li>
<li class="toctree-l1"><a class="reference internal" href="recursion.html">Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="lexical-syntax.html">Lexical syntax</a></li>
<li class="toctree-l1"><a class="reference internal" href="name-resolution.html">Name resolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="evaluation.html">Evaluation of QL programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="language.html">QL language specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="qldoc.html">QLDoc comment specification</a></li>
</ul>

            </div>
    </div>
    <div class="mainBox">
        
  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="expressions">
<span id="id1"></span><h1>Expressions<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a></h1>
<p>An expression evaluates to a set of values and has a type.</p>
<p>For example, the expression <code class="docutils literal"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code>
evaluates to the integer <code class="docutils literal"><span class="pre">3</span></code> and the expression <code class="docutils literal"><span class="pre">&quot;QL&quot;</span></code> evaluates to the string <code class="docutils literal"><span class="pre">&quot;QL&quot;</span></code>. <code class="docutils literal"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code> has <a class="reference internal" href="types.html#types"><span class="std std-ref">type</span></a> <code class="docutils literal"><span class="pre">int</span></code> and <code class="docutils literal"><span class="pre">&quot;QL&quot;</span></code> has type <code class="docutils literal"><span class="pre">string</span></code>.</p>
<p>The following sections describe the expressions that are available in QL.</p>
<div class="section" id="variable-references">
<h2>Variable references<a class="headerlink" href="#variable-references" title="Permalink to this headline">¶</a></h2>
<p>A variable reference is the name of a declared <a class="reference internal" href="variables.html#variables"><span class="std std-ref">variable</span></a>. This kind of
expression has the same type as the variable it refers to.</p>
<p>For example, if you have <a class="reference internal" href="variables.html#variable-declarations"><span class="std std-ref">declared</span></a> the variables <code class="docutils literal"><span class="pre">int</span> <span class="pre">i</span></code> and <code class="docutils literal"><span class="pre">LocalScopeVariable</span> <span class="pre">lsv</span></code>, then
the expressions <code class="docutils literal"><span class="pre">i</span></code> and <code class="docutils literal"><span class="pre">lsv</span></code> have types <code class="docutils literal"><span class="pre">int</span></code> and <code class="docutils literal"><span class="pre">LocalScopeVariable</span></code> respectively.</p>
<p>You can also refer to the variables <code class="docutils literal"><span class="pre">this</span></code> and <code class="docutils literal"><span class="pre">result</span></code>. These are used in <a class="reference internal" href="predicates.html#predicates"><span class="std std-ref">predicate</span></a> definitions and act in the same way as other variable references.</p>
</div>
<div class="section" id="literals">
<span id="index-0"></span><h2>Literals<a class="headerlink" href="#literals" title="Permalink to this headline">¶</a></h2>
<p>You can express certain values directly in QL, such as numbers, booleans, and strings.</p>
<ul>
<li><p class="first"><a class="reference internal" href="types.html#boolean"><span class="std std-ref">Boolean</span></a> literals: These are the values <code class="docutils literal"><span class="pre">true</span></code> and <code class="docutils literal"><span class="pre">false</span></code>.</p>
</li>
<li><p class="first"><a class="reference internal" href="types.html#int"><span class="std std-ref">Integer</span></a> literals: These are sequences of decimal digits (<code class="docutils literal"><span class="pre">0</span></code> through <code class="docutils literal"><span class="pre">9</span></code>),
possibly starting with a minus sign (<code class="docutils literal"><span class="pre">-</span></code>).
For example:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="m">0</span>
<span class="m">42</span>
<span class="o">-</span><span class="m">2048</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="types.html#float"><span class="std std-ref">Float</span></a> literals: These are sequences of decimal digits separated by a dot
(<code class="docutils literal"><span class="pre">.</span></code>), possibly starting with a minus sign (<code class="docutils literal"><span class="pre">-</span></code>).
For example:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="m">2.0</span>
<span class="m">123.456</span>
<span class="o">-</span><span class="m">100.5</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="types.html#string"><span class="std std-ref">String</span></a> literals: These are finite strings of 16-bit characters. You can
define a string literal by enclosing characters in quotation marks (<code class="docutils literal"><span class="pre">&quot;...&quot;</span></code>). Most
characters represent themselves, but there are a few characters that you need to “escape”
with a backslash. The following are examples of string literals:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="s">&quot;hello&quot;</span>
<span class="s">&quot;They said, \&quot;Please escape quotation marks!\&quot;&quot;</span>
</pre></div>
</div>
<p>See <a class="reference external" href="https://help.semmle.com/QL/ql-spec/language.html#string-literals-string">String literals</a>
in the QL language specification for more details.</p>
<p>Note: there is no “date literal” in QL. Instead, to specify a <a class="reference internal" href="types.html#date"><span class="std std-ref">date</span></a>, you should
convert a string to the date that it represents using the <code class="docutils literal"><span class="pre">toDate()</span></code> predicate. For example,
<code class="docutils literal"><span class="pre">&quot;2016-04-03&quot;.toDate()</span></code> is the date April 3, 2016, and <code class="docutils literal"><span class="pre">&quot;2000-01-01</span> <span class="pre">00:00:01&quot;.toDate()</span></code> is the
point in time one second after New Year 2000.</p>
<dl class="docutils">
<dt>The following string formats are recognized as dates:</dt>
<dd><ul class="first last simple">
<li><strong>ISO dates</strong>, such as <code class="docutils literal"><span class="pre">&quot;2016-04-03</span> <span class="pre">17:00:24&quot;</span></code>. The seconds part is optional (assumed
to be <code class="docutils literal"><span class="pre">&quot;00&quot;</span></code> if it’s missing), and the entire time part can also be missing (in which
case it’s assumed to be <code class="docutils literal"><span class="pre">&quot;00:00:00&quot;</span></code>).</li>
<li><strong>Short-hand ISO dates</strong>, such as <code class="docutils literal"><span class="pre">&quot;20160403&quot;</span></code>.</li>
<li><strong>UK-style dates</strong>, such as <code class="docutils literal"><span class="pre">&quot;03/04/2016&quot;</span></code>.</li>
<li><strong>Verbose dates</strong>, such as <code class="docutils literal"><span class="pre">&quot;03</span> <span class="pre">April</span> <span class="pre">2016&quot;</span></code>.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="parenthesized-expressions">
<h2>Parenthesized expressions<a class="headerlink" href="#parenthesized-expressions" title="Permalink to this headline">¶</a></h2>
<p>A parenthesized expression is an expression surrounded by parentheses, <code class="docutils literal"><span class="pre">(</span></code> and <code class="docutils literal"><span class="pre">)</span></code>. This
expression has exactly the same type and values as the original expression.
Parentheses are useful for grouping expressions together to remove ambiguity and improve
readability.</p>
</div>
<div class="section" id="ranges">
<span id="index-1"></span><span id="id2"></span><h2>Ranges<a class="headerlink" href="#ranges" title="Permalink to this headline">¶</a></h2>
<p>A range expression denotes a range of values ordered between two expressions. It consists of
two expressions separated by <code class="docutils literal"><span class="pre">..</span></code> and enclosed in brackets (<code class="docutils literal"><span class="pre">[</span></code> and <code class="docutils literal"><span class="pre">]</span></code>).
For example, <code class="docutils literal"><span class="pre">[3</span> <span class="pre">..</span> <span class="pre">7]</span></code> is a valid range expression. Its values are any integers between
<code class="docutils literal"><span class="pre">3</span></code> and <code class="docutils literal"><span class="pre">7</span></code> (including <code class="docutils literal"><span class="pre">3</span></code> and <code class="docutils literal"><span class="pre">7</span></code> themselves).</p>
<p>In a valid range, the start and end expression are integers, floats, or dates. If one of them
is a date, then both must be dates. If one of them is an integer and the other a float, then
both are treated as floats.</p>
</div>
<div class="section" id="set-literal-expressions">
<span id="setliteral"></span><span id="index-2"></span><h2>Set literal expressions<a class="headerlink" href="#set-literal-expressions" title="Permalink to this headline">¶</a></h2>
<p>A set literal expression allows the explicit listing of a choice between several values.
It consists of a comma-separated collection of expressions that are enclosed in brackets (<code class="docutils literal"><span class="pre">[</span></code> and <code class="docutils literal"><span class="pre">]</span></code>).
For example, <code class="docutils literal"><span class="pre">[2,</span> <span class="pre">3,</span> <span class="pre">5,</span> <span class="pre">7,</span> <span class="pre">11,</span> <span class="pre">13,</span> <span class="pre">17,</span> <span class="pre">19,</span> <span class="pre">23,</span> <span class="pre">29]</span></code> is a valid set literal expression.
Its values are the first ten prime numbers.</p>
<p>The values of the contained expressions need to be of <a class="reference internal" href="types.html#type-compatibility"><span class="std std-ref">compatible types</span></a> for a valid set literal expression.
Furthermore, at least one of the set elements has to be of a type that is a supertype of the types of all
the other contained expressions.</p>
<p>Set literals are supported from release 2.1.0 of the CodeQL CLI, and release 1.24 of LGTM Enterprise.</p>
</div>
<div class="section" id="super-expressions">
<span id="super"></span><span id="index-3"></span><h2>Super expressions<a class="headerlink" href="#super-expressions" title="Permalink to this headline">¶</a></h2>
<p>Super expressions in QL are similar to super expressions in other programming languages, such
as Java. You can use them in predicate calls, when you want to use the predicate definition
from a supertype. In practice, this is useful when a predicate inherits two definitions from
its supertypes. In that case, the predicate must <a class="reference internal" href="types.html#overriding-member-predicates"><span class="std std-ref">override</span></a>
those definitions to avoid ambiguity.
However, if you want to use the definition from a particular supertype instead of writing a
new definition, you can use a super expression.</p>
<p>In the following example, the class <code class="docutils literal"><span class="pre">C</span></code> inherits two definitions of the predicate
<code class="docutils literal"><span class="pre">getANumber()</span></code>—one from <code class="docutils literal"><span class="pre">A</span></code> and one from <code class="docutils literal"><span class="pre">B</span></code>.
Instead of overriding both definitions, it uses the definition from <code class="docutils literal"><span class="pre">B</span></code>.</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">A</span> <span class="k">extends</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span> <span class="o">=</span> <span class="m">1</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">getANumber</span><span class="p">()</span> <span class="p">{</span> <span class="k">result</span> <span class="o">=</span> <span class="m">2</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="n">B</span> <span class="k">extends</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="n">B</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span> <span class="o">=</span> <span class="m">1</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">getANumber</span><span class="p">()</span> <span class="p">{</span> <span class="k">result</span> <span class="o">=</span> <span class="m">3</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="n">C</span> <span class="k">extends</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="p">{</span>
  <span class="c1">// Need to define `int getANumber()`; otherwise it would be ambiguous</span>
  <span class="kt">int</span> <span class="n">getANumber</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">result</span> <span class="o">=</span> <span class="n">B</span><span class="p">.</span><span class="k">super</span><span class="p">.</span><span class="n">getANumber</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">from</span> <span class="n">C</span> <span class="n">c</span>
<span class="k">select</span> <span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">getANumber</span><span class="p">()</span>
</pre></div>
</div>
<p>The result of this query is <code class="docutils literal"><span class="pre">1,</span> <span class="pre">3</span></code>.</p>
</div>
<div class="section" id="calls-to-predicates-with-result">
<span id="calls-with-result"></span><h2>Calls to predicates (with result)<a class="headerlink" href="#calls-to-predicates-with-result" title="Permalink to this headline">¶</a></h2>
<p>Calls to <a class="reference internal" href="predicates.html#predicates-with-result"><span class="std std-ref">predicates with results</span></a> are themselves expressions,
unlike calls to <a class="reference internal" href="predicates.html#predicates-without-result"><span class="std std-ref">predicates without results</span></a> which are
formulas. For more information, see “<a class="reference internal" href="formulas.html#calls"><span class="std std-ref">Calls to predicates</span></a>.”</p>
<p>A call to a predicate with result evaluates to the values of the <code class="docutils literal"><span class="pre">result</span></code> variable of the
called predicate.</p>
<p>For example <code class="docutils literal"><span class="pre">a.getAChild()</span></code> is a call to a predicate <code class="docutils literal"><span class="pre">getAChild()</span></code> on a variable <code class="docutils literal"><span class="pre">a</span></code>.
This call evaluates to the set of children of <code class="docutils literal"><span class="pre">a</span></code>.</p>
</div>
<div class="section" id="aggregations">
<span id="index-4"></span><span id="id3"></span><h2>Aggregations<a class="headerlink" href="#aggregations" title="Permalink to this headline">¶</a></h2>
<p>An aggregation is a mapping that computes a result value from a set of input values that are
specified by a formula.</p>
<p>The general syntax is:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">aggregate</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">variable</span> <span class="n">declarations</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">formula</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>The variables <a class="reference internal" href="variables.html#variable-declarations"><span class="std std-ref">declared</span></a> in <code class="docutils literal"><span class="pre">&lt;variable</span> <span class="pre">declarations&gt;</span></code> are called
the <strong>aggregation variables</strong>.</p>
<p>Ordered aggregates (namely <code class="docutils literal"><span class="pre">min</span></code>, <code class="docutils literal"><span class="pre">max</span></code>, <code class="docutils literal"><span class="pre">rank</span></code>, <code class="docutils literal"><span class="pre">concat</span></code>, and <code class="docutils literal"><span class="pre">strictconcat</span></code>) are
ordered by their <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> values by default. The ordering is either numeric (for
integers and floating point numbers) or lexicographic (for strings). Lexicographic ordering is
based on the <a class="reference external" href="https://en.wikipedia.org/wiki/List_of_Unicode_characters#Basic_Latin">Unicode value</a>
of each character.</p>
<p>To specify a different order, follow <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> with the keywords <code class="docutils literal"><span class="pre">order</span> <span class="pre">by</span></code>, then
the expression that specifies the order, and optionally the keyword <code class="docutils literal"><span class="pre">asc</span></code> or <code class="docutils literal"><span class="pre">desc</span></code>
(to determine whether to order the expression in ascending or descending order). If you don’t
specify an ordering, it defaults to <code class="docutils literal"><span class="pre">asc</span></code>.</p>
<p>The following aggregates are available in QL:</p>
<ul id="index-5">
<li><p class="first"><code class="docutils literal"><span class="pre">count</span></code>: This aggregate determines the number of distinct values of <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> for
each possible assignment of the aggregation variables.</p>
<p>For example, the following aggregation returns the number of files that have more than
<code class="docutils literal"><span class="pre">500</span></code> lines:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">count</span><span class="p">(</span><span class="n">File</span> <span class="n">f</span> <span class="o">|</span> <span class="n">f</span><span class="p">.</span><span class="n">getTotalNumberOfLines</span><span class="p">()</span> <span class="o">&gt;</span> <span class="m">500</span> <span class="o">|</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>If there are no possible assignments to the aggregation variables that satisfy the formula, as in
<code class="docutils literal"><span class="pre">count(int</span> <span class="pre">i</span> <span class="pre">|</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">and</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">|</span> <span class="pre">i)</span></code>, then <code class="docutils literal"><span class="pre">count</span></code> defaults to the value <code class="docutils literal"><span class="pre">0</span></code>.</p>
</li>
</ul>
<ul id="index-6">
<li><p class="first"><code class="docutils literal"><span class="pre">min</span></code> and <code class="docutils literal"><span class="pre">max</span></code>: These aggregates determine the smallest (<code class="docutils literal"><span class="pre">min</span></code>) or largest (<code class="docutils literal"><span class="pre">max</span></code>)
value of <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> among the possible assignments to the aggregation variables.
In this case, <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> must be of numeric type or of type <code class="docutils literal"><span class="pre">string</span></code>.</p>
<p>For example, the following aggregation returns the name of the <code class="docutils literal"><span class="pre">.js</span></code> file (or files) with the
largest number of lines:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">max</span><span class="p">(</span><span class="n">File</span> <span class="n">f</span> <span class="o">|</span> <span class="n">f</span><span class="p">.</span><span class="n">getExtension</span><span class="p">()</span> <span class="o">=</span> <span class="s">&quot;js&quot;</span> <span class="o">|</span> <span class="n">f</span><span class="p">.</span><span class="n">getBaseName</span><span class="p">()</span> <span class="k">order</span> <span class="k">by</span> <span class="n">f</span><span class="p">.</span><span class="n">getTotalNumberOfLines</span><span class="p">())</span>
</pre></div>
</div>
<p>The following aggregation returns the minimum string <code class="docutils literal"><span class="pre">s</span></code> out of the three strings mentioned
below, that is, the string that comes first in the lexicographic ordering of all the possible
values of <code class="docutils literal"><span class="pre">s</span></code>. (In this case, it returns <code class="docutils literal"><span class="pre">&quot;De</span> <span class="pre">Morgan&quot;</span></code>.)</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">min</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span> <span class="o">|</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Tarski&quot;</span> <span class="k">or</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Dedekind&quot;</span> <span class="k">or</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;De Morgan&quot;</span> <span class="o">|</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<ul id="index-7">
<li><p class="first"><code class="docutils literal"><span class="pre">avg</span></code>: This aggregate determines the average value of <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> for all possible
assignments to the aggregation variables. The type of <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> must be numeric.
If there are no possible assignments to the aggregation variables that satisfy the formula, the aggregation fails and
returns no values. In other words, it evaluates to the empty set.</p>
<p>For example, the following aggregation returns the average of the integers <code class="docutils literal"><span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">1</span></code>,
<code class="docutils literal"><span class="pre">2</span></code>, and <code class="docutils literal"><span class="pre">3</span></code>:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">avg</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="m">0</span> <span class="p">..</span> <span class="m">3</span><span class="p">]</span> <span class="o">|</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<ul id="index-8">
<li><p class="first"><code class="docutils literal"><span class="pre">sum</span></code>: This aggregate determines the sum of the values of <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> over all possible
assignments to the aggregation variables. The type of <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> must be numeric.
If there are no possible assignments to the aggregation variables that satisfy the formula, then the sum is <code class="docutils literal"><span class="pre">0</span></code>.</p>
<p>For example, the following aggregation returns the sum of <code class="docutils literal"><span class="pre">i</span> <span class="pre">*</span> <span class="pre">j</span></code> for all possible values
of <code class="docutils literal"><span class="pre">i</span></code> and <code class="docutils literal"><span class="pre">j</span></code>:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">|</span> <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="m">0</span> <span class="p">..</span> <span class="m">2</span><span class="p">]</span> <span class="k">and</span> <span class="n">j</span> <span class="o">=</span> <span class="p">[</span><span class="m">3</span> <span class="p">..</span> <span class="m">5</span><span class="p">]</span> <span class="o">|</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<ul id="index-9">
<li><p class="first"><code class="docutils literal"><span class="pre">concat</span></code>: This aggregate concatenates the values of <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> over all possible
assignments to the aggregation variables. Note that <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> must be of type
<code class="docutils literal"><span class="pre">string</span></code>. If there are no possible assignments to the aggregation variables that satisfy
the formula, then <code class="docutils literal"><span class="pre">concat</span></code> defaults to the empty string.</p>
<p>For example, the following aggregation returns the string <code class="docutils literal"><span class="pre">&quot;3210&quot;</span></code>, that is, the
concatenation of the strings <code class="docutils literal"><span class="pre">&quot;0&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;1&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;2&quot;</span></code>, and <code class="docutils literal"><span class="pre">&quot;3&quot;</span></code> in descending order:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">concat</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="m">0</span> <span class="p">..</span> <span class="m">3</span><span class="p">]</span> <span class="o">|</span> <span class="n">i</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span> <span class="k">order</span> <span class="k">by</span> <span class="n">i</span> <span class="k">desc</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">concat</span></code> aggregate can also take a second expression, separated from the first one by
a comma. This second expression is inserted as a separator between each concatenated value.</p>
<p>For example, the following aggregation returns <code class="docutils literal"><span class="pre">&quot;0|1|2|3&quot;</span></code>:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">concat</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="m">0</span> <span class="p">..</span> <span class="m">3</span><span class="p">]</span> <span class="o">|</span> <span class="n">i</span><span class="p">.</span><span class="n">toString</span><span class="p">(),</span> <span class="s">&quot;|&quot;</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<ul id="index-10">
<li><p class="first"><code class="docutils literal"><span class="pre">rank</span></code>: This aggregate takes the possible values of <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> and ranks them.
In this case, <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> must be of numeric type or of type <code class="docutils literal"><span class="pre">string</span></code>. The aggregation
returns the value that is ranked in the position specified by the <strong>rank expression</strong>.
You must include this rank expression in brackets after the keyword <code class="docutils literal"><span class="pre">rank</span></code>.</p>
<p>For example, the following aggregation returns the value that is ranked 4th out of all the
possible values. In this case, <code class="docutils literal"><span class="pre">8</span></code> is the 4th integer in the range from <code class="docutils literal"><span class="pre">5</span></code> through
<code class="docutils literal"><span class="pre">15</span></code>:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">rank</span><span class="p">[</span><span class="m">4</span><span class="p">](</span><span class="kt">int</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="m">5</span> <span class="p">..</span> <span class="m">15</span><span class="p">]</span> <span class="o">|</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the rank indices start at <code class="docutils literal"><span class="pre">1</span></code>, so <code class="docutils literal"><span class="pre">rank[0](...)</span></code> returns no results.</p>
</li>
</ul>
<ul class="simple" id="index-11">
<li><code class="docutils literal"><span class="pre">strictconcat</span></code>, <code class="docutils literal"><span class="pre">strictcount</span></code>, and <code class="docutils literal"><span class="pre">strictsum</span></code>: These aggregates work like <code class="docutils literal"><span class="pre">concat</span></code>,
<code class="docutils literal"><span class="pre">count</span></code>, and <code class="docutils literal"><span class="pre">sum</span></code> respectively, except that they are <em>strict</em>. That is, if there are no
possible assignments to the aggregation variables that satisfy the formula, then the entire aggregation fails and
evaluates to the empty set (instead of defaulting to <code class="docutils literal"><span class="pre">0</span></code> or the empty string).
This is useful if you’re only interested in results where the aggregation body is non-trivial.</li>
</ul>
<ul id="index-12">
<li><p class="first"><code class="docutils literal"><span class="pre">unique</span></code>: This aggregate depends on the values of <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> over all possible assignments to
the aggregation variables. If there is a unique value of <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> over the aggregation variables,
then the aggregate evaluates to that value.
Otherwise, the aggregate has no value.</p>
<p>For example, the following query returns the positive integers <code class="docutils literal"><span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">2</span></code>, <code class="docutils literal"><span class="pre">3</span></code>, <code class="docutils literal"><span class="pre">4</span></code>, <code class="docutils literal"><span class="pre">5</span></code>.
For negative integers <code class="docutils literal"><span class="pre">x</span></code>, the expressions <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">x.abs()</span></code> have different values, so the
value for <code class="docutils literal"><span class="pre">y</span></code> in the aggregate expression is not uniquely determined.</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">from</span> <span class="kt">int</span> <span class="n">x</span>
<span class="k">where</span> <span class="n">x</span> <span class="k">in</span> <span class="p">[</span><span class="o">-</span><span class="m">5</span> <span class="p">..</span> <span class="m">5</span><span class="p">]</span> <span class="k">and</span> <span class="n">x</span> <span class="o">!=</span> <span class="m">0</span>
<span class="k">select</span> <span class="k">unique</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="k">or</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span> <span class="o">|</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">unique</span></code> aggregate is supported from release 2.1.0 of the CodeQL CLI, and release 1.24 of LGTM Enterprise.</p>
</li>
</ul>
<div class="section" id="evaluation-of-aggregates">
<h3>Evaluation of aggregates<a class="headerlink" href="#evaluation-of-aggregates" title="Permalink to this headline">¶</a></h3>
<p>In general, aggregate evaluation involves the following steps:</p>
<ol class="arabic simple">
<li>Determine the input variables: these are the aggregation variables declared in <code class="docutils literal"><span class="pre">&lt;variable</span> <span class="pre">declarations&gt;</span></code> and
also the variables declared outside of the aggregate that are used in some component of the aggregate.</li>
<li>Generate all possible distinct tuples (combinations) of the values of input variables such that the
<code class="docutils literal"><span class="pre">&lt;formula&gt;</span></code> holds true. Note that the same value of an aggregate variable may appear in
multiple distinct tuples. All such occurrences of the same value are treated as distinct occurrences
when processing tuples.</li>
<li>Apply <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> on each tuple and collect the generated (distinct) values. The application
of <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> on a tuple may result in generating more than one value.</li>
<li>Apply the aggregation function on the values generated in step 3 to compute the final result.</li>
</ol>
<p>Let us apply these steps to the <code class="docutils literal"><span class="pre">sum</span></code> aggregate in the following query:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">select</span> <span class="k">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">|</span>
    <span class="k">exists</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span> <span class="o">|</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="p">.</span><span class="n">charAt</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">and</span> <span class="k">exists</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span> <span class="o">|</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;world!&quot;</span><span class="p">.</span><span class="n">charAt</span><span class="p">(</span><span class="n">j</span><span class="p">))</span> <span class="o">|</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic">
<li><p class="first">Input variables: <code class="docutils literal"><span class="pre">i</span></code>, <code class="docutils literal"><span class="pre">j</span></code>.</p>
</li>
<li><p class="first">All possible tuples <code class="docutils literal"><span class="pre">(&lt;value</span> <span class="pre">of</span> <span class="pre">i&gt;,</span> <span class="pre">&lt;value</span> <span class="pre">of</span> <span class="pre">j&gt;)</span></code> satisfying the given condition:
<code class="docutils literal"><span class="pre">(0,</span> <span class="pre">0),</span> <span class="pre">(0,</span> <span class="pre">1),</span> <span class="pre">(0,</span> <span class="pre">2),</span> <span class="pre">(0,</span> <span class="pre">3),</span> <span class="pre">(0,</span> <span class="pre">4),</span> <span class="pre">(0,</span> <span class="pre">5),</span> <span class="pre">(1,</span> <span class="pre">0),</span> <span class="pre">(1,</span> <span class="pre">1),</span> <span class="pre">...,</span> <span class="pre">(4,</span> <span class="pre">5)</span></code>.</p>
<p>30 tuples are generated in this step.</p>
</li>
<li><p class="first">Apply the <code class="docutils literal"><span class="pre">&lt;expression&gt;</span> <span class="pre">i</span></code> on all tuples. This means selecting all values of <code class="docutils literal"><span class="pre">i</span></code> from
all tuples: <code class="docutils literal"><span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">3,</span> <span class="pre">3,</span> <span class="pre">3,</span> <span class="pre">3,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">4,</span> <span class="pre">4,</span> <span class="pre">4,</span> <span class="pre">4,</span> <span class="pre">4.</span></code></p>
</li>
<li><p class="first">Apply the aggregation function <code class="docutils literal"><span class="pre">sum</span></code> on the above values to get the final result <code class="docutils literal"><span class="pre">60</span></code>.</p>
</li>
</ol>
<p>If we change <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> to <code class="docutils literal"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">j</span></code> in the above query, the query result is <code class="docutils literal"><span class="pre">135</span></code> since
applying <code class="docutils literal"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">j</span></code> on all tuples results in following values:
<code class="docutils literal"><span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">8,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">8,</span> <span class="pre">9</span></code>.</p>
<p>Next, consider the following query:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span> <span class="o">|</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span> <span class="o">|</span> <span class="n">s</span><span class="p">.</span><span class="n">charAt</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
</pre></div>
</div>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">s</span></code> is the input variable of the aggregate.</li>
<li>A single tuple <code class="docutils literal"><span class="pre">&quot;hello&quot;</span></code> is generated in this step.</li>
<li>The <code class="docutils literal"><span class="pre">&lt;expression&gt;</span> <span class="pre">charAt(_)</span></code> is applied on this tuple. The underscore <code class="docutils literal"><span class="pre">_</span></code> in <code class="docutils literal"><span class="pre">charAt(_)</span></code>
is a <a class="reference internal" href="#dont-care"><span class="std std-ref">don’t-care expression</span></a>, which represents any value.
<code class="docutils literal"><span class="pre">s.charAt(_)</span></code> generates four distinct values <code class="docutils literal"><span class="pre">h,</span> <span class="pre">e,</span> <span class="pre">l,</span> <span class="pre">o</span></code>.</li>
<li>Finally, <code class="docutils literal"><span class="pre">count</span></code> is applied on these values, and the query returns <code class="docutils literal"><span class="pre">4</span></code>.</li>
</ol>
</div>
<div class="section" id="omitting-parts-of-an-aggregation">
<h3>Omitting parts of an aggregation<a class="headerlink" href="#omitting-parts-of-an-aggregation" title="Permalink to this headline">¶</a></h3>
<p>The three parts of an aggregation are not always required, so you can often write the
aggregation in a simpler form:</p>
<ol class="arabic">
<li><p class="first">If you want to write an aggregation of the form <code class="docutils literal"><span class="pre">&lt;aggregate&gt;(&lt;type&gt;</span> <span class="pre">v</span> <span class="pre">|</span> <span class="pre">&lt;expression&gt;</span> <span class="pre">=</span> <span class="pre">v</span> <span class="pre">|</span> <span class="pre">v)</span></code>,
then you can omit the <code class="docutils literal"><span class="pre">&lt;variable</span> <span class="pre">declarations&gt;</span></code> and <code class="docutils literal"><span class="pre">&lt;formula&gt;</span></code> parts and write it
as follows:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">aggregate</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>For example, the following aggregations determine how many times the letter <code class="docutils literal"><span class="pre">l</span></code> occurs in
string <code class="docutils literal"><span class="pre">&quot;hello&quot;</span></code>. These forms are equivalent:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">count</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="p">.</span><span class="n">indexOf</span><span class="p">(</span><span class="s">&quot;l&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="n">i</span><span class="p">)</span>
<span class="k">count</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">.</span><span class="n">indexOf</span><span class="p">(</span><span class="s">&quot;l&quot;</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p class="first">If there only one aggregation variable, you can omit the <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> part instead.
In this case, the expression is considered to be the aggregation variable itself.
For example, the following aggregations are equivalent:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">avg</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="m">0</span> <span class="p">..</span> <span class="m">3</span><span class="p">]</span> <span class="o">|</span> <span class="n">i</span><span class="p">)</span>
<span class="k">avg</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="m">0</span> <span class="p">..</span> <span class="m">3</span><span class="p">])</span>
</pre></div>
</div>
</li>
<li><p class="first">As a special case, you can omit the <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> part from <code class="docutils literal"><span class="pre">count</span></code> even if there is more
than one aggregation variable. In such a case, it counts the number of distinct tuples of
aggregation variables that satisfy the formula. In other words, the expression part is
considered to be the constant <code class="docutils literal"><span class="pre">1</span></code>. For example, the following aggregations are equivalent:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">count</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">|</span> <span class="n">i</span> <span class="k">in</span> <span class="p">[</span><span class="m">1</span> <span class="p">..</span> <span class="m">3</span><span class="p">]</span> <span class="k">and</span> <span class="n">j</span> <span class="k">in</span> <span class="p">[</span><span class="m">1</span> <span class="p">..</span> <span class="m">3</span><span class="p">]</span> <span class="o">|</span> <span class="m">1</span><span class="p">)</span>
<span class="k">count</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">|</span> <span class="n">i</span> <span class="k">in</span> <span class="p">[</span><span class="m">1</span> <span class="p">..</span> <span class="m">3</span><span class="p">]</span> <span class="k">and</span> <span class="n">j</span> <span class="k">in</span> <span class="p">[</span><span class="m">1</span> <span class="p">..</span> <span class="m">3</span><span class="p">])</span>
</pre></div>
</div>
</li>
<li><p class="first">You can omit the <code class="docutils literal"><span class="pre">&lt;formula&gt;</span></code> part, but in that case you should include two vertical bars:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">aggregate</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">variable</span> <span class="n">declarations</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>This is useful if you don’t want to restrict the aggregation variables any further.
For example, the following aggregation returns the maximum number of lines across all files:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">max</span><span class="p">(</span><span class="n">File</span> <span class="n">f</span> <span class="o">|</span> <span class="o">|</span> <span class="n">f</span><span class="p">.</span><span class="n">getTotalNumberOfLines</span><span class="p">())</span>
</pre></div>
</div>
</li>
<li><p class="first">Finally, you can also omit both the <code class="docutils literal"><span class="pre">&lt;formula&gt;</span></code> and <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> parts. For example,
the following aggregations are equivalent ways to count the number of files in a database:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">count</span><span class="p">(</span><span class="n">File</span> <span class="n">f</span> <span class="o">|</span> <span class="k">any</span><span class="p">()</span> <span class="o">|</span> <span class="m">1</span><span class="p">)</span>
<span class="k">count</span><span class="p">(</span><span class="n">File</span> <span class="n">f</span> <span class="o">|</span> <span class="o">|</span> <span class="m">1</span><span class="p">)</span>
<span class="k">count</span><span class="p">(</span><span class="n">File</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="monotonic-aggregates">
<span id="id4"></span><h3>Monotonic aggregates<a class="headerlink" href="#monotonic-aggregates" title="Permalink to this headline">¶</a></h3>
<p>In addition to standard aggregates, QL also supports monotonic aggregates.
Monotonic aggregates differ from standard aggregates in the way that they deal with the
values generated by the <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> part of the formula:</p>
<ul class="simple">
<li>Standard aggregates take the <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> values for each <code class="docutils literal"><span class="pre">&lt;formula&gt;</span></code> value and
flatten them into a list. A single aggregation function is applied to all the values.</li>
<li>Monotonic aggregates take an <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> for each value given by the <code class="docutils literal"><span class="pre">&lt;formula&gt;</span></code>,
and create combinations of all the possible values. The aggregation
function is applied to each of the resulting combinations.</li>
</ul>
<p>In general, if the <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> is total and functional, then monotonic aggregates are
equivalent to standard aggregates. Results differ when there is not precisely one <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code>
value for each value generated by the <code class="docutils literal"><span class="pre">&lt;formula&gt;</span></code>:</p>
<ul class="simple">
<li>If there are missing <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> values (that is, there is no
<code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> value for a value generated by the <code class="docutils literal"><span class="pre">&lt;formula&gt;</span></code>), monotonic aggregates
won’t compute a result, as you cannot create combinations of values
including exactly one <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> value for each value generated by the <code class="docutils literal"><span class="pre">&lt;formula&gt;</span></code>.</li>
<li>If there is more than one <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> per <code class="docutils literal"><span class="pre">&lt;formula&gt;</span></code> result, you can create multiple
combinations of values including exactly one <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> value for each
value generated by the <code class="docutils literal"><span class="pre">&lt;formula&gt;</span></code>. Here, the aggregation function is applied to each of the
resulting combinations.</li>
</ul>
<div class="section" id="recursive-monotonic-aggregates">
<h4>Recursive monotonic aggregates<a class="headerlink" href="#recursive-monotonic-aggregates" title="Permalink to this headline">¶</a></h4>
<p>Monotonic aggregates may be used <a class="reference internal" href="recursion.html#recursion"><span class="std std-ref">recursively</span></a>, but the recursive call may only appear in the
expression, and not in the range. The recursive semantics for aggregates are the same as the
recursive semantics for the rest of QL. For example, we might define a predicate to calculate
the distance of a node in a graph from the leaves as follows:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">depth</span><span class="p">(</span><span class="n">Node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="k">not</span> <span class="k">exists</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">getAChild</span><span class="p">())</span>
  <span class="k">then</span> <span class="k">result</span> <span class="o">=</span> <span class="m">0</span>
  <span class="k">else</span> <span class="k">result</span> <span class="o">=</span> <span class="m">1</span> <span class="o">+</span> <span class="k">max</span><span class="p">(</span><span class="n">Node</span> <span class="n">child</span> <span class="o">|</span> <span class="n">child</span> <span class="o">=</span> <span class="n">n</span><span class="p">.</span><span class="n">getAChild</span><span class="p">()</span> <span class="o">|</span> <span class="n">depth</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here the recursive call is in the expression, which is legal. The recursive semantics for aggregates
are the same as the recursive semantics for the rest of QL. If you understand how aggregates work in
the non-recursive case then you should not find it difficult to use them recursively. However, it is
worth seeing how the evaluation of a recursive aggregation proceeds.</p>
<p>Consider the depth example we just saw with the following graph as input (arrows point from children to parents):</p>
<p><img alt="image0" src="_images/monotonic-aggregates-graph.png" /></p>
<p>Then the evaluation of the <code class="docutils literal"><span class="pre">depth</span></code> predicate proceeds as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="5%" />
<col width="20%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Stage</strong></th>
<th class="head"><strong>depth</strong></th>
<th class="head"><strong>Comments</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>&#160;</td>
<td>We always begin with the empty set.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td><code class="docutils literal"><span class="pre">(0,</span> <span class="pre">b),</span> <span class="pre">(0,</span> <span class="pre">d),</span> <span class="pre">(0,</span> <span class="pre">e)</span></code></td>
<td>The nodes with no children have depth 0. The recursive step for <strong>a</strong> and <strong>c</strong> fails to produce a value, since some of their children do not have values for <code class="docutils literal"><span class="pre">depth</span></code>.</td>
</tr>
<tr class="row-even"><td>2</td>
<td><code class="docutils literal"><span class="pre">(0,</span> <span class="pre">b),</span> <span class="pre">(0,</span> <span class="pre">d),</span> <span class="pre">(0,</span> <span class="pre">e),</span> <span class="pre">(1,</span> <span class="pre">c)</span></code></td>
<td>The recursive step for <strong>c</strong> succeeds, since <code class="docutils literal"><span class="pre">depth</span></code> now has a value for all its children (<strong>d</strong> and <strong>e</strong>). The recursive step for <strong>a</strong> still fails.</td>
</tr>
<tr class="row-odd"><td>3</td>
<td><code class="docutils literal"><span class="pre">(0,</span> <span class="pre">b),</span> <span class="pre">(0,</span> <span class="pre">d),</span> <span class="pre">(0,</span> <span class="pre">e),</span> <span class="pre">(1,</span> <span class="pre">c),</span> <span class="pre">(2,</span> <span class="pre">a)</span></code></td>
<td>The recursive step for <strong>a</strong> succeeds, since <code class="docutils literal"><span class="pre">depth</span></code> now has a value for all its children (<strong>b</strong> and <strong>c</strong>).</td>
</tr>
</tbody>
</table>
<p>Here, we can see that at the intermediate stages it is very important for the aggregate to
fail if some of the children lack a value - this prevents erroneous values being added.</p>
</div>
</div>
</div>
<div class="section" id="any">
<span id="index-13"></span><h2>Any<a class="headerlink" href="#any" title="Permalink to this headline">¶</a></h2>
<p>The general syntax of an <code class="docutils literal"><span class="pre">any</span></code> expression is similar to the syntax of an
<a class="reference internal" href="#aggregations"><span class="std std-ref">aggregation</span></a>, namely:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">any</span><span class="p">(</span><span class="o">&lt;</span><span class="n">variable</span> <span class="n">declarations</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">formula</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>You should always include the <a class="reference internal" href="variables.html#variable-declarations"><span class="std std-ref">variable declarations</span></a>, but the
<a class="reference internal" href="formulas.html#formulas"><span class="std std-ref">formula</span></a> and <a class="reference internal" href="#expressions"><span class="std std-ref">expression</span></a> parts are optional.</p>
<p>The <code class="docutils literal"><span class="pre">any</span></code> expression denotes any values that are of a particular form and that satisfy a
particular condition.
More precisely, the <code class="docutils literal"><span class="pre">any</span></code> expression:</p>
<ol class="arabic simple">
<li>Introduces temporary variables.</li>
<li>Restricts their values to those that satisfy the <code class="docutils literal"><span class="pre">&lt;formula&gt;</span></code> part (if it’s present).</li>
<li>Returns <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> for each of those variables. If there is no <code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code> part,
then it returns the variables themselves.</li>
</ol>
<p>The following table lists some examples of different forms of <code class="docutils literal"><span class="pre">any</span></code> expressions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Expression</th>
<th class="head">Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">any(File</span> <span class="pre">f)</span></code></td>
<td>all <code class="docutils literal"><span class="pre">File</span></code>s in the database</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">any(Element</span> <span class="pre">e</span> <span class="pre">|</span> <span class="pre">e.getName())</span></code></td>
<td>the names of all <code class="docutils literal"><span class="pre">Element</span></code>s in the database</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">any(int</span> <span class="pre">i</span> <span class="pre">|</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">[0</span> <span class="pre">..</span> <span class="pre">3])</span></code></td>
<td>the integers <code class="docutils literal"><span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">2</span></code>, and <code class="docutils literal"><span class="pre">3</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">any(int</span> <span class="pre">i</span> <span class="pre">|</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">[0</span> <span class="pre">..</span> <span class="pre">3]</span> <span class="pre">|</span> <span class="pre">i</span> <span class="pre">*</span> <span class="pre">i)</span></code></td>
<td>the integers <code class="docutils literal"><span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">4</span></code>, and <code class="docutils literal"><span class="pre">9</span></code></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is also a <a class="reference external" href="https://help.semmle.com/QL/ql-spec/language.html#non-member-built-ins">built-in predicate</a>
<code class="docutils literal"><span class="pre">any()</span></code>. This is a predicate that always holds.</p>
</div>
</div>
<div class="section" id="unary-operations">
<h2>Unary operations<a class="headerlink" href="#unary-operations" title="Permalink to this headline">¶</a></h2>
<p>A unary operation is a minus sign (<code class="docutils literal"><span class="pre">-</span></code>) or a plus sign (<code class="docutils literal"><span class="pre">+</span></code>) followed by an expression of type
<code class="docutils literal"><span class="pre">int</span></code> or <code class="docutils literal"><span class="pre">float</span></code>. For example:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="o">-</span><span class="m">6.28</span>
<span class="o">+</span><span class="p">(</span><span class="m">10</span> <span class="o">-</span> <span class="m">4</span><span class="p">)</span>
<span class="o">+</span><span class="k">avg</span><span class="p">(</span><span class="kt">float</span> <span class="n">f</span> <span class="o">|</span> <span class="n">f</span> <span class="o">=</span> <span class="m">3.4</span> <span class="k">or</span> <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="m">9.8</span><span class="p">)</span>
<span class="o">-</span><span class="k">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="k">in</span> <span class="p">[</span><span class="m">0</span> <span class="p">..</span> <span class="m">9</span><span class="p">]</span> <span class="o">|</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>A plus sign leaves the values of the expression unchanged, while a minus sign takes the
arithmetic negations of the values.</p>
</div>
<div class="section" id="binary-operations">
<span id="id5"></span><h2>Binary operations<a class="headerlink" href="#binary-operations" title="Permalink to this headline">¶</a></h2>
<p>A binary operation consists of an expression, followed by a binary operator, followed by
another expression. For example:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="m">5</span> <span class="o">%</span> <span class="m">2</span>
<span class="p">(</span><span class="m">9</span> <span class="o">+</span> <span class="m">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="o">-</span><span class="m">2</span><span class="p">)</span>
<span class="s">&quot;Q&quot;</span> <span class="o">+</span> <span class="s">&quot;L&quot;</span>
<span class="m">2</span> <span class="o">*</span> <span class="k">min</span><span class="p">(</span><span class="kt">float</span> <span class="n">f</span> <span class="o">|</span> <span class="n">f</span> <span class="k">in</span> <span class="p">[</span><span class="o">-</span><span class="m">3</span> <span class="p">..</span> <span class="m">3</span><span class="p">])</span>
</pre></div>
</div>
<p id="index-14">You can use the following binary operators in QL:</p>
<table border="1" class="docutils">
<colgroup>
<col width="75%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Symbol</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Addition/concatenation</td>
<td><code class="docutils literal"><span class="pre">+</span></code></td>
</tr>
<tr class="row-odd"><td>Multiplication</td>
<td><code class="docutils literal"><span class="pre">*</span></code></td>
</tr>
<tr class="row-even"><td>Division</td>
<td><code class="docutils literal"><span class="pre">/</span></code></td>
</tr>
<tr class="row-odd"><td>Subtraction</td>
<td><code class="docutils literal"><span class="pre">-</span></code></td>
</tr>
<tr class="row-even"><td>Modulo</td>
<td><code class="docutils literal"><span class="pre">%</span></code></td>
</tr>
</tbody>
</table>
<p>If both expressions are numbers, these operators act as standard arithmetic operators. For
example, <code class="docutils literal"><span class="pre">10.6</span> <span class="pre">-</span> <span class="pre">3.2</span></code> has value <code class="docutils literal"><span class="pre">7.4</span></code>, <code class="docutils literal"><span class="pre">123.456</span> <span class="pre">*</span> <span class="pre">0</span></code> has value <code class="docutils literal"><span class="pre">0</span></code>, and <code class="docutils literal"><span class="pre">9</span> <span class="pre">%</span> <span class="pre">4</span></code> has
value <code class="docutils literal"><span class="pre">1</span></code> (the remainder after dividing <code class="docutils literal"><span class="pre">9</span></code> by <code class="docutils literal"><span class="pre">4</span></code>).
If both operands are integers, then the result is an integer. Otherwise the result is a
floating-point number.</p>
<p>You can also use <code class="docutils literal"><span class="pre">+</span></code> as a string concatenation operator. In this case, at least one of the
expressions must be a string—the other expression is implicitly converted to a string using the
<code class="docutils literal"><span class="pre">toString()</span></code> predicate. The two expressions are concatenated, and the result is a string. For
example, the expression <code class="docutils literal"><span class="pre">221</span> <span class="pre">+</span> <span class="pre">&quot;B&quot;</span></code> has value <code class="docutils literal"><span class="pre">&quot;221B&quot;</span></code>.</p>
</div>
<div class="section" id="casts">
<span id="id6"></span><h2>Casts<a class="headerlink" href="#casts" title="Permalink to this headline">¶</a></h2>
<p>A cast allows you to constrain the <a class="reference internal" href="types.html#types"><span class="std std-ref">type</span></a> of an expression. This is similar to casting in other
languages, for example in Java.</p>
<dl class="docutils">
<dt>You can write a cast in two ways:</dt>
<dd><ul class="first last simple">
<li>As a “postfix” cast: A dot followed by the name of a type in parentheses.
For example, <code class="docutils literal"><span class="pre">x.(Foo)</span></code> restricts the type of <code class="docutils literal"><span class="pre">x</span></code> to <code class="docutils literal"><span class="pre">Foo</span></code>.</li>
<li>As a “prefix” cast: A type in parentheses followed by another expression.
For example, <code class="docutils literal"><span class="pre">(Foo)x</span></code> also restricts the type of <code class="docutils literal"><span class="pre">x</span></code> to <code class="docutils literal"><span class="pre">Foo</span></code>.</li>
</ul>
</dd>
</dl>
<p>Note that a postfix cast is equivalent to a prefix cast surrounded by parentheses—<code class="docutils literal"><span class="pre">x.(Foo)</span></code>
is exactly equivalent to <code class="docutils literal"><span class="pre">((Foo)x)</span></code>.</p>
<p>Casts are useful if you want to call a <a class="reference internal" href="types.html#member-predicates"><span class="std std-ref">member predicate</span></a> that is only defined for a more
specific type. For example, the following query selects Java
<a class="reference external" href="https://help.semmle.com/qldoc/java/semmle/code/java/Type.qll/type.Type$Class.html">classes</a>
that have a direct supertype called “List”:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="n">java</span>

<span class="k">from</span> <span class="n">Type</span> <span class="n">t</span>
<span class="k">where</span> <span class="n">t</span><span class="p">.(</span><span class="n">Class</span><span class="p">).</span><span class="n">getASupertype</span><span class="p">().</span><span class="n">hasName</span><span class="p">(</span><span class="s">&quot;List&quot;</span><span class="p">)</span>
<span class="k">select</span> <span class="n">t</span>
</pre></div>
</div>
<p>Since the predicate <code class="docutils literal"><span class="pre">getASupertype()</span></code> is defined for <code class="docutils literal"><span class="pre">Class</span></code>, but not for <code class="docutils literal"><span class="pre">Type</span></code>, you
can’t call <code class="docutils literal"><span class="pre">t.getASupertype()</span></code> directly. The cast <code class="docutils literal"><span class="pre">t.(Class)</span></code> ensures that <code class="docutils literal"><span class="pre">t</span></code> is
of type <code class="docutils literal"><span class="pre">Class</span></code>, so it has access to the desired predicate.</p>
<p>If you prefer to use a prefix cast, you can rewrite the <code class="docutils literal"><span class="pre">where</span></code> part as:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">where</span> <span class="p">((</span><span class="n">Class</span><span class="p">)</span><span class="n">t</span><span class="p">).</span><span class="n">getASupertype</span><span class="p">().</span><span class="n">hasName</span><span class="p">(</span><span class="s">&quot;List&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="don-t-care-expressions">
<span id="dont-care"></span><span id="index-15"></span><h2>Don’t-care expressions<a class="headerlink" href="#don-t-care-expressions" title="Permalink to this headline">¶</a></h2>
<p>This is an expression written as a single underscore <code class="docutils literal"><span class="pre">_</span></code>. It represents any value. (You
“don’t care” what the value is.)</p>
<p>Unlike other expressions, a don’t-care expression does not have a type. In practice, this
means that <code class="docutils literal"><span class="pre">_</span></code> doesn’t have any <a class="reference internal" href="types.html#member-predicates"><span class="std std-ref">member predicates</span></a>, so you can’t
call <code class="docutils literal"><span class="pre">_.somePredicate()</span></code>.</p>
<p>For example, the following query selects all the characters in the string <code class="docutils literal"><span class="pre">&quot;hello&quot;</span></code>:</p>
<div class="highlight-ql"><div class="highlight"><pre><span></span><span class="k">from</span> <span class="kt">string</span> <span class="n">s</span>
<span class="k">where</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="p">.</span><span class="n">charAt</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="k">select</span> <span class="n">s</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">charAt(int</span> <span class="pre">i)</span></code> predicate is defined on strings and usually takes an <code class="docutils literal"><span class="pre">int</span></code> argument.
Here the don’t care expression <code class="docutils literal"><span class="pre">_</span></code> is used to tell the query to select characters at
every possible index. The query returns the values <code class="docutils literal"><span class="pre">h</span></code>, <code class="docutils literal"><span class="pre">e</span></code>, <code class="docutils literal"><span class="pre">l</span></code>, and <code class="docutils literal"><span class="pre">o</span></code>.</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    </div>
    <div class="privacy">
            <a target="_blank" href="https://help.semmle.com/privacy-policy.html" alt="Privacy policy and tracking preferences" title="Privacy policy and tracking preferences">Privacy policy</a>
    </div>
    
</div>


 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .name").show();
        $(".toggle .name").click(function() {
            $(this).parent().children().not(".name").toggle(400);
            $(this).parent().children(".name").toggleClass("open");
        })
    });
</script>

  </body>
</html>