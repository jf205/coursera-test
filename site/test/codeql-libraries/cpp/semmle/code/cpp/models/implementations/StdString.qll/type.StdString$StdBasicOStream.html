<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="qldoc"><meta name="description" content="API documentation for CodeQL"><meta name="keywords" content="CodeQL,QL,StdBasicOStream"><meta name="addsearch-category" content="C/C++ CodeQL library"><title>StdBasicOStream</title><link rel="stylesheet" type="text/css" href="https://unpkg.com/@primer/css/dist/primer.css"><link rel="stylesheet" type="text/css" href="../../../../../../qldoc.css"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-5Q9DBRM');</script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q9DBRM" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="Header text-white"><div class="Header-item"><svg class="octicon octicon-mark-github mr-2" height="32" viewbox="0 0 16 16" width="32"><path fill-rule="even-odd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg></div><div class="Header-item--full f2 text-bold">CodeQL library for C/C++</div><div class="Header-item"><span>Version 1.26.0</span></div><div class="Header-item .text-gray-light"><div class="nav-section"><a href="../../../../../../index.html">Index</a></div></div><div class="Header-item"><a title="Search the CodeQL libraries" target="_blank" href="https://help.semmle.com/home/help/search-results-qldoc.html"><span class=".text-gray-light">Search</span></a></div></div><div id="main"><nav id="sidebar"><div id="sidebar-content" class="pt-2"><div class="nav-section"><p>For other CodeQL resources, including tutorials and examples, see <a href="https://help.semmle.com/QL/learn-ql/" class="learn-ql-link" target="_blank">Learning CodeQL</a><p>.</p></p><h2 class="section-heading"><a href="type.StdString$StdBasicOStream.html" class="ref-link ref-type">StdBasicOStream</a></h2><div class="doc-block"><ol class="section-links"><li></li><li></li><li><a href="type.StdString$StdBasicOStream.html#Import%20path">Import path</a></li><li><a href="type.StdString$StdBasicOStream.html#Direct%20supertypes">Direct supertypes</a></li><li><a href="type.StdString$StdBasicOStream.html#Indirect%20supertypes">Indirect supertypes</a></li><li><a href="type.StdString$StdBasicOStream.html#Inherited%20predicates">Inherited predicates</a></li><li><a href="type.StdString$StdBasicOStream.html#Charpred">Charpred</a></li></ol></div></div><div class="nav-section"><div><div><h2 class="section-heading"><span>Module <a href="module.StdString.html" class="ref-link ref-module" title="Module StdString">StdString</a></span></h2></div><div><h3 class="subsection-heading">Imports</h3><div class="doc-block"><table><tbody><tr><td><a href="../Iterator.qll/module.Iterator.html" class="ref-link ref-module" title="Module Iterator">Iterator</a></td></tr><tr><td><a href="../../interfaces/Taint.qll/module.Taint.html" class="ref-link ref-module" title="Module Taint">Taint</a></td></tr></tbody></table></div></div><div><h3 class="subsection-heading">Classes</h3><div class="doc-block"><table><tbody><tr><td><a href="type.StdString$StdBasicIStream.html" class="ref-link ref-type" title="Class StdString::StdBasicIStream">StdBasicIStream</a></td></tr><tr><td><a href="type.StdString$StdBasicOStream.html" class="ref-link ref-type" title="Class StdString::StdBasicOStream">StdBasicOStream</a></td></tr><tr><td><a href="type.StdString$StdBasicString.html" class="ref-link ref-type" title="Class StdString::StdBasicString">StdBasicString</a></td></tr><tr><td><a href="type.StdString$StdGetLine.html" class="ref-link ref-type" title="Class StdString::StdGetLine">StdGetLine</a></td></tr><tr><td><a href="type.StdString$StdIStreamGet.html" class="ref-link ref-type" title="Class StdString::StdIStreamGet">StdIStreamGet</a></td></tr><tr><td><a href="type.StdString$StdIStreamGetLine.html" class="ref-link ref-type" title="Class StdString::StdIStreamGetLine">StdIStreamGetLine</a></td></tr><tr><td><a href="type.StdString$StdIStreamIn.html" class="ref-link ref-type" title="Class StdString::StdIStreamIn">StdIStreamIn</a></td></tr><tr><td><a href="type.StdString$StdIStreamInNonMember.html" class="ref-link ref-type" title="Class StdString::StdIStreamInNonMember">StdIStreamInNonMember</a></td></tr><tr><td><a href="type.StdString$StdIStreamPutBack.html" class="ref-link ref-type" title="Class StdString::StdIStreamPutBack">StdIStreamPutBack</a></td></tr><tr><td><a href="type.StdString$StdIStreamRead.html" class="ref-link ref-type" title="Class StdString::StdIStreamRead">StdIStreamRead</a></td></tr><tr><td><a href="type.StdString$StdIStreamReadSome.html" class="ref-link ref-type" title="Class StdString::StdIStreamReadSome">StdIStreamReadSome</a></td></tr><tr><td><a href="type.StdString$StdOStreamOut.html" class="ref-link ref-type" title="Class StdString::StdOStreamOut">StdOStreamOut</a></td></tr><tr><td><a href="type.StdString$StdOStreamOutNonMember.html" class="ref-link ref-type" title="Class StdString::StdOStreamOutNonMember">StdOStreamOutNonMember</a></td></tr><tr><td><a href="type.StdString$StdStreamFunction.html" class="ref-link ref-type" title="Class StdString::StdStreamFunction">StdStreamFunction</a></td></tr><tr><td><a href="type.StdString$StdStringAppend.html" class="ref-link ref-type" title="Class StdString::StdStringAppend">StdStringAppend</a></td></tr><tr><td><a href="type.StdString$StdStringAssign.html" class="ref-link ref-type" title="Class StdString::StdStringAssign">StdStringAssign</a></td></tr><tr><td><a href="type.StdString$StdStringAt.html" class="ref-link ref-type" title="Class StdString::StdStringAt">StdStringAt</a></td></tr><tr><td><a href="type.StdString$StdStringCStr.html" class="ref-link ref-type" title="Class StdString::StdStringCStr">StdStringCStr</a></td></tr><tr><td><a href="type.StdString$StdStringConstructor.html" class="ref-link ref-type" title="Class StdString::StdStringConstructor">StdStringConstructor</a></td></tr><tr><td><a href="type.StdString$StdStringCopy.html" class="ref-link ref-type" title="Class StdString::StdStringCopy">StdStringCopy</a></td></tr><tr><td><a href="type.StdString$StdStringData.html" class="ref-link ref-type" title="Class StdString::StdStringData">StdStringData</a></td></tr><tr><td><a href="type.StdString$StdStringFrontBack.html" class="ref-link ref-type" title="Class StdString::StdStringFrontBack">StdStringFrontBack</a></td></tr><tr><td><a href="type.StdString$StdStringPlus.html" class="ref-link ref-type" title="Class StdString::StdStringPlus">StdStringPlus</a></td></tr><tr><td><a href="type.StdString$StdStringPush.html" class="ref-link ref-type" title="Class StdString::StdStringPush">StdStringPush</a></td></tr><tr><td><a href="type.StdString$StdStringStreamConstructor.html" class="ref-link ref-type" title="Class StdString::StdStringStreamConstructor">StdStringStreamConstructor</a></td></tr><tr><td><a href="type.StdString$StdStringStreamStr.html" class="ref-link ref-type" title="Class StdString::StdStringStreamStr">StdStringStreamStr</a></td></tr><tr><td><a href="type.StdString$StdStringSubstr.html" class="ref-link ref-type" title="Class StdString::StdStringSubstr">StdStringSubstr</a></td></tr><tr><td><a href="type.StdString$StdStringSwap.html" class="ref-link ref-type" title="Class StdString::StdStringSwap">StdStringSwap</a></td></tr></tbody></table></div></div></div></div></div></nav><div class="overflow-y-auto width-full pt-2"><div id="content"><div><h1 class="section-heading" id="StdString::StdBasicOStream"><span><span>Class <span><a href="type.StdString$StdBasicOStream.html" class="ref-link ref-type" title="Class StdString::StdBasicOStream">StdBasicOStream</a></span></span></span></h1></div><div><div class="doc-block"><div class="qldoc"><p>The <code>std::basic_ostream</code> template class.</p>
</div></div></div><div><h2 class="subsection-heading" id="Import path">Import path</h2><div class="doc-block"><code>import semmle.code.cpp.models.implementations.StdString</code></div></div><div><h2 class="subsection-heading" id="Direct supertypes">Direct supertypes</h2><div><div class="doc-block"><ul class="inline-list comma-list"><li><a href="../../../Class.qll/type.Class$TemplateClass.html" class="ref-link ref-type" title="Class TemplateClass">TemplateClass</a></li></ul></div></div></div><div><h2 class="subsection-heading" id="Indirect supertypes">Indirect supertypes</h2><div><div class="doc-block"><ul class="inline-list comma-list"><li><a href="../../../../../../type.@declaration.html" class="ref-link ref-type" title="Union type @declaration">@declaration</a></li><li><a href="../../../../../../type.@declaredtype.html" class="ref-link ref-type" title="Union type @declaredtype">@declaredtype</a></li><li><a href="../../../../../../type.@element.html" class="ref-link ref-type" title="Union type @element">@element</a></li><li><a href="../../../../../../type.@enclosingfunction_child.html" class="ref-link ref-type" title="Union type @enclosingfunction_child">@enclosingfunction_child</a></li><li><a href="../../../../../../type.@exprparent.html" class="ref-link ref-type" title="Union type @exprparent">@exprparent</a></li><li><a href="../../../../../../type.@locatable.html" class="ref-link ref-type" title="Union type @locatable">@locatable</a></li><li><a href="../../../../../../type.@member.html" class="ref-link ref-type" title="Union type @member">@member</a></li><li><a href="../../../../../../type.@namedscope.html" class="ref-link ref-type" title="Union type @namedscope">@namedscope</a></li><li><a href="../../../../../../type.@namequalifyingelement.html" class="ref-link ref-type" title="Union type @namequalifyingelement">@namequalifyingelement</a></li><li><a href="../../../../../../type.@namespacembr.html" class="ref-link ref-type" title="Union type @namespacembr">@namespacembr</a></li><li><a href="../../../../../../type.@type.html" class="ref-link ref-type" title="Union type @type">@type</a></li><li><a href="../../../../../../type.@usertype.html" class="ref-link ref-type" title="Type @usertype">@usertype</a></li><li><a href="../../../Declaration.qll/type.Declaration$AccessHolder.html" class="ref-link ref-type" title="Class AccessHolder">AccessHolder</a></li><li><a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></li><li><a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></li><li><a href="../../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></li><li><a href="../../../Element.qll/type.Element$ElementBase.html" class="ref-link ref-type" title="Class ElementBase">ElementBase</a></li><li><a href="../../../Location.qll/type.Location$Locatable.html" class="ref-link ref-type" title="Class Locatable">Locatable</a></li><li><a href="../../../NameQualifiers.qll/type.NameQualifiers$NameQualifyingElement.html" class="ref-link ref-type" title="Class NameQualifyingElement">NameQualifyingElement</a></li><li><a href="../../../Declaration.qll/type.Declaration$TAccessHolder.html" class="ref-link ref-type" title="Type TAccessHolder">TAccessHolder</a></li><li><a href="../../../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></li><li><a href="../../../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></li></ul></div></div></div><div><h2 class="subsection-heading" id="Inherited predicates">Inherited predicates</h2><div class="doc-block"><table><tbody><tr><td><a href="../../../Class.qll/predicate.Class$Class$accessOfBaseMember.2.html" class="ref-link ref-predicate" title="Member predicate Class::accessOfBaseMember">accessOfBaseMember</a></td><td><span class="qldoc-summary"><p>Gets the access specifier, if any, that a hypothetical member of <code>base</code>  would have when viewed as a member of <code>this</code>, given that this member had  access specifier <code>fieldInBase</code>. Encodes the rules of C++14 11.2/1 and  11.6/1, except that this predicate includes the case of <code>base</code> = <code>this</code>.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$accessOfBaseMember.1.html" class="ref-link ref-predicate" title="Member predicate Class::accessOfBaseMember">accessOfBaseMember</a></td><td><span class="qldoc-summary"><p>Gets the access specifier, if any, that <code>member</code> has when viewed as a  member of <code>this</code>, where <code>member</code> may come from a base class of <code>this</code>.  Encodes the rules of C++14 11.2/1 and 11.6/1, except that this predicate  includes the case of <code>base</code> = <code>this</code>.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$AccessHolder$canAccessClass.2.html" class="ref-link ref-predicate" title="Member predicate AccessHolder::canAccessClass">canAccessClass</a></td><td><span class="qldoc-summary"><p>Holds if a base class <code>base</code> of <code>derived</code> <em>is accessible at</em> <code>this</code> (N4140  11.2/4). When this holds, and <code>derived</code> has only one base subobject of  type <code>base</code>, code in <code>this</code> can implicitly convert a pointer to <code>derived</code>  into a pointer to <code>base</code>. Conversely, if such a conversion is possible  then this predicate holds.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$AccessHolder.html" class="ref-link ref-type" title="Class AccessHolder">AccessHolder</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$AccessHolder$canAccessMember.2.html" class="ref-link ref-predicate" title="Member predicate AccessHolder::canAccessMember">canAccessMember</a></td><td><span class="qldoc-summary"><p>Holds if a non-static member <code>member</code> <em>is accessible at</em> <code>this</code> when named  in a class <code>derived</code> that is derived from or equal to the declaring class  of <code>member</code> (N4140 11.2/5 and 11.4).</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$AccessHolder.html" class="ref-link ref-type" title="Class AccessHolder">AccessHolder</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$AccessHolder$couldAccessMember.3.html" class="ref-link ref-predicate" title="Member predicate AccessHolder::couldAccessMember">couldAccessMember</a></td><td><span class="qldoc-summary"><p>Holds if a hypothetical non-static member of <code>memberClass</code> with access  specifier <code>memberAccess</code> <em>is accessible at</em> <code>this</code> when named in a class  <code>derived</code> that is derived from or equal to <code>memberClass</code> (N4140 11.2/5 and  11.4).</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$AccessHolder.html" class="ref-link ref-type" title="Class AccessHolder">AccessHolder</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$derivesFrom.1.html" class="ref-link ref-predicate" title="Member predicate Class::derivesFrom">derivesFrom</a></td><td><span class="qldoc-summary"><p>Holds if this class/struct derives directly from that.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$explain.0.html" class="ref-link ref-predicate" title="Member predicate Class::explain">explain</a></td><td><span class="qldoc-summary"><p>Gets a detailed string representation explaining the AST of this type  (with all specifiers and nested constructs such as pointers). This is  intended to help debug queries and is a very expensive operation; not  to be used in production queries.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Element.qll/predicate.Element$Element$findRootCause.0.html" class="ref-link ref-predicate" title="Member predicate Element::findRootCause">findRootCause</a></td><td><span class="qldoc-summary"><p>Gets the source of this element: either itself or a macro that expanded  to this element.</p>
</span></td><td><span>from <a href="../../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><span class="deprecated"><a href="../../../Element.qll/predicate.Element$Element$fromLibrary.0.html" class="ref-link ref-predicate" title="Member predicate Element::fromLibrary">fromLibrary</a></span></td><td><span class="qldoc-summary"><p>Holds if this element may be from a library.</p>
</span></td><td><span>from <a href="../../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../Element.qll/predicate.Element$Element$fromSource.0.html" class="ref-link ref-predicate" title="Member predicate Element::fromSource">fromSource</a></td><td><span class="qldoc-summary"><p>Holds if this element may be from source.</p>
</span></td><td><span>from <a href="../../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getABaseClass.0.html" class="ref-link ref-predicate" title="Member predicate Class::getABaseClass">getABaseClass</a></td><td><span class="qldoc-summary"><p>Gets a direct base class/struct of this class/struct [N4140 10].</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getABaseClassByteOffset.1.html" class="ref-link ref-predicate" title="Member predicate Class::getABaseClassByteOffset">getABaseClassByteOffset</a></td><td><span class="qldoc-summary"><p>Gets the byte offset within <code>this</code> of each base class subobject of type  <code>baseClass</code>, or zero if <code>baseClass</code> and <code>this</code> are the same type. Both  direct and indirect base classes are included.  Note that for virtual base classes, and non-virtual base classes thereof,  this predicate assumes that <code>this</code> is the type of the complete most-derived  object.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getACanonicalMember.0.html" class="ref-link ref-predicate" title="Member predicate Class::getACanonicalMember">getACanonicalMember</a></td><td><span class="qldoc-summary"><p>Gets a member declared in this class, struct or union.  If you also want template instantiations of results, see  <code>getAMember()</code>.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getACanonicalMemberFunction.0.html" class="ref-link ref-predicate" title="Member predicate Class::getACanonicalMemberFunction">getACanonicalMemberFunction</a></td><td><span class="qldoc-summary"><p>Gets a function declared in this class, struct or union.  For template member functions, results include only the template.  If you also want instantiations of the template, then use  <code>getAMemberFunction()</code> instead.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getACanonicalMemberVariable.0.html" class="ref-link ref-predicate" title="Member predicate Class::getACanonicalMemberVariable">getACanonicalMemberVariable</a></td><td><span class="qldoc-summary"><p>Gets a member variable declared in this class, struct or union.  For template member variables, results include only the template.  If you also want instantiations of the template, then use  <code>getAMemberVariable()</code> instead.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getAConstructor.0.html" class="ref-link ref-predicate" title="Member predicate Class::getAConstructor">getAConstructor</a></td><td><span class="qldoc-summary"><p>Gets a constructor of this class, struct or union.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getADeclaration.0.html" class="ref-link ref-predicate" title="Member predicate Class::getADeclaration">getADeclaration</a></td><td><span class="qldoc-summary"><p>Gets a child declaration of this class, struct or union.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../UserType.qll/predicate.UserType$UserType$getADeclarationEntry.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getADeclarationEntry">getADeclarationEntry</a></td><td><span class="qldoc-summary"><p>Gets a declaration entry corresponding to this declaration. See the  comment above this class for an explanation of the relationship  between <code>Declaration</code> and <code>DeclarationEntry</code>.</p>
</span></td><td><span>from <a href="../../../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../../../UserType.qll/predicate.UserType$UserType$getADeclarationLocation.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getADeclarationLocation">getADeclarationLocation</a></td><td><span class="qldoc-summary"><p>Gets the location of a declaration entry corresponding to this  declaration.</p>
</span></td><td><span>from <a href="../../../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getADerivation.0.html" class="ref-link ref-predicate" title="Member predicate Class::getADerivation">getADerivation</a></td><td><span class="qldoc-summary"><p>Gets a class derivation of this class/struct, for example the  <code>public B</code> in the following code:  <code>class D : public B { ... };</code></p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getADerivedClass.0.html" class="ref-link ref-predicate" title="Member predicate Class::getADerivedClass">getADerivedClass</a></td><td><span class="qldoc-summary"><p>Gets a class/struct that is directly derived from this class/struct [N4140 10].</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getAField.0.html" class="ref-link ref-predicate" title="Member predicate Class::getAField">getAField</a></td><td><span class="qldoc-summary"><p>Gets a field of this class, struct or union.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$getAFile.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::getAFile">getAFile</a></td><td><span class="qldoc-summary"><p>Gets a file where this element occurs.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getAFriendDecl.0.html" class="ref-link ref-predicate" title="Member predicate Class::getAFriendDecl">getAFriendDecl</a></td><td><span class="qldoc-summary"><p>Gets a friend declaration in this class, struct or union.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getALinkTarget.0.html" class="ref-link ref-predicate" title="Member predicate Class::getALinkTarget">getALinkTarget</a></td><td><span class="qldoc-summary"><p>Gets a link target which references this class, struct or union.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getAMember.0.html" class="ref-link ref-predicate" title="Member predicate Class::getAMember">getAMember</a></td><td><span class="qldoc-summary"><p>Gets a member declared in this class, struct or union.  For template members, this may be either the template or an instantiation  of that template. If you only want the template, see  <code>getACanonicalMember()</code>.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getAMember.1.html" class="ref-link ref-predicate" title="Member predicate Class::getAMember">getAMember</a></td><td><span class="qldoc-summary"><p>Gets the (zero-based) <code>index</code>th canonical member declared in this  class, struct or union. If that member is a template, all instantiations  of that template. If you only want the canonical member, see  <code>getCanonicalMember(int)</code>.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getAMemberFunction.0.html" class="ref-link ref-predicate" title="Member predicate Class::getAMemberFunction">getAMemberFunction</a></td><td><span class="qldoc-summary"><p>Gets a function declared in this class, struct or union.  For template member functions, results include both the template  and the instantiations of that template. If you only want the  template, then use <code>getACanonicalMemberFunction()</code> instead.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getAMemberVariable.0.html" class="ref-link ref-predicate" title="Member predicate Class::getAMemberVariable">getAMemberVariable</a></td><td><span class="qldoc-summary"><p>Gets a member variable declared in this class, struct or union.  For template member variables, results include both the template  and the instantiations of that template. If you only want the  template, then use <code>getACanonicalMemberVariable()</code> instead.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../NameQualifiers.qll/predicate.NameQualifiers$NameQualifyingElement$getANameQualifier.0.html" class="ref-link ref-predicate" title="Member predicate NameQualifyingElement::getANameQualifier">getANameQualifier</a></td><td><span class="qldoc-summary"><p>Gets a name qualifier for which this is the qualifying namespace or  user-defined type. For example: class <code>X</code> is the  <code>NameQualifyingElement</code> and <code>X::</code> is the <code>NameQualifier</code>.</p>
</span></td><td><span>from <a href="../../../NameQualifiers.qll/type.NameQualifiers$NameQualifyingElement.html" class="ref-link ref-type" title="Class NameQualifyingElement">NameQualifyingElement</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getANestedType.0.html" class="ref-link ref-predicate" title="Member predicate Class::getANestedType">getANestedType</a></td><td><span class="qldoc-summary"><p>Gets a type declared in this class, struct or union.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$TemplateClass$getAPrimaryQlClass.0.html" class="ref-link ref-predicate" title="Member predicate TemplateClass::getAPrimaryQlClass">getAPrimaryQlClass</a></td><td><span class="qldoc-summary"><p>Gets the name of a primary CodeQL class to which this element belongs.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$TemplateClass.html" class="ref-link ref-type" title="Class TemplateClass">TemplateClass</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getAPrivateCanonicalMember.0.html" class="ref-link ref-predicate" title="Member predicate Class::getAPrivateCanonicalMember">getAPrivateCanonicalMember</a></td><td><span class="qldoc-summary"><p>Gets a private canonical member declared in this class, struct or union.  If you also want template instantiations of results, see  <code>getAPrivateMember()</code>.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getAPrivateMember.0.html" class="ref-link ref-predicate" title="Member predicate Class::getAPrivateMember">getAPrivateMember</a></td><td><span class="qldoc-summary"><p>Gets a private member declared in this class, struct or union.  For template members, this may be either the template or an  instantiation of that template. For just the template, use  <code>getAPrivateCanonicalMember()</code>.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getAProtectedCanonicalMember.0.html" class="ref-link ref-predicate" title="Member predicate Class::getAProtectedCanonicalMember">getAProtectedCanonicalMember</a></td><td><span class="qldoc-summary"><p>Gets a protected canonical member declared in this class, struct or union.  If you also want template instantiations of results, see  <code>getAProtectedMember()</code>.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getAProtectedMember.0.html" class="ref-link ref-predicate" title="Member predicate Class::getAProtectedMember">getAProtectedMember</a></td><td><span class="qldoc-summary"><p>Gets a protected member declared in this class, struct or union.  For template members, this may be either the template or an  instantiation of that template. For just the template, use  <code>getAProtectedCanonicalMember()</code>.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getAPublicCanonicalMember.0.html" class="ref-link ref-predicate" title="Member predicate Class::getAPublicCanonicalMember">getAPublicCanonicalMember</a></td><td><span class="qldoc-summary"><p>Gets a public canonical member declared in this class, struct or union.  If you also want template instantiations of results, see  <code>getAPublicMember()</code>.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getAPublicMember.0.html" class="ref-link ref-predicate" title="Member predicate Class::getAPublicMember">getAPublicMember</a></td><td><span class="qldoc-summary"><p>Gets a public member declared in this class, struct or union.  For template members, this may be either the template or an  instantiation of that template. For just the template, use  <code>getAPublicCanonicalMember()</code>.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../UserType.qll/predicate.UserType$UserType$getASpecifier.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getASpecifier">getASpecifier</a></td><td></td><td><span>from <a href="../../../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getAStaticMember.0.html" class="ref-link ref-predicate" title="Member predicate Class::getAStaticMember">getAStaticMember</a></td><td><span class="qldoc-summary"><p>Gets a static member declared in this class, struct or union.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$getATemplateArgument.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::getATemplateArgument">getATemplateArgument</a></td><td><span class="qldoc-summary"><p>Gets a template argument used to instantiate this declaration from a template.  When called on a template, this will return a template parameter type for  both typed and non-typed parameters.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$getATemplateArgumentKind.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::getATemplateArgumentKind">getATemplateArgumentKind</a></td><td><span class="qldoc-summary"><p>Gets a template argument used to instantiate this declaration from a template.  When called on a template, this will return a non-typed template  parameter value.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../Type.qll/predicate.Type$Type$getATypeNameUse.0.html" class="ref-link ref-predicate" title="Member predicate Type::getATypeNameUse">getATypeNameUse</a></td><td><span class="qldoc-summary"><p>Gets as many places as possible where this type is used by name in the source after macros have been replaced  (in particular, therefore, this will find type name uses caused by macros). Note that all type name uses within  instantiations are currently excluded - this is too draconian in the absence of indexing prototype instantiations  of functions, and is likely to improve in the future. At present, the method takes the conservative approach of  giving valid type name uses, but not necessarily <em>all</em> type name uses.</p>
</span></td><td><span>from <a href="../../../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getAlignment.0.html" class="ref-link ref-predicate" title="Member predicate Class::getAlignment">getAlignment</a></td><td><span class="qldoc-summary"><p>Gets the alignment of this type in bytes (on the machine where facts were  extracted).</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Type.qll/predicate.Type$Type$getAnAttribute.0.html" class="ref-link ref-predicate" title="Member predicate Type::getAnAttribute">getAnAttribute</a></td><td><span class="qldoc-summary"><p>Gets an attribute of this type.</p>
</span></td><td><span>from <a href="../../../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$TemplateClass$getAnInstantiation.0.html" class="ref-link ref-predicate" title="Member predicate TemplateClass::getAnInstantiation">getAnInstantiation</a></td><td><span class="qldoc-summary"><p>Gets a class instantiated from this template.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$TemplateClass.html" class="ref-link ref-type" title="Class TemplateClass">TemplateClass</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getCanonicalMember.1.html" class="ref-link ref-predicate" title="Member predicate Class::getCanonicalMember">getCanonicalMember</a></td><td><span class="qldoc-summary"><p>Gets the (zero-based) <code>index</code>th member declared in this class, struct  or union.  If you also want template instantiations of results, see  <code>getAMember(int)</code>.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><span class="deprecated"><a href="../../../Element.qll/predicate.Element$ElementBase$getCanonicalQLClass.0.html" class="ref-link ref-predicate" title="Member predicate ElementBase::getCanonicalQLClass">getCanonicalQLClass</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: use <code>getAPrimaryQlClass</code> instead.</p>
</span></td><td><span>from <a href="../../../Element.qll/type.Element$ElementBase.html" class="ref-link ref-type" title="Class ElementBase">ElementBase</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$getDeclaringType.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::getDeclaringType">getDeclaringType</a></td><td><span class="qldoc-summary"><p>Gets the class where this member is declared, if it is a member.  For templates, both the template itself and all instantiations of  the template are considered to have the same declaring class.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../UserType.qll/predicate.UserType$UserType$getDefinition.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getDefinition">getDefinition</a></td><td><span class="qldoc-summary"><p>Gets the declaration entry corresponding to this declaration that is a  definition, if any.</p>
</span></td><td><span>from <a href="../../../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../../../UserType.qll/predicate.UserType$UserType$getDefinitionLocation.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getDefinitionLocation">getDefinitionLocation</a></td><td><span class="qldoc-summary"><p>Gets the location of the definition, if any.</p>
</span></td><td><span>from <a href="../../../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getDerivation.1.html" class="ref-link ref-predicate" title="Member predicate Class::getDerivation">getDerivation</a></td><td><span class="qldoc-summary"><p>Gets class derivation number <code>index</code> of this class/struct, for example the  <code>public B</code> is derivation 1 in the following code:  <code>class D : public A, public B, public C { ... };</code></p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$getDescription.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::getDescription">getDescription</a></td><td><span class="qldoc-summary"><p>Gets a description of this <code>Declaration</code> for display purposes.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getDestructor.0.html" class="ref-link ref-predicate" title="Member predicate Class::getDestructor">getDestructor</a></td><td><span class="qldoc-summary"><p>Gets the destructor of this class, struct or union, if any.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../UserType.qll/predicate.UserType$UserType$getEnclosingAccessHolder.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getEnclosingAccessHolder">getEnclosingAccessHolder</a></td><td><span class="qldoc-summary"><p>Gets the nearest enclosing <code>AccessHolder</code>.</p>
</span></td><td><span>from <a href="../../../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../../../Element.qll/predicate.Element$Element$getEnclosingElement.0.html" class="ref-link ref-predicate" title="Member predicate Element::getEnclosingElement">getEnclosingElement</a></td><td><span class="qldoc-summary"><p>Gets the closest <code>Element</code> enclosing this one.</p>
</span></td><td><span>from <a href="../../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../UserType.qll/predicate.UserType$UserType$getEnclosingFunction.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getEnclosingFunction">getEnclosingFunction</a></td><td><span class="qldoc-summary"><p>Gets the function that directly encloses this type (if any).</p>
</span></td><td><span>from <a href="../../../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../../../Element.qll/predicate.Element$Element$getFile.0.html" class="ref-link ref-predicate" title="Member predicate Element::getFile">getFile</a></td><td><span class="qldoc-summary"><p>Gets the primary file where this element occurs.</p>
</span></td><td><span>from <a href="../../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../UserType.qll/predicate.UserType$UserType$getLocation.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getLocation">getLocation</a></td><td><span class="qldoc-summary"><p>Gets the preferred location of this declaration, if any.</p>
</span></td><td><span>from <a href="../../../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><span class="deprecated"><a href="../../../Class.qll/predicate.Class$Class$getMember.1.html" class="ref-link ref-predicate" title="Member predicate Class::getMember">getMember</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Use <code>getCanonicalMember(int)</code> or <code>getAMember(int)</code> instead.  Gets the <code>index</code>th member of this class.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getMetrics.0.html" class="ref-link ref-predicate" title="Member predicate Class::getMetrics">getMetrics</a></td><td><span class="qldoc-summary"><p>Gets the metric class associated with this class, struct or union.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../UserType.qll/predicate.UserType$UserType$getName.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getName">getName</a></td><td><span class="qldoc-summary"><p>Gets the name of this type.</p>
</span></td><td><span>from <a href="../../../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$getNamespace.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::getNamespace">getNamespace</a></td><td><span class="qldoc-summary"><p>Gets the innermost namespace which contains this declaration.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><span class="deprecated"><a href="../../../Class.qll/predicate.Class$Class$getNumMember.0.html" class="ref-link ref-predicate" title="Member predicate Class::getNumMember">getNumMember</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: As this includes a somewhat arbitrary number of              template instantiations, it is unlikely to do what              you need.  Gets the number of members that this class has. This includes both  templates that are in this class, and instantiations of those  templates.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$getNumberOfTemplateArguments.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::getNumberOfTemplateArguments">getNumberOfTemplateArguments</a></td><td><span class="qldoc-summary"><p>Gets the number of template arguments for this declaration.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../Element.qll/predicate.Element$Element$getParentScope.0.html" class="ref-link ref-predicate" title="Member predicate Element::getParentScope">getParentScope</a></td><td><span class="qldoc-summary"><p>Gets the parent scope of this <code>Element</code>, if any.  A scope is a <code>Type</code> (<code>Class</code> / <code>Enum</code>), a <code>Namespace</code>, a <code>BlockStmt</code>, a <code>Function</code>,  or certain kinds of <code>Statement</code>.</p>
</span></td><td><span>from <a href="../../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../Type.qll/predicate.Type$Type$getPointerIndirectionLevel.0.html" class="ref-link ref-predicate" title="Member predicate Type::getPointerIndirectionLevel">getPointerIndirectionLevel</a></td><td><span class="qldoc-summary"><p>Gets the pointer indirection level of this type.</p>
</span></td><td><span>from <a href="../../../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$getQualifiedName.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::getQualifiedName">getQualifiedName</a></td><td><span class="qldoc-summary"><p>Gets the name of the declaration, fully qualified with its  namespace and declaring type.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../UserType.qll/predicate.UserType$UserType$getSimpleName.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getSimpleName">getSimpleName</a></td><td><span class="qldoc-summary"><p>Gets the simple name of this type, without any template parameters.  For example  if the name of the type is <code>&quot;myType&lt;int&gt;&quot;</code>, the simple name is just <code>&quot;myType&quot;</code>.</p>
</span></td><td><span>from <a href="../../../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../../../Type.qll/predicate.Type$Type$getSize.0.html" class="ref-link ref-predicate" title="Member predicate Type::getSize">getSize</a></td><td><span class="qldoc-summary"><p>Gets the size of this type in bytes.</p>
</span></td><td><span>from <a href="../../../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$getTemplateArgument.1.html" class="ref-link ref-predicate" title="Member predicate Declaration::getTemplateArgument">getTemplateArgument</a></td><td><span class="qldoc-summary"><p>Gets the <code>i</code>th template argument used to instantiate this declaration from a  template.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$getTemplateArgumentKind.1.html" class="ref-link ref-predicate" title="Member predicate Declaration::getTemplateArgumentKind">getTemplateArgumentKind</a></td><td><span class="qldoc-summary"><p>Gets the <code>i</code>th template argument value used to instantiate this declaration  from a template. When called on a template, this will return the <code>i</code>th template  parameter value if it exists.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../Type.qll/predicate.Type$Type$getUnderlyingType.0.html" class="ref-link ref-predicate" title="Member predicate Type::getUnderlyingType">getUnderlyingType</a></td><td><span class="qldoc-summary"><p>Gets this type after typedefs have been resolved.</p>
</span></td><td><span>from <a href="../../../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../../../Type.qll/predicate.Type$Type$getUnspecifiedType.0.html" class="ref-link ref-predicate" title="Member predicate Type::getUnspecifiedType">getUnspecifiedType</a></td><td><span class="qldoc-summary"><p>Gets this type after specifiers have been deeply stripped and typedefs have been resolved.</p>
</span></td><td><span>from <a href="../../../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getUuid.0.html" class="ref-link ref-predicate" title="Member predicate Class::getUuid">getUuid</a></td><td><span class="qldoc-summary"><p>Gets the UUID that associated with this class, struct or union via the  <code>__declspec(uuid)</code> attribute.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$getVirtualBaseClassByteOffset.1.html" class="ref-link ref-predicate" title="Member predicate Class::getVirtualBaseClassByteOffset">getVirtualBaseClassByteOffset</a></td><td><span class="qldoc-summary"><p>Gets the byte offset of virtual base class subobject <code>base</code> within a  most-derived object of class <code>this</code>. The virtual base can be a direct or  indirect virtual base of <code>this</code>. Does not hold if <code>this</code> is an  uninstantiated template.  See <code>ClassDerivation.getByteOffset</code> for offsets of non-virtual base  classes.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$hasConstructor.0.html" class="ref-link ref-predicate" title="Member predicate Class::hasConstructor">hasConstructor</a></td><td><span class="qldoc-summary"><p>Holds if this class, struct or union has a constructor.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><span class="deprecated"><a href="../../../Class.qll/predicate.Class$Class$hasCopyAssignmentOperator.0.html" class="ref-link ref-predicate" title="Member predicate Class::hasCopyAssignmentOperator">hasCopyAssignmentOperator</a></span></td><td><span class="qldoc-summary"><p>Holds if this class has a copy assignment operator that is either  explicitly declared (though possibly <code>= delete</code>) or is auto-generated,  non-trivial and called from somewhere.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><span class="deprecated"><a href="../../../Class.qll/predicate.Class$Class$hasCopyConstructor.0.html" class="ref-link ref-predicate" title="Member predicate Class::hasCopyConstructor">hasCopyConstructor</a></span></td><td><span class="qldoc-summary"><p>Holds if this class has a copy constructor that is either explicitly  declared (though possibly <code>= delete</code>) or is auto-generated, non-trivial  and called from somewhere.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$hasDeclaringType.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::hasDeclaringType">hasDeclaringType</a></td><td><span class="qldoc-summary"><p>Holds if this declaration is a member of a class/struct/union.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$hasDefinition.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::hasDefinition">hasDefinition</a></td><td><span class="qldoc-summary"><p>Holds if the declaration has a definition.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$hasDestructor.0.html" class="ref-link ref-predicate" title="Member predicate Class::hasDestructor">hasDestructor</a></td><td><span class="qldoc-summary"><p>Holds if this class, struct or union has a destructor.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><span class="deprecated"><a href="../../../Class.qll/predicate.Class$Class$hasGeneratedCopyAssignmentOperator.0.html" class="ref-link ref-predicate" title="Member predicate Class::hasGeneratedCopyAssignmentOperator">hasGeneratedCopyAssignmentOperator</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: name changed to <code>hasImplicitCopyAssignmentOperator</code> to  reflect that <code>= default</code> members are no longer included.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><span class="deprecated"><a href="../../../Class.qll/predicate.Class$Class$hasGeneratedCopyConstructor.0.html" class="ref-link ref-predicate" title="Member predicate Class::hasGeneratedCopyConstructor">hasGeneratedCopyConstructor</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: name changed to <code>hasImplicitCopyConstructor</code> to reflect that  <code>= default</code> members are no longer included.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$hasGlobalName.1.html" class="ref-link ref-predicate" title="Member predicate Declaration::hasGlobalName">hasGlobalName</a></td><td><span class="qldoc-summary"><p>Holds if this declaration has the given name in the global namespace.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$hasGlobalOrStdName.1.html" class="ref-link ref-predicate" title="Member predicate Declaration::hasGlobalOrStdName">hasGlobalOrStdName</a></td><td><span class="qldoc-summary"><p>Holds if this declaration has the given name in the global namespace or the <code>std</code> namespace.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$hasImplicitCopyAssignmentOperator.0.html" class="ref-link ref-predicate" title="Member predicate Class::hasImplicitCopyAssignmentOperator">hasImplicitCopyAssignmentOperator</a></td><td><span class="qldoc-summary"><p>Holds if this class, struct or union has an implicitly-declared copy  assignment operator that is not <em>deleted</em>. This predicate is more  accurate than checking if this class, struct or union has a  <code>CopyAssignmentOperator ca</code> where <code>ca.isCompilerGenerated()</code> since such a  <code>CopyAssignmentOperator</code> may not exist in the database if (1) it is never  called or (2) it is <em>trivial</em>, meaning that it is equivalent to <code>memcpy</code>.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$hasImplicitCopyConstructor.0.html" class="ref-link ref-predicate" title="Member predicate Class::hasImplicitCopyConstructor">hasImplicitCopyConstructor</a></td><td><span class="qldoc-summary"><p>Holds if this class, struct or union has an implicitly-declared copy  constructor that is not <em>deleted</em>. This predicate is more accurate than  checking if this class, struct or union has a <code>CopyConstructor cc</code> where  <code>cc.isCompilerGenerated()</code> since such a <code>CopyConstructor</code> may not exist  in the database if (1) it is never called or (2) it is <em>trivial</em>, meaning  that it is equivalent to <code>memcpy</code>.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../UserType.qll/predicate.UserType$UserType$hasName.1.html" class="ref-link ref-predicate" title="Member predicate UserType::hasName">hasName</a></td><td></td><td><span>from <a href="../../../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$hasPrivateBaseClass.1.html" class="ref-link ref-predicate" title="Member predicate Class::hasPrivateBaseClass">hasPrivateBaseClass</a></td><td><span class="qldoc-summary"><p>Holds if this class/struct has a private class derivation, for  example the <code>private B</code> in the following code:  <code>class D : private B { ... };</code></p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$hasProtectedBaseClass.1.html" class="ref-link ref-predicate" title="Member predicate Class::hasProtectedBaseClass">hasProtectedBaseClass</a></td><td><span class="qldoc-summary"><p>Holds if this class/struct has a protected class derivation, for  example the <code>protected B</code> in the following code:  <code>class D : protected B { ... };</code></p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$hasPublicBaseClass.1.html" class="ref-link ref-predicate" title="Member predicate Class::hasPublicBaseClass">hasPublicBaseClass</a></td><td><span class="qldoc-summary"><p>Holds if this class/struct has a public class derivation, for  example the <code>public B</code> in the following code:  <code>class D : public B { ... };</code></p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$hasQualifiedName.1.html" class="ref-link ref-predicate" title="Member predicate Declaration::hasQualifiedName">hasQualifiedName</a></td><td><span class="qldoc-summary"><p>DEPRECATED: Prefer <code>hasGlobalName</code> or the 2-argument or 3-argument  <code>hasQualifiedName</code> predicates. To get the exact same results as this  predicate in all edge cases, use <code>getQualifiedName()</code>.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$hasQualifiedName.3.html" class="ref-link ref-predicate" title="Member predicate Declaration::hasQualifiedName">hasQualifiedName</a></td><td><span class="qldoc-summary"><p>Holds if this declaration has a fully-qualified name with a name-space  component of <code>namespaceQualifier</code>, a declaring type of <code>typeQualifier</code>,  and a base name of <code>baseName</code>. Template parameters and arguments are  stripped from all components. Missing components are <code>&quot;&quot;</code>.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$hasQualifiedName.2.html" class="ref-link ref-predicate" title="Member predicate Declaration::hasQualifiedName">hasQualifiedName</a></td><td><span class="qldoc-summary"><p>Holds if this declaration has a fully-qualified name with a name-space  component of <code>namespaceQualifier</code>, no declaring type, and a base name of  <code>baseName</code>.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../UserType.qll/predicate.UserType$UserType$hasSpecifier.1.html" class="ref-link ref-predicate" title="Member predicate UserType::hasSpecifier">hasSpecifier</a></td><td></td><td><span>from <a href="../../../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$hasVirtualBaseClass.1.html" class="ref-link ref-predicate" title="Member predicate Class::hasVirtualBaseClass">hasVirtualBaseClass</a></td><td><span class="qldoc-summary"><p>Holds if this class/struct has a virtual class derivation, for  example the <code>virtual public B</code> in the following code:  <code>class D : virtual public B { ... };</code></p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$implicitCopyAssignmentOperatorDeleted.0.html" class="ref-link ref-predicate" title="Member predicate Class::implicitCopyAssignmentOperatorDeleted">implicitCopyAssignmentOperatorDeleted</a></td><td><span class="qldoc-summary"><p>Holds if the compiler would be unable to generate a copy assignment  operator for this class, struct or union. This predicate implements the  rules listed here:  <a href="http://en.cppreference.com/w/cpp/language/copy_assignment#Deleted_implicitly-declared_copy_assignment_operator">http://en.cppreference.com/w/cpp/language/copy_assignment#Deleted_implicitly-declared_copy_assignment_operator</a></p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$implicitCopyConstructorDeleted.0.html" class="ref-link ref-predicate" title="Member predicate Class::implicitCopyConstructorDeleted">implicitCopyConstructorDeleted</a></td><td><span class="qldoc-summary"><p>Holds if the compiler would be unable to generate a copy constructor for  this class, struct or union. This predicate implements the rules listed  here:  <a href="http://en.cppreference.com/w/cpp/language/copy_constructor#Deleted_implicitly-declared_copy_constructor">http://en.cppreference.com/w/cpp/language/copy_constructor#Deleted_implicitly-declared_copy_constructor</a></p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$AccessHolder$inMemberOrFriendOf.1.html" class="ref-link ref-predicate" title="Member predicate AccessHolder::inMemberOrFriendOf">inMemberOrFriendOf</a></td><td><span class="qldoc-summary"><p>Holds if <code>this</code> can access private members of class <code>c</code>.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$AccessHolder.html" class="ref-link ref-type" title="Class AccessHolder">AccessHolder</a></span></td></tr><tr><td><a href="../../../Type.qll/predicate.Type$Type$internal_getAnAdditionalSpecifier.0.html" class="ref-link ref-predicate" title="Member predicate Type::internal_getAnAdditionalSpecifier">internal_getAnAdditionalSpecifier</a></td><td><span class="qldoc-summary"><p>Internal &ndash; should be <code>protected</code> when QL supports such a flag. Subtypes  override this to recursively get specifiers that are not attached directly  to this <code>@type</code> in the database but arise through type aliases such as  <code>typedef</code> and <code>decltype</code>.</p>
</span></td><td><span>from <a href="../../../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../../../Type.qll/predicate.Type$Type$involvesReference.0.html" class="ref-link ref-predicate" title="Member predicate Type::involvesReference">involvesReference</a></td><td><span class="qldoc-summary"><p>Holds if this type involves a reference.</p>
</span></td><td><span>from <a href="../../../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$involvesTemplateParameter.0.html" class="ref-link ref-predicate" title="Member predicate Class::involvesTemplateParameter">involvesTemplateParameter</a></td><td><span class="qldoc-summary"><p>Holds if this type involves a template parameter.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$isAbstract.0.html" class="ref-link ref-predicate" title="Member predicate Class::isAbstract">isAbstract</a></td><td><span class="qldoc-summary"><p>Holds if this class/struct is abstract, in other words whether  it declares one or more pure virtual member functions.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Element.qll/predicate.Element$Element$isAffectedByMacro.0.html" class="ref-link ref-predicate" title="Member predicate Element::isAffectedByMacro">isAffectedByMacro</a></td><td><span class="qldoc-summary"><p>Holds if this element is affected in any way by a macro. All elements  that are totally or partially generated by a macro are included, so  this is a super-set of <code>isInMacroExpansion</code>.</p>
</span></td><td><span>from <a href="../../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../UserType.qll/predicate.UserType$UserType$isAnonymous.0.html" class="ref-link ref-predicate" title="Member predicate UserType::isAnonymous">isAnonymous</a></td><td><span class="qldoc-summary"><p>Holds if this type is anonymous.</p>
</span></td><td><span>from <a href="../../../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../../../Type.qll/predicate.Type$Type$isConst.0.html" class="ref-link ref-predicate" title="Member predicate Type::isConst">isConst</a></td><td><span class="qldoc-summary"><p>Holds if this type is const.</p>
</span></td><td><span>from <a href="../../../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$isConstructedFrom.1.html" class="ref-link ref-predicate" title="Member predicate Class::isConstructedFrom">isConstructedFrom</a></td><td><span class="qldoc-summary"><p>Holds if this class, struct or union is constructed from another class as  a result of template instantiation. It originates either from a class  template or from a class nested in a class template.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Type.qll/predicate.Type$Type$isDeeplyConst.0.html" class="ref-link ref-predicate" title="Member predicate Type::isDeeplyConst">isDeeplyConst</a></td><td><span class="qldoc-summary"><p>Holds if this type is constant and only contains constant types.  For instance, a <code>char *const</code> is a constant type, but not deeply constant,  because while the pointer can&rsquo;t be modified the character can. The type  <code>const char *const*</code> is a deeply constant type though - both the pointer  and what it points to are immutable.</p>
</span></td><td><span>from <a href="../../../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$isDeeplyConstBelow.0.html" class="ref-link ref-predicate" title="Member predicate Class::isDeeplyConstBelow">isDeeplyConstBelow</a></td><td><span class="qldoc-summary"><p>Holds if this type is constant and only contains constant types, excluding  the type itself. It is implied by Type.isDeeplyConst() and is just used to  implement that predicate.  For example, <code>const char *const</code> is deeply constant and deeply constant below,  but <code>const char *</code> is only deeply constant below (the pointer can be changed,  but not the underlying char). <code>char *const</code> is neither (it is just <code>const</code>).</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$isDefined.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::isDefined">isDefined</a></td><td><span class="qldoc-summary"><p>DEPRECATED: Use <code>hasDefinition</code> instead.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$isFinal.0.html" class="ref-link ref-predicate" title="Member predicate Class::isFinal">isFinal</a></td><td><span class="qldoc-summary"><p>Holds if this class, struct or union was declared &lsquo;final&rsquo;.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Element.qll/predicate.Element$Element$isFromTemplateInstantiation.1.html" class="ref-link ref-predicate" title="Member predicate Element::isFromTemplateInstantiation">isFromTemplateInstantiation</a></td><td><span class="qldoc-summary"><p>Holds if this <code>Element</code> is a part of a template instantiation (but not  the template itself).</p>
</span></td><td><span>from <a href="../../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../Element.qll/predicate.Element$Element$isFromUninstantiatedTemplate.1.html" class="ref-link ref-predicate" title="Member predicate Element::isFromUninstantiatedTemplate">isFromUninstantiatedTemplate</a></td><td><span class="qldoc-summary"><p>Holds if this <code>Element</code> is part of a template <code>template</code> (not if it is  part of an instantiation of <code>template</code>). This means it is represented in  the database purely as syntax and without guarantees on the presence or  correctness of type-based operations such as implicit conversions.</p>
</span></td><td><span>from <a href="../../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../Element.qll/predicate.Element$Element$isInMacroExpansion.0.html" class="ref-link ref-predicate" title="Member predicate Element::isInMacroExpansion">isInMacroExpansion</a></td><td><span class="qldoc-summary"><p>Holds if this element comes from a macro expansion. Only elements that  are entirely generated by a macro are included - for elements that  partially come from a macro, see <code>isAffectedByMacro</code>.</p>
</span></td><td><span>from <a href="../../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../UserType.qll/predicate.UserType$UserType$isLocal.0.html" class="ref-link ref-predicate" title="Member predicate UserType::isLocal">isLocal</a></td><td><span class="qldoc-summary"><p>Holds if this is a local type (that is, a type that has a directly-enclosing  function).</p>
</span></td><td><span>from <a href="../../../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$isMember.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::isMember">isMember</a></td><td><span class="qldoc-summary"><p>Holds if this declaration is a member of a class/struct/union.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$isPOD.0.html" class="ref-link ref-predicate" title="Member predicate Class::isPOD">isPOD</a></td><td><span class="qldoc-summary"><p>Holds if this class, struct or union is a POD (Plain Old Data) class  [N4140 9(10)].</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$isPolymorphic.0.html" class="ref-link ref-predicate" title="Member predicate Class::isPolymorphic">isPolymorphic</a></td><td><span class="qldoc-summary"><p>Holds if this class/struct is polymorphic (has a virtual function, or  inherits one).</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$isStandardLayout.0.html" class="ref-link ref-predicate" title="Member predicate Class::isStandardLayout">isStandardLayout</a></td><td><span class="qldoc-summary"><p>Holds if this class, struct or union is a standard-layout class  [N4140 9(7)]. Also holds for structs in C programs.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$isStatic.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::isStatic">isStatic</a></td><td><span class="qldoc-summary"><p>Holds if this declaration is static.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$isTopLevel.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::isTopLevel">isTopLevel</a></td><td><span class="qldoc-summary"><p>Holds if this declaration is a top-level declaration.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../../../Type.qll/predicate.Type$Type$isVolatile.0.html" class="ref-link ref-predicate" title="Member predicate Type::isVolatile">isVolatile</a></td><td><span class="qldoc-summary"><p>Holds if this type is volatile.</p>
</span></td><td><span>from <a href="../../../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../../../Type.qll/predicate.Type$Type$refersTo.1.html" class="ref-link ref-predicate" title="Member predicate Type::refersTo">refersTo</a></td><td><span class="qldoc-summary"><p>Holds if this type refers to type <code>t</code> (by default,  a type always refers to itself).</p>
</span></td><td><span>from <a href="../../../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../../../Class.qll/predicate.Class$Class$refersToDirectly.1.html" class="ref-link ref-predicate" title="Member predicate Class::refersToDirectly">refersToDirectly</a></td><td><span class="qldoc-summary"><p>Holds if this type refers to type <code>t</code> directly.</p>
</span></td><td><span>from <a href="../../../Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></span></td></tr><tr><td><a href="../../../Type.qll/predicate.Type$Type$resolveTypedefs.0.html" class="ref-link ref-predicate" title="Member predicate Type::resolveTypedefs">resolveTypedefs</a></td><td><span class="qldoc-summary"><p>Gets this type with any typedefs resolved. For example, given  <code>typedef C T</code>, this would resolve <code>const T&amp;amp;</code> to <code>const C&amp;amp;</code>.  Note that this will only work if the resolved type actually appears  on its own elsewhere in the program.</p>
</span></td><td><span>from <a href="../../../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../../../Type.qll/predicate.Type$Type$stripTopLevelSpecifiers.0.html" class="ref-link ref-predicate" title="Member predicate Type::stripTopLevelSpecifiers">stripTopLevelSpecifiers</a></td><td><span class="qldoc-summary"><p>Gets this type after any top-level specifiers and typedefs have been stripped.</p>
</span></td><td><span>from <a href="../../../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../../../Type.qll/predicate.Type$Type$stripType.0.html" class="ref-link ref-predicate" title="Member predicate Type::stripType">stripType</a></td><td><span class="qldoc-summary"><p>Gets the type stripped of pointers, references and cv-qualifiers, and resolving typedefs.  For example, given <code>typedef const C&amp;amp; T</code>, <code>stripType</code> returns <code>C</code>.</p>
</span></td><td><span>from <a href="../../../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../../../Declaration.qll/predicate.Declaration$Declaration$toString.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::toString">toString</a></td><td><span class="qldoc-summary"><p>Gets a textual representation of this element.</p>
</span></td><td><span>from <a href="../../../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr></tbody></table></div></div><div><h2 class="subsection-heading" id="Charpred">Charpred</h2><div class="doc-block"><table><tbody><tr><td><a href="predicate.StdString$StdBasicOStream$StdBasicOStream.0.html" class="ref-link ref-predicate" title="Characteristic predicate StdString::StdBasicOStream::StdBasicOStream">StdBasicOStream</a></td><td></td></tr></tbody></table></div></div></div></div></div><footer id="content-footer">Copyright 2020 GitHub Software UK Ltd.<a title="Privacy statement and tracking preferences" target="_blank" href="https://docs.github.com/github/site-policy/github-privacy-statement">Privacy Statement</a></footer></body></html>