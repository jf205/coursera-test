<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="qldoc"><meta name="description" content="API documentation for CodeQL"><meta name="keywords" content="CodeQL,QL,cpp"><meta name="addsearch-category" content="C/C++ CodeQL library"><title>cpp</title><link rel="stylesheet" type="text/css" href="https://unpkg.com/@primer/css/dist/primer.css"><link rel="stylesheet" type="text/css" href="../qldoc.css"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-5Q9DBRM');</script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q9DBRM" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="Header text-white"><div class="Header-item"><svg class="octicon octicon-mark-github mr-2" height="32" viewbox="0 0 16 16" width="32"><path fill-rule="even-odd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg></div><div class="Header-item--full f2 text-bold">CodeQL library for C/C++</div><div class="Header-item"><span>Version 1.26.0</span></div><div class="Header-item .text-gray-light"><div class="nav-section"><a href="../index.html">Index</a></div></div><div class="Header-item"><a title="Search the CodeQL libraries" target="_blank" href="https://help.semmle.com/home/help/search-results-qldoc.html"><span class=".text-gray-light">Search</span></a></div></div><div id="main"><nav id="sidebar"><div id="sidebar-content" class="pt-2"><div class="nav-section"><p>For other CodeQL resources, including tutorials and examples, see <a href="https://help.semmle.com/QL/learn-ql/" class="learn-ql-link" target="_blank">Learning CodeQL</a><p>.</p></p><h2 class="section-heading"><a href="module.cpp.html" class="ref-link ref-module">cpp</a></h2><div class="doc-block"><ol class="section-links"><li></li><li></li><li><a href="module.cpp.html#Import%20path">Import path</a></li><li><a href="module.cpp.html#Predicates">Predicates</a></li><li><a href="module.cpp.html#Classes">Classes</a></li><li><a href="module.cpp.html#Modules">Modules</a></li><li><a href="module.cpp.html#Aliases">Aliases</a></li></ol></div></div></div></nav><div class="overflow-y-auto width-full pt-2"><div id="content"><div><h1 class="section-heading" id="cpp"><span><span>Module <span><a href="module.cpp.html" class="ref-link ref-module" title="Module cpp">cpp</a></span></span></span></h1></div><div><div class="doc-block"><div class="qldoc"><p>Provides classes and predicates for working with C/C++ code.</p>
<p>Where the documentation refers to the standards, it gives
references to the freely-available drafts.</p>
<p>For C++11, these references are of the form [N3337 5.3.2/1], and the
corresponding draft of the standard can be downloaded from
<a href="https://github.com/cplusplus/draft/raw/master/papers/n3337.pdf">https://github.com/cplusplus/draft/raw/master/papers/n3337.pdf</a></p>
<p>For C++14, these references are of the form [N4140 5.3.2/1], and the
corresponding draft of the standard can be downloaded from
<a href="https://github.com/cplusplus/draft/raw/master/papers/n4140.pdf">https://github.com/cplusplus/draft/raw/master/papers/n4140.pdf</a></p>
</div></div></div><div><h2 class="subsection-heading" id="Import path">Import path</h2><div class="doc-block"><code>import cpp</code></div></div><div><h2 class="subsection-heading" id="Predicates">Predicates</h2><div class="doc-block"><table><tbody><tr><td><a href="../semmle/code/cpp/Macro.qll/predicate.Macro$affectedByMacro.1.html" class="ref-link ref-predicate" title="Predicate affectedByMacro">affectedByMacro</a></td><td><span class="qldoc-summary"><p>Holds if <code>element</code> is affected by a macro.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/commons/Alloc.qll/predicate.Alloc$allocationCall.1.html" class="ref-link ref-predicate" title="Predicate allocationCall">allocationCall</a></span></td><td><span class="qldoc-summary"><p>A call to a library routine that allocates memory.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/commons/Alloc.qll/predicate.Alloc$allocationFunction.1.html" class="ref-link ref-predicate" title="Predicate allocationFunction">allocationFunction</a></span></td><td><span class="qldoc-summary"><p>A library routine that allocates memory.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dominance.qll/predicate.Dominance$bbDominates.2.html" class="ref-link ref-predicate" title="Predicate bbDominates">bbDominates</a></td><td><span class="qldoc-summary"><p>Holds if <code>dominator</code> is a dominator of <code>node</code> in the control-flow graph of  basic blocks. This is reflexive.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dominance.qll/predicate.Dominance$bbIDominates.2.html" class="ref-link ref-predicate" title="Predicate bbIDominates">bbIDominates</a></td><td><span class="qldoc-summary"><p>Holds if <code>dominator</code> is an immediate dominator of <code>node</code> in the control-flow  graph of basic blocks.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dominance.qll/predicate.Dominance$bbIPostDominates.2.html" class="ref-link ref-predicate" title="Predicate bbIPostDominates">bbIPostDominates</a></td><td><span class="qldoc-summary"><p>Holds if <code>postDominator</code> is an immediate post-dominator of <code>node</code> in the control-flow  graph of basic blocks.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dominance.qll/predicate.Dominance$bbPostDominates.2.html" class="ref-link ref-predicate" title="Predicate bbPostDominates">bbPostDominates</a></td><td><span class="qldoc-summary"><p>Holds if <code>postDominator</code> is a post-dominator of <code>node</code> in the control-flow graph of  basic blocks. This is reflexive.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dominance.qll/predicate.Dominance$bbStrictlyDominates.2.html" class="ref-link ref-predicate" title="Predicate bbStrictlyDominates">bbStrictlyDominates</a></td><td><span class="qldoc-summary"><p>Holds if <code>dominator</code> is a strict dominator of <code>node</code> in the control-flow  graph of basic blocks. Being strict means that <code>dominator != node</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dominance.qll/predicate.Dominance$bbStrictlyPostDominates.2.html" class="ref-link ref-predicate" title="Predicate bbStrictlyPostDominates">bbStrictlyPostDominates</a></td><td><span class="qldoc-summary"><p>Holds if <code>postDominator</code> is a strict post-dominator of <code>node</code> in the control-flow  graph of basic blocks. Being strict means that <code>postDominator != node</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dataflow.qll/predicate.Dataflow$callByReference.2.html" class="ref-link ref-predicate" title="Predicate callByReference">callByReference</a></td><td><span class="qldoc-summary"><p>Holds if <code>call</code> passes <code>v</code> by reference, either with an explicit address-of  operator or implicitly as a C++ reference. Both const and non-const  references are included.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dereferenced.qll/predicate.Dereferenced$callDereferences.2.html" class="ref-link ref-predicate" title="Predicate callDereferences">callDereferences</a></td><td><span class="qldoc-summary"><p>Holds if the call <code>fc</code> will dereference argument <code>i</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Nullness.qll/predicate.Nullness$callMayReturnNull.1.html" class="ref-link ref-predicate" title="Predicate callMayReturnNull">callMayReturnNull</a></td><td><span class="qldoc-summary"><p>Holds if <code>call</code> may, directly or indirectly, evaluate to a null literal.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/StringAnalysis.qll/predicate.StringAnalysis$canValueFlow.2.html" class="ref-link ref-predicate" title="Predicate canValueFlow">canValueFlow</a></td><td><span class="qldoc-summary"><p>Holds if a value can flow directly from one expr to another.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Nullness.qll/predicate.Nullness$checkedNull.2.html" class="ref-link ref-predicate" title="Predicate checkedNull">checkedNull</a></td><td><span class="qldoc-summary"><p>Holds if <code>var</code> is likely to be null at <code>node</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Nullness.qll/predicate.Nullness$checkedValid.2.html" class="ref-link ref-predicate" title="Predicate checkedValid">checkedValid</a></td><td><span class="qldoc-summary"><p>Holds if <code>var</code> is likely to be non-null at <code>node</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/internal/ConstantExprs.qll/predicate.ConstantExprs$Cached$ControlFlowGraphPublic$conditionAlwaysFalse.1.html" class="ref-link ref-predicate" title="Predicate conditionAlwaysFalse">conditionAlwaysFalse</a></td><td><span class="qldoc-summary"><p>Holds if <code>condition</code> always evaluates to zero.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/internal/ConstantExprs.qll/predicate.ConstantExprs$Cached$ControlFlowGraphPublic$conditionAlwaysTrue.1.html" class="ref-link ref-predicate" title="Predicate conditionAlwaysTrue">conditionAlwaysTrue</a></td><td><span class="qldoc-summary"><p>Holds if <code>condition</code> always evaluates to a nonzero value.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/metrics/MetricFunction.qll/predicate.MetricFunction$cyclomaticComplexityBranches.1.html" class="ref-link ref-predicate" title="Predicate cyclomaticComplexityBranches">cyclomaticComplexityBranches</a></td><td><span class="qldoc-summary"><p>Gets the number of branching statements and expressions in a block. This is  for computing cyclomatic complexity.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dataflow.qll/predicate.Dataflow$definitelyNull.1.html" class="ref-link ref-predicate" title="Predicate definitelyNull">definitelyNull</a></td><td><span class="qldoc-summary"><p>Holds if a simple data-flow analysis determines that <code>e</code> is definitely null.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/DefinitionsAndUses.qll/predicate.DefinitionsAndUses$definition.2.html" class="ref-link ref-predicate" title="Predicate definition">definition</a></td><td><span class="qldoc-summary"><p>Holds if <code>def</code> is a (potential) assignment to stack variable <code>v</code>. That is,  the variable may hold another value in the control-flow node(s)  following <code>def</code> than before.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/DefinitionsAndUses.qll/predicate.DefinitionsAndUses$definitionBarrier.2.html" class="ref-link ref-predicate" title="Predicate definitionBarrier">definitionBarrier</a></td><td><span class="qldoc-summary"><p>Holds if <code>barrier</code> is either a (potential) definition of <code>v</code> or follows an  access that gets the address of <code>v</code>. In both cases, the value of  <code>v</code> after <code>barrier</code> cannot be assumed to be the same as before.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/DefinitionsAndUses.qll/predicate.DefinitionsAndUses$definitionByReference.2.html" class="ref-link ref-predicate" title="Predicate definitionByReference">definitionByReference</a></td><td><span class="qldoc-summary"><p>Holds if <code>va</code> is a variable passed by reference as argument <code>def</code>, where the  callee potentially assigns the corresponding parameter. The  definitions-and-uses library models assignment by reference as if it happens  on evaluation of the argument, <code>def</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/DefinitionsAndUses.qll/predicate.DefinitionsAndUses$definitionReaches.2.html" class="ref-link ref-predicate" title="Predicate definitionReaches">definitionReaches</a></td><td><span class="qldoc-summary"><p>Holds if the definition <code>def</code> of some stack variable can reach <code>node</code>, which  is a definition or use, without crossing definitions of the same variable.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/DefinitionsAndUses.qll/predicate.DefinitionsAndUses$definitionUsePair.3.html" class="ref-link ref-predicate" title="Predicate definitionUsePair">definitionUsePair</a></td><td><span class="qldoc-summary"><p>Computed relation: A &ldquo;definition-use-pair&rdquo; for a particular variable.  Intuitively, this means that <code>def</code> is an assignment to <code>var</code>, and  <code>use</code> is a read of <code>var</code> at which the value assigned by <code>def</code> may  be read. (There can be more than one definition reaching a single  use, and a single definition can reach many uses.)</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dataflow.qll/predicate.Dataflow$deref.2.html" class="ref-link ref-predicate" title="Predicate deref">deref</a></td><td><span class="qldoc-summary"><p>Holds if evaluation of <code>op</code> dereferences <code>v</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dereferenced.qll/predicate.Dereferenced$dereferenced.1.html" class="ref-link ref-predicate" title="Predicate dereferenced">dereferenced</a></td><td><span class="qldoc-summary"><p>Holds if <code>e</code> will be dereferenced after being evaluated.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dereferenced.qll/predicate.Dereferenced$dereferencedByOperation.2.html" class="ref-link ref-predicate" title="Predicate dereferencedByOperation">dereferencedByOperation</a></td><td><span class="qldoc-summary"><p>Holds if evaluation of <code>op</code> dereferences <code>e</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dominance.qll/predicate.Dominance$dominates.2.html" class="ref-link ref-predicate" title="Predicate dominates">dominates</a></td><td><span class="qldoc-summary"><p>Holds if <code>dominator</code> is a dominator of <code>node</code> in the control-flow graph. This  is reflexive.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/DefinitionsAndUses.qll/predicate.DefinitionsAndUses$exprDefinition.3.html" class="ref-link ref-predicate" title="Predicate exprDefinition">exprDefinition</a></td><td><span class="qldoc-summary"><p>Holds if <code>def</code> is a (definite) assignment to the stack variable <code>v</code>. <code>e</code> is  the assigned expression.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/controlflow/ControlFlowGraph.qll/predicate.ControlFlowGraph$falsecond_base.2.html" class="ref-link ref-predicate" title="Predicate falsecond_base">falsecond_base</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Use <code>ControlFlowNode.getAFalseSuccessor()</code> instead.  Holds when <code>n2</code> is a control-flow node such that the control-flow  edge <code>(n1, n2)</code> may be taken when <code>n1</code> is an expression that is false.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/Alloc.qll/predicate.Alloc$freeCall.2.html" class="ref-link ref-predicate" title="Predicate freeCall">freeCall</a></td><td><span class="qldoc-summary"><p>A call to a library routine that frees memory.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/Alloc.qll/predicate.Alloc$freeFunction.2.html" class="ref-link ref-predicate" title="Predicate freeFunction">freeFunction</a></td><td><span class="qldoc-summary"><p>A library routine that frees memory.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dereferenced.qll/predicate.Dereferenced$functionDereferences.2.html" class="ref-link ref-predicate" title="Predicate functionDereferences">functionDereferences</a></td><td><span class="qldoc-summary"><p>Holds if the body of a function <code>f</code> is likely to dereference its <code>i</code>th  parameter unconditionally. This analysis does not account for reassignment.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dominance.qll/predicate.Dominance$functionEntry.1.html" class="ref-link ref-predicate" title="Predicate functionEntry">functionEntry</a></td><td><span class="qldoc-summary"><p>Holds if <code>entry</code> is the entry point of a function.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dominance.qll/predicate.Dominance$functionExit.1.html" class="ref-link ref-predicate" title="Predicate functionExit">functionExit</a></td><td><span class="qldoc-summary"><p>Holds if <code>exit</code> is the exit node of a function.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/FormattingFunction.qll/predicate.FormattingFunction$getAFormatterWideType.0.html" class="ref-link ref-predicate" title="Predicate getAFormatterWideType">getAFormatterWideType</a></td><td><span class="qldoc-summary"><p>A type that is used as a format string by any formatting function.</p>
</span></td></tr><tr><td><a href="../DefaultOptions.qll/predicate.DefaultOptions$getOptions.0.html" class="ref-link ref-predicate" title="Predicate getOptions">getOptions</a></td><td></td></tr><tr><td><a href="../semmle/code/cpp/commons/StructLikeClass.qll/predicate.StructLikeClass$getter.3.html" class="ref-link ref-predicate" title="Predicate getter">getter</a></td><td><span class="qldoc-summary"><p>Holds if <code>f</code> is a getter member function for <code>v</code>, in class <code>c</code>.  See <code>StructLikeClass.getAGetter</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dominance.qll/predicate.Dominance$iDominates.2.html" class="ref-link ref-predicate" title="Predicate iDominates">iDominates</a></td><td><span class="qldoc-summary"><p>Holds if <code>dominator</code> is an immediate dominator of <code>node</code> in the control-flow  graph.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dominance.qll/predicate.Dominance$iPostDominates.2.html" class="ref-link ref-predicate" title="Predicate iPostDominates">iPostDominates</a></td><td><span class="qldoc-summary"><p>Holds if <code>postDominator</code> is an immediate post-dominator of <code>node</code> in the control-flow  graph.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Macro.qll/predicate.Macro$inMacroExpansion.1.html" class="ref-link ref-predicate" title="Predicate inMacroExpansion">inMacroExpansion</a></td><td><span class="qldoc-summary"><p>Holds if <code>element</code> is in the expansion of a macro.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Macro.qll/predicate.Macro$inSystemMacroExpansion.1.html" class="ref-link ref-predicate" title="Predicate inSystemMacroExpansion">inSystemMacroExpansion</a></td><td><span class="qldoc-summary"><p>Holds if <code>element</code> is in the expansion of a macro from  a system header.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/Alloc.qll/predicate.Alloc$isAllocationExpr.1.html" class="ref-link ref-predicate" title="Predicate isAllocationExpr">isAllocationExpr</a></td><td><span class="qldoc-summary"><p>Is e some kind of allocation (<code>new</code>, <code>alloc</code>, <code>realloc</code> etc)?</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/commons/Alloc.qll/predicate.Alloc$isDeallocationExpr.1.html" class="ref-link ref-predicate" title="Predicate isDeallocationExpr">isDeallocationExpr</a></span></td><td><span class="qldoc-summary"><p>Is e some kind of deallocation (<code>delete</code>, <code>free</code>, <code>realloc</code> etc)?</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/commons/Alloc.qll/predicate.Alloc$isFixedSizeAllocationExpr.2.html" class="ref-link ref-predicate" title="Predicate isFixedSizeAllocationExpr">isFixedSizeAllocationExpr</a></span></td><td><span class="qldoc-summary"><p>Is e some kind of allocation (<code>new</code>, <code>alloc</code>, <code>realloc</code> etc) with a fixed size?</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Linkage.qll/predicate.Linkage$isLinkerAwareExtracted.0.html" class="ref-link ref-predicate" title="Predicate isLinkerAwareExtracted">isLinkerAwareExtracted</a></td><td><span class="qldoc-summary"><p>Holds if this database was created with the linker awareness feature  switched on.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/Alloc.qll/predicate.Alloc$isMemoryManagementExpr.1.html" class="ref-link ref-predicate" title="Predicate isMemoryManagementExpr">isMemoryManagementExpr</a></td><td><span class="qldoc-summary"><p>Is e some kind of allocation or deallocation (<code>new</code>, <code>alloc</code>, <code>realloc</code>, <code>delete</code>, <code>free</code> etc)?</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/commons/Alloc.qll/predicate.Alloc$isStdLibAllocationExpr.1.html" class="ref-link ref-predicate" title="Predicate isStdLibAllocationExpr">isStdLibAllocationExpr</a></span></td><td><span class="qldoc-summary"><p>Is e an allocation from stdlib.h (<code>malloc</code>, <code>realloc</code> etc)?</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/Synchronization.qll/predicate.Synchronization$lockCall.2.html" class="ref-link ref-predicate" title="Predicate lockCall">lockCall</a></td><td><span class="qldoc-summary"><p>Holds if <code>call</code> is a call that locks or tries to lock its argument <code>arg</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/internal/ConstantExprs.qll/predicate.ConstantExprs$Cached$ControlFlowGraphPublic$loopConditionAlwaysTrueUponEntry.2.html" class="ref-link ref-predicate" title="Predicate loopConditionAlwaysTrueUponEntry">loopConditionAlwaysTrueUponEntry</a></td><td><span class="qldoc-summary"><p>The condition <code>condition</code> for the loop <code>loop</code> is provably <code>true</code> upon entry.  That is, at least one iteration of the loop is guaranteed.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Macro.qll/predicate.Macro$macroLine.2.html" class="ref-link ref-predicate" title="Predicate macroLine">macroLine</a></td><td><span class="qldoc-summary"><p>Holds if there is a macro invocation on line <code>line</code> of file <code>f</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Macro.qll/predicate.Macro$macroLocation.1.html" class="ref-link ref-predicate" title="Predicate macroLocation">macroLocation</a></td><td><span class="qldoc-summary"><p>Holds if <code>l</code> is the location of a macro.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Nullness.qll/predicate.Nullness$mayReturnNull.1.html" class="ref-link ref-predicate" title="Predicate mayReturnNull">mayReturnNull</a></td><td><span class="qldoc-summary"><p>Holds if <code>f</code> may, directly or indirectly, return a null literal.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dataflow.qll/predicate.Dataflow$maybeNull.1.html" class="ref-link ref-predicate" title="Predicate maybeNull">maybeNull</a></td><td><span class="qldoc-summary"><p>Holds if a simple data-flow analysis determines that <code>e</code> may be null.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Element.qll/predicate.Element$mkElement.1.html" class="ref-link ref-predicate" title="Predicate mkElement">mkElement</a></td><td><span class="qldoc-summary"><p>Get the <code>Element</code> that represents this <code>@element</code>.  Normally this will simply be a cast of <code>e</code>, but sometimes it is not.  For example, for an incomplete struct <code>e</code> the result may be a  complete struct with the same name.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/Synchronization.qll/predicate.Synchronization$mustlockCall.2.html" class="ref-link ref-predicate" title="Predicate mustlockCall">mustlockCall</a></td><td><span class="qldoc-summary"><p>Holds if <code>call</code> is a call that always locks its argument <code>arg</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Nullness.qll/predicate.Nullness$nullCheckExpr.2.html" class="ref-link ref-predicate" title="Predicate nullCheckExpr">nullCheckExpr</a></td><td><span class="qldoc-summary"><p>Holds if <code>var</code> is null when <code>checkExpr</code> evaluates to a true value.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Nullness.qll/predicate.Nullness$nullInit.2.html" class="ref-link ref-predicate" title="Predicate nullInit">nullInit</a></td><td><span class="qldoc-summary"><p>Holds if the evaluation of <code>n</code> may have the effect of, directly or  indirectly, assigning a null literal to <code>var</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Nullness.qll/predicate.Nullness$nullValue.1.html" class="ref-link ref-predicate" title="Predicate nullValue">nullValue</a></td><td><span class="qldoc-summary"><p>Holds if <code>val</code> is a null literal or a call to a function that may return a  null literal.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/DefinitionsAndUses.qll/predicate.DefinitionsAndUses$parameterUsePair.2.html" class="ref-link ref-predicate" title="Predicate parameterUsePair">parameterUsePair</a></td><td><span class="qldoc-summary"><p>Holds if <code>va</code> is a use of the parameter <code>p</code> that could  observe the passed-in value.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Macro.qll/predicate.Macro$possibleMacroLocation.1.html" class="ref-link ref-predicate" title="Predicate possibleMacroLocation">possibleMacroLocation</a></td><td><span class="qldoc-summary"><p>Holds if there might be a macro invocation at location <code>l</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dominance.qll/predicate.Dominance$postDominates.2.html" class="ref-link ref-predicate" title="Predicate postDominates">postDominates</a></td><td><span class="qldoc-summary"><p>Holds if <code>postDominator</code> is a post-dominator of <code>node</code> in the control-flow graph. This  is reflexive.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/Printf.qll/predicate.Printf$primitiveVariadicFormatter.2.html" class="ref-link ref-predicate" title="Predicate primitiveVariadicFormatter">primitiveVariadicFormatter</a></td><td><span class="qldoc-summary"><p>A standard function such as <code>vprintf</code> that has a format parameter  and a variable argument list of type <code>va_arg</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/predicate.Cast$qlCast.1.html" class="ref-link ref-predicate" title="Predicate qlCast">qlCast</a></td><td><span class="qldoc-summary"><p>A node representing the Cast sub-class of entity <code>cast</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/predicate.Cast$qlConversion.1.html" class="ref-link ref-predicate" title="Predicate qlConversion">qlConversion</a></td><td><span class="qldoc-summary"><p>A node representing the Conversion sub-class of entity <code>cast</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/internal/ConstantExprs.qll/predicate.ConstantExprs$Cached$ControlFlowGraphPublic$reachable.1.html" class="ref-link ref-predicate" title="Predicate reachable">reachable</a></td><td><span class="qldoc-summary"><p>Holds if the control-flow node <code>n</code> is reachable, meaning that either  it is an entry point, or there exists a path in the control-flow  graph of its function that connects an entry point to it.  Compile-time constant conditions are taken into account, so that  the call to <code>f</code> is not reachable in <code>if (0) f();</code> even if the  <code>if</code> statement as a whole is reachable.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/StructLikeClass.qll/predicate.StructLikeClass$setter.3.html" class="ref-link ref-predicate" title="Predicate setter">setter</a></td><td><span class="qldoc-summary"><p>Holds if <code>f</code> is a setter member function for <code>v</code>, in class <code>c</code>.  See <code>StructLikeClass.getASetter</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dominance.qll/predicate.Dominance$strictlyDominates.2.html" class="ref-link ref-predicate" title="Predicate strictlyDominates">strictlyDominates</a></td><td><span class="qldoc-summary"><p>Holds if <code>dominator</code> is a strict dominator of <code>node</code> in the control-flow  graph. Being strict means that <code>dominator != node</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dominance.qll/predicate.Dominance$strictlyPostDominates.2.html" class="ref-link ref-predicate" title="Predicate strictlyPostDominates">strictlyPostDominates</a></td><td><span class="qldoc-summary"><p>Holds if <code>postDominator</code> is a strict post-dominator of <code>node</code> in the control-flow  graph. Being strict means that <code>postDominator != node</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/ControlFlowGraph.qll/predicate.ControlFlowGraph$successors_extended.2.html" class="ref-link ref-predicate" title="Predicate successors_extended">successors_extended</a></td><td><span class="qldoc-summary"><p>Holds if there is a control-flow edge from <code>source</code> to <code>target</code> in either  the extractor-generated control-flow graph or in a subclass of  <code>AdditionalControlFlowEdge</code>. Use this relation instead of <code>qlCFGSuccessor</code>.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/controlflow/ControlFlowGraph.qll/predicate.ControlFlowGraph$truecond_base.2.html" class="ref-link ref-predicate" title="Predicate truecond_base">truecond_base</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Use <code>ControlFlowNode.getATrueSuccessor()</code> instead.  Holds when <code>n2</code> is a control-flow node such that the control-flow  edge <code>(n1, n2)</code> may be taken when <code>n1</code> is an expression that is true.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/Synchronization.qll/predicate.Synchronization$trylockCall.2.html" class="ref-link ref-predicate" title="Predicate trylockCall">trylockCall</a></td><td><span class="qldoc-summary"><p>Holds if <code>call</code> is a call that tries to lock its argument <code>arg</code>, but may  return without success.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Element.qll/predicate.Element$underlyingElement.1.html" class="ref-link ref-predicate" title="Predicate underlyingElement">underlyingElement</a></td><td><span class="qldoc-summary"><p>INTERNAL: Do not use.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/Synchronization.qll/predicate.Synchronization$unlockCall.2.html" class="ref-link ref-predicate" title="Predicate unlockCall">unlockCall</a></td><td><span class="qldoc-summary"><p>Holds if <code>call</code> is a call that unlocks its argument <code>arg</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/BasicBlocks.qll/predicate.BasicBlocks$unreachable.1.html" class="ref-link ref-predicate" title="Predicate unreachable">unreachable</a></td><td><span class="qldoc-summary"><p>Correct relation for reachability of ControlFlowNodes.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Element.qll/predicate.Element$unresolveElement.1.html" class="ref-link ref-predicate" title="Predicate unresolveElement">unresolveElement</a></td><td><span class="qldoc-summary"><p>INTERNAL: Do not use.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/DefinitionsAndUses.qll/predicate.DefinitionsAndUses$useOfVar.2.html" class="ref-link ref-predicate" title="Predicate useOfVar">useOfVar</a></td><td><span class="qldoc-summary"><p>Holds if <code>use</code> is a non-definition use of stack variable <code>v</code>. This will not  include accesses on the LHS of an assignment (which don&rsquo;t retrieve the  variable value), but <em>will</em> include accesses in increment/decrement  operations.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/DefinitionsAndUses.qll/predicate.DefinitionsAndUses$useOfVarActual.2.html" class="ref-link ref-predicate" title="Predicate useOfVarActual">useOfVarActual</a></td><td><span class="qldoc-summary"><p>Same as <code>useOfVar(v, use)</code>, but with the extra condition that the  access <code>use</code> actually reads the value of the stack variable <code>v</code> at  run-time. (Non-examples include <code>&amp;x</code> and function calls where the  callee does not use the relevant parameter.)</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/DefinitionsAndUses.qll/predicate.DefinitionsAndUses$useUsePair.3.html" class="ref-link ref-predicate" title="Predicate useUsePair">useUsePair</a></td><td><span class="qldoc-summary"><p>A use/use pair is a pair of uses of a particular variable <code>var</code>  where the same value might be read (meaning that there is a  control-flow path from <code>first</code> to <code>second</code> without crossing  a definition of <code>var</code>).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Nullness.qll/predicate.Nullness$validCheckExpr.2.html" class="ref-link ref-predicate" title="Predicate validCheckExpr">validCheckExpr</a></td><td><span class="qldoc-summary"><p>Holds if <code>var</code> is non-null when <code>checkExpr</code> evaluates to a true value.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/SSAUtils.qll/predicate.SSAUtils$var_definition.2.html" class="ref-link ref-predicate" title="Predicate var_definition">var_definition</a></td><td><span class="qldoc-summary"><p>Extended version of <code>definition</code> that also includes parameters.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/Printf.qll/predicate.Printf$variadicFormatter.2.html" class="ref-link ref-predicate" title="Predicate variadicFormatter">variadicFormatter</a></td><td><span class="qldoc-summary"><p>Holds if <code>f</code> is a function such as <code>vprintf</code> that has a format parameter  (at <code>formatParamIndex</code>) and a variable argument list of type <code>va_arg</code>.</p>
</span></td></tr></tbody></table></div></div><div><h2 class="subsection-heading" id="Classes">Classes</h2><div class="doc-block"><table><tbody><tr><td><a href="../semmle/code/cpp/Class.qll/type.Class$AbstractClass.html" class="ref-link ref-type" title="Class AbstractClass">AbstractClass</a></td><td><span class="qldoc-summary"><p>An &ldquo;abstract class&rdquo;, in other words a class/struct that contains at least one  pure virtual function.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Access.qll/type.Access$Access.html" class="ref-link ref-type" title="Class Access">Access</a></td><td><span class="qldoc-summary"><p>A C/C++ access expression. This refers to a function, variable, or enum constant.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Declaration.qll/type.Declaration$AccessHolder.html" class="ref-link ref-type" title="Class AccessHolder">AccessHolder</a></td><td><span class="qldoc-summary"><p>A declaration that can potentially have more C++ access rights than its  enclosing element. This comprises <code>Class</code> (they have access to their own  private members) along with other <code>UserType</code>s and <code>Function</code> (they can be  the target of <code>friend</code> declarations).  For example <code>MyClass</code> and  <code>myFunction</code> in the following code:  ```  class MyClass  {  public:    &hellip;  };</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Specifier.qll/type.Specifier$AccessSpecifier.html" class="ref-link ref-type" title="Class AccessSpecifier">AccessSpecifier</a></td><td><span class="qldoc-summary"><p>A C++ access specifier: <code>public</code>, <code>protected</code>, or <code>private</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$AddExpr.html" class="ref-link ref-type" title="Class AddExpr">AddExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ add expression.  <code>c = a + b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$AdditionalControlFlowEdge.html" class="ref-link ref-type" title="Class AdditionalControlFlowEdge">AdditionalControlFlowEdge</a></td><td><span class="qldoc-summary"><p>An abstract class that can be extended to add additional edges to the  control-flow graph. Instances of this class correspond to the source nodes  of such edges, and the predicate <code>getAnEdgeTarget</code> should be overridden to  produce the target nodes of each source.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$AddressOfExpr.html" class="ref-link ref-type" title="Class AddressOfExpr">AddressOfExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ address-of expression.  <code>int *ptr = &amp;var;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Literal.qll/type.Literal$AggregateLiteral.html" class="ref-link ref-type" title="Class AggregateLiteral">AggregateLiteral</a></td><td><span class="qldoc-summary"><p>A C/C++ aggregate literal.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/Alias.qll/type.Alias$AliasFunction.html" class="ref-link ref-type" title="Class AliasFunction">AliasFunction</a></td><td><span class="qldoc-summary"><p>Models the aliasing behavior of a library function.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Specifier.qll/type.Specifier$AlignAs.html" class="ref-link ref-type" title="Class AlignAs">AlignAs</a></td><td><span class="qldoc-summary"><p>A C++11 <code>alignas</code> construct.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$AlignofExprOperator.html" class="ref-link ref-type" title="Class AlignofExprOperator">AlignofExprOperator</a></td><td><span class="qldoc-summary"><p>A C++11 <code>alignof</code> expression whose operand is an expression.  <code>int addrMask = ~(alignof(expr) - 1);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$AlignofOperator.html" class="ref-link ref-type" title="Class AlignofOperator">AlignofOperator</a></td><td><span class="qldoc-summary"><p>A C++11 <code>alignof</code> expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$AlignofTypeOperator.html" class="ref-link ref-type" title="Class AlignofTypeOperator">AlignofTypeOperator</a></td><td><span class="qldoc-summary"><p>A C++11 <code>alignof</code> expression whose operand is a type name.  <code>bool proper_alignment = (alingof(T) == alignof(T[0]);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/Allocation.qll/type.Allocation$AllocationExpr.html" class="ref-link ref-type" title="Class AllocationExpr">AllocationExpr</a></td><td><span class="qldoc-summary"><p>An allocation expression such as call to <code>malloc</code> or a <code>new</code> expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/Allocation.qll/type.Allocation$AllocationFunction.html" class="ref-link ref-type" title="Class AllocationFunction">AllocationFunction</a></td><td><span class="qldoc-summary"><p>An allocation function such as <code>malloc</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Nullness.qll/type.Nullness$AnalysedExpr.html" class="ref-link ref-type" title="Class AnalysedExpr">AnalysedExpr</a></td><td><span class="qldoc-summary"><p>An expression that has been extended with member predicates that provide  information about the role of this expression in nullness checks.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/StringAnalysis.qll/type.StringAnalysis$AnalysedString.html" class="ref-link ref-type" title="Class AnalysedString">AnalysedString</a></td><td><span class="qldoc-summary"><p>An analysed null terminated string.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$ArithmeticConversion.html" class="ref-link ref-type" title="Class ArithmeticConversion">ArithmeticConversion</a></td><td><span class="qldoc-summary"><p>A conversion from one arithmetic or <code>enum</code> type to another.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$ArithmeticType.html" class="ref-link ref-type" title="Class ArithmeticType">ArithmeticType</a></td><td><span class="qldoc-summary"><p>The C/C++ arithmetic types. See 4.1.1.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Literal.qll/type.Literal$ArrayAggregateLiteral.html" class="ref-link ref-type" title="Class ArrayAggregateLiteral">ArrayAggregateLiteral</a></td><td><span class="qldoc-summary"><p>A C/C++ aggregate literal that initializes an array  <code>S s[4] = { s_1, s_2, s_3, s_n };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Access.qll/type.Access$ArrayExpr.html" class="ref-link ref-type" title="Class ArrayExpr">ArrayExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ array access expression. For example, the access to <code>as</code> in  <code>myFunction</code> in the following code:  ```  int as[10];</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/ArrayFunction.qll/type.ArrayFunction$ArrayFunction.html" class="ref-link ref-type" title="Class ArrayFunction">ArrayFunction</a></td><td><span class="qldoc-summary"><p>A library function with input and/or output buffer parameters</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/ObjectiveC.qll/type.ObjectiveC$ArrayLiteral.html" class="ref-link ref-type" title="Class ArrayLiteral">ArrayLiteral</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C @[&hellip;] literal.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Literal.qll/type.Literal$ArrayOrVectorAggregateLiteral.html" class="ref-link ref-type" title="Class ArrayOrVectorAggregateLiteral">ArrayOrVectorAggregateLiteral</a></td><td><span class="qldoc-summary"><p>A C/C++ aggregate literal that initializes an array or a GNU vector type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$ArrayToPointerConversion.html" class="ref-link ref-type" title="Class ArrayToPointerConversion">ArrayToPointerConversion</a></td><td><span class="qldoc-summary"><p>A C/C++ array to pointer conversion.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$ArrayType.html" class="ref-link ref-type" title="Class ArrayType">ArrayType</a></td><td><span class="qldoc-summary"><p>A C/C++ array type. See 4.9.1.  <code>char table[32];</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$AsmStmt.html" class="ref-link ref-type" title="Class AsmStmt">AsmStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;asm&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignAddExpr.html" class="ref-link ref-type" title="Class AssignAddExpr">AssignAddExpr</a></td><td><span class="qldoc-summary"><p>A non-overloaded <code>+=</code> assignment expression on a non-pointer <em>lvalue</em>.  <code>a += b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignAndExpr.html" class="ref-link ref-type" title="Class AssignAndExpr">AssignAndExpr</a></td><td><span class="qldoc-summary"><p>A non-overloaded AND (<code>&amp;=</code>) assignment expression.  <code>a &amp;= b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignArithmeticOperation.html" class="ref-link ref-type" title="Class AssignArithmeticOperation">AssignArithmeticOperation</a></td><td><span class="qldoc-summary"><p>A non-overloaded arithmetic assignment operation on a non-pointer <em>lvalue</em>:  <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code> and <code>%=</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignBitwiseOperation.html" class="ref-link ref-type" title="Class AssignBitwiseOperation">AssignBitwiseOperation</a></td><td><span class="qldoc-summary"><p>A non-overloaded bitwise assignment operation:  <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, and <code>&gt;&gt;=</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignDivExpr.html" class="ref-link ref-type" title="Class AssignDivExpr">AssignDivExpr</a></td><td><span class="qldoc-summary"><p>A non-overloaded <code>/=</code> assignment expression.  <code>a /= b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignExpr.html" class="ref-link ref-type" title="Class AssignExpr">AssignExpr</a></td><td><span class="qldoc-summary"><p>A non-overloaded assignment operation with the operator <code>=</code>.  <code>a = b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignLShiftExpr.html" class="ref-link ref-type" title="Class AssignLShiftExpr">AssignLShiftExpr</a></td><td><span class="qldoc-summary"><p>A non-overloaded <code>&lt;&lt;=</code> assignment expression.  <code>a &lt;&lt;= b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignMulExpr.html" class="ref-link ref-type" title="Class AssignMulExpr">AssignMulExpr</a></td><td><span class="qldoc-summary"><p>A non-overloaded <code>*=</code> assignment expression.  <code>a *= b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignOperation.html" class="ref-link ref-type" title="Class AssignOperation">AssignOperation</a></td><td><span class="qldoc-summary"><p>A non-overloaded binary assignment operation other than <code>=</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignOrExpr.html" class="ref-link ref-type" title="Class AssignOrExpr">AssignOrExpr</a></td><td><span class="qldoc-summary"><p>A non-overloaded OR (<code>|=</code>) assignment expression.  <code>a |= b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignPointerAddExpr.html" class="ref-link ref-type" title="Class AssignPointerAddExpr">AssignPointerAddExpr</a></td><td><span class="qldoc-summary"><p>A non-overloaded <code>+=</code> pointer assignment expression.  <code>ptr += index;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignPointerSubExpr.html" class="ref-link ref-type" title="Class AssignPointerSubExpr">AssignPointerSubExpr</a></td><td><span class="qldoc-summary"><p>A non-overloaded <code>-=</code> pointer assignment expression.  <code>ptr -= index;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignRShiftExpr.html" class="ref-link ref-type" title="Class AssignRShiftExpr">AssignRShiftExpr</a></td><td><span class="qldoc-summary"><p>A non-overloaded <code>&gt;&gt;=</code> assignment expression.  <code>a &gt;&gt;= b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignRemExpr.html" class="ref-link ref-type" title="Class AssignRemExpr">AssignRemExpr</a></td><td><span class="qldoc-summary"><p>A non-overloaded <code>%=</code> assignment expression.  <code>a %= b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignSubExpr.html" class="ref-link ref-type" title="Class AssignSubExpr">AssignSubExpr</a></td><td><span class="qldoc-summary"><p>A non-overloaded <code>-=</code> assignment expression on a non-pointer <em>lvalue</em>.  <code>a -= b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignXorExpr.html" class="ref-link ref-type" title="Class AssignXorExpr">AssignXorExpr</a></td><td><span class="qldoc-summary"><p>A non-overloaded XOR (<code>^=</code>) assignment expression.  <code>a ^= b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$Assignment.html" class="ref-link ref-type" title="Class Assignment">Assignment</a></td><td><span class="qldoc-summary"><p>A non-overloaded binary assignment operation, including <code>=</code>, <code>+=</code>, <code>&amp;=</code>,  etc. A C++ overloaded assignment operation looks syntactically identical but is instead  a <code>FunctionCall</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$AssumeExpr.html" class="ref-link ref-type" title="Class AssumeExpr">AssumeExpr</a></td><td><span class="qldoc-summary"><p>A Microsoft C/C++ __assume expression.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/ObjectiveC.qll/type.ObjectiveC$AtEncodeExpr.html" class="ref-link ref-type" title="Class AtEncodeExpr">AtEncodeExpr</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C <code>@encode</code> expression, for example <code>@encode(int *)</code>.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/ObjectiveC.qll/type.ObjectiveC$AtExpr.html" class="ref-link ref-type" title="Class AtExpr">AtExpr</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C @ expression which boxes a single value, such as @(22).</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/ObjectiveC.qll/type.ObjectiveC$AtProtocolExpr.html" class="ref-link ref-type" title="Class AtProtocolExpr">AtProtocolExpr</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C <code>@protocol</code> expression, for example <code>@protocol(SomeProtocol)</code>.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/ObjectiveC.qll/type.ObjectiveC$AtSelectorExpr.html" class="ref-link ref-type" title="Class AtSelectorExpr">AtSelectorExpr</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C <code>@selector</code> expression, for example <code>@selector(driveForDistance:)</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Specifier.qll/type.Specifier$Attribute.html" class="ref-link ref-type" title="Class Attribute">Attribute</a></td><td><span class="qldoc-summary"><p>An attribute introduced by GNU&rsquo;s <code>__attribute__((name))</code> syntax,  Microsoft&rsquo;s <code>__declspec(name)</code> syntax, Microsoft&rsquo;s <code>[name]</code> syntax, the  C++11 standard <code>[[name]]</code> syntax, or the C++11 <code>alignas</code> syntax.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Specifier.qll/type.Specifier$AttributeArgument.html" class="ref-link ref-type" title="Class AttributeArgument">AttributeArgument</a></td><td><span class="qldoc-summary"><p>An argument to an <code>Attribute</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/Printf.qll/type.Printf$AttributeFormattingFunction.html" class="ref-link ref-type" title="Class AttributeFormattingFunction">AttributeFormattingFunction</a></td><td><span class="qldoc-summary"><p>A function that can be identified as a <code>printf</code> style formatting  function by its use of the GNU <code>format</code> attribute.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/ObjectiveC.qll/type.ObjectiveC$AutoReleasePoolStmt.html" class="ref-link ref-type" title="Class AutoReleasePoolStmt">AutoReleasePoolStmt</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C <code>@autoreleasepool</code> statement, for example  <code>@autoreleasepool { int x; int y; }</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$AutoType.html" class="ref-link ref-type" title="Class AutoType">AutoType</a></td><td><span class="qldoc-summary"><p>A type representing the use of the C++11 <code>auto</code> keyword.  <code>auto val = some_typed_expr();</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$BaseClassConversion.html" class="ref-link ref-type" title="Class BaseClassConversion">BaseClassConversion</a></td><td><span class="qldoc-summary"><p>A conversion from a pointer or <em>glvalue</em> of a derived class to a pointer or  <em>glvalue</em> of a direct or virtual base class.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/BasicBlocks.qll/type.BasicBlocks$BasicBlock.html" class="ref-link ref-type" title="Class BasicBlock">BasicBlock</a></td><td><span class="qldoc-summary"><p>A basic block in the C/C++ control-flow graph.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$BinaryArithmeticOperation.html" class="ref-link ref-type" title="Class BinaryArithmeticOperation">BinaryArithmeticOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ binary arithmetic operation.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BitwiseOperation.qll/type.BitwiseOperation$BinaryBitwiseOperation.html" class="ref-link ref-type" title="Class BinaryBitwiseOperation">BinaryBitwiseOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ binary bitwise operation.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$BinaryFloatingPointType.html" class="ref-link ref-type" title="Class BinaryFloatingPointType">BinaryFloatingPointType</a></td><td><span class="qldoc-summary"><p>A floating-point type whose representation is base 2.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/LogicalOperation.qll/type.LogicalOperation$BinaryLogicalOperation.html" class="ref-link ref-type" title="Class BinaryLogicalOperation">BinaryLogicalOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ binary logical operation.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$BinaryOperation.html" class="ref-link ref-type" title="Class BinaryOperation">BinaryOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ binary operation.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Field.qll/type.Field$BitField.html" class="ref-link ref-type" title="Class BitField">BitField</a></td><td><span class="qldoc-summary"><p>A C structure member or C++ member variable declared with an explicit size  in bits. For example the member variable <code>x</code> in the following code:  <code>struct MyStruct { int x : 3; };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BitwiseOperation.qll/type.BitwiseOperation$BitwiseAndExpr.html" class="ref-link ref-type" title="Class BitwiseAndExpr">BitwiseAndExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ bitwise AND expression.  <code>unsigned c = a &amp; b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BitwiseOperation.qll/type.BitwiseOperation$BitwiseOrExpr.html" class="ref-link ref-type" title="Class BitwiseOrExpr">BitwiseOrExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ bitwise OR expression.  <code>unsigned c = a | b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BitwiseOperation.qll/type.BitwiseOperation$BitwiseXorExpr.html" class="ref-link ref-type" title="Class BitwiseXorExpr">BitwiseXorExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ bitwise XOR expression.  <code>unsigned c = a ^ b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$BlockExpr.html" class="ref-link ref-type" title="Class BlockExpr">BlockExpr</a></td><td><span class="qldoc-summary"><p>A code block expression, for example:  <code>^ int (int x, int y) {return x + y;}</code>  Blocks are a language extension supported by Clang, and by Apple&rsquo;s  branch of GCC.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Block.qll/type.Block$BlockStmt.html" class="ref-link ref-type" title="Class BlockStmt">BlockStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ block statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$BlockType.html" class="ref-link ref-type" title="Class BlockType">BlockType</a></td><td><span class="qldoc-summary"><p>A block type, for example, <code>int(^)(char, float)</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$BoolConversion.html" class="ref-link ref-type" title="Class BoolConversion">BoolConversion</a></td><td><span class="qldoc-summary"><p>A conversion to <code>bool</code>. Returns <code>false</code> if the source value is zero,  <code>false</code>, or <code>nullptr</code>. Returns <code>true</code> otherwise.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$BoolType.html" class="ref-link ref-type" title="Class BoolType">BoolType</a></td><td><span class="qldoc-summary"><p>The C/C++ boolean type. See 4.2.  This is the C <code>_Bool</code> type  or the C++ <code>bool</code> type.  For example:  <code>extern bool a, b; // C++ _Bool c, d; // C</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$BreakStmt.html" class="ref-link ref-type" title="Class BreakStmt">BreakStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;break&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInChooseExpr.html" class="ref-link ref-type" title="Class BuiltInChooseExpr">BuiltInChooseExpr</a></td><td><span class="qldoc-summary"><p>The <code>__builtin_choose_expr</code> expression.  This is a GNU/Clang extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInComplexOperation.html" class="ref-link ref-type" title="Class BuiltInComplexOperation">BuiltInComplexOperation</a></td><td><span class="qldoc-summary"><p>The GNU <code>__builtin_complex</code> operation.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Function.qll/type.Function$BuiltInFunction.html" class="ref-link ref-type" title="Class BuiltInFunction">BuiltInFunction</a></td><td><span class="qldoc-summary"><p>A GCC built-in function. For example: <code>__builtin___memcpy_chk</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInIntAddr.html" class="ref-link ref-type" title="Class BuiltInIntAddr">BuiltInIntAddr</a></td><td><span class="qldoc-summary"><p>A C/C++ <code>__INTADDR__</code> built-in operation (used by some implementations  of <code>offsetof</code>).  The operation retains its semantics even in the presence  of an overloaded <code>operator &amp;</code>).  This is an EDG extension.  <code>struct S { int a, b; }; int d = __INTADDR__(struct S, b); // usually 4</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInNoOp.html" class="ref-link ref-type" title="Class BuiltInNoOp">BuiltInNoOp</a></td><td><span class="qldoc-summary"><p>A Microsoft C/C++ <code>__noop</code> expression, which does nothing.  <code>__noop;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperation.html" class="ref-link ref-type" title="Class BuiltInOperation">BuiltInOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ built-in operation. This is the root QL class encompassing  built-in functionality.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationBuiltInAddressOf.html" class="ref-link ref-type" title="Class BuiltInOperationBuiltInAddressOf">BuiltInOperationBuiltInAddressOf</a></td><td><span class="qldoc-summary"><p>A clang <code>__builtin_addressof</code> function (can be used to implement C++&rsquo;s  <code>std::addressof</code>).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationBuiltInConvertVector.html" class="ref-link ref-type" title="Class BuiltInOperationBuiltInConvertVector">BuiltInOperationBuiltInConvertVector</a></td><td><span class="qldoc-summary"><p>A clang <code>__builtin_convertvector</code> expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationBuiltInOffsetOf.html" class="ref-link ref-type" title="Class BuiltInOperationBuiltInOffsetOf">BuiltInOperationBuiltInOffsetOf</a></td><td><span class="qldoc-summary"><p>A C/C++ <code>__builtin_offsetof</code> built-in operation (used by some implementations  of <code>offsetof</code>).  The operation retains its semantics even in the presence  of an overloaded <code>operator &amp;</code>).  This is a GNU/Clang extension.  <code>struct S { int a, b; }; int d = __builtin_offsetof(struct S, b); // usually 4</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationBuiltInShuffleVector.html" class="ref-link ref-type" title="Class BuiltInOperationBuiltInShuffleVector">BuiltInOperationBuiltInShuffleVector</a></td><td><span class="qldoc-summary"><p>A clang <code>__builtin_shufflevector</code> expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationBuiltInTypesCompatibleP.html" class="ref-link ref-type" title="Class BuiltInOperationBuiltInTypesCompatibleP">BuiltInOperationBuiltInTypesCompatibleP</a></td><td><span class="qldoc-summary"><p>A C++ <code>__builtin_types_compatible_p</code> built-in operation (used by some  implementations of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationHasAssign.html" class="ref-link ref-type" title="Class BuiltInOperationHasAssign">BuiltInOperationHasAssign</a></td><td><span class="qldoc-summary"><p>A C++ <code>__has_assign</code> built-in operation (used by some implementations of  the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationHasCopy.html" class="ref-link ref-type" title="Class BuiltInOperationHasCopy">BuiltInOperationHasCopy</a></td><td><span class="qldoc-summary"><p>A C++ <code>__has_copy</code> built-in operation (used by some implementations of the  <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationHasFinalizer.html" class="ref-link ref-type" title="Class BuiltInOperationHasFinalizer">BuiltInOperationHasFinalizer</a></td><td><span class="qldoc-summary"><p>The <code>__has_finalizer</code> built-in operation.  This is a Microsoft extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationHasNoThrowAssign.html" class="ref-link ref-type" title="Class BuiltInOperationHasNoThrowAssign">BuiltInOperationHasNoThrowAssign</a></td><td><span class="qldoc-summary"><p>A C++ <code>__has_nothrow_assign</code> built-in operation (used by some  implementations of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationHasNoThrowConstructor.html" class="ref-link ref-type" title="Class BuiltInOperationHasNoThrowConstructor">BuiltInOperationHasNoThrowConstructor</a></td><td><span class="qldoc-summary"><p>A C++ <code>__has_nothrow_constructor</code> built-in operation (used by some  implementations of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationHasNoThrowCopy.html" class="ref-link ref-type" title="Class BuiltInOperationHasNoThrowCopy">BuiltInOperationHasNoThrowCopy</a></td><td><span class="qldoc-summary"><p>A C++ <code>__has_nothrow_copy</code> built-in operation (used by some implementations  of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationHasNothrowMoveAssign.html" class="ref-link ref-type" title="Class BuiltInOperationHasNothrowMoveAssign">BuiltInOperationHasNothrowMoveAssign</a></td><td><span class="qldoc-summary"><p>The <code>__has_nothrow_move_assign</code> built-in operation (used by some  implementations of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationHasTrivialAssign.html" class="ref-link ref-type" title="Class BuiltInOperationHasTrivialAssign">BuiltInOperationHasTrivialAssign</a></td><td><span class="qldoc-summary"><p>A C++ <code>__has_trivial_assign</code> built-in operation (used by some implementations  of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationHasTrivialConstructor.html" class="ref-link ref-type" title="Class BuiltInOperationHasTrivialConstructor">BuiltInOperationHasTrivialConstructor</a></td><td><span class="qldoc-summary"><p>A C++ <code>__has_trivial_constructor</code> built-in operation (used by some  implementations of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationHasTrivialCopy.html" class="ref-link ref-type" title="Class BuiltInOperationHasTrivialCopy">BuiltInOperationHasTrivialCopy</a></td><td><span class="qldoc-summary"><p>A C++ <code>__has_trivial_copy</code> built-in operation (used by some implementations  of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationHasTrivialDestructor.html" class="ref-link ref-type" title="Class BuiltInOperationHasTrivialDestructor">BuiltInOperationHasTrivialDestructor</a></td><td><span class="qldoc-summary"><p>A C++ <code>__has_trivial_destructor</code> built-in operation (used by some  implementations of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationHasTrivialMoveAssign.html" class="ref-link ref-type" title="Class BuiltInOperationHasTrivialMoveAssign">BuiltInOperationHasTrivialMoveAssign</a></td><td><span class="qldoc-summary"><p>The <code>__has_trivial_move_assign</code> built-in operation (used by some  implementations of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationHasTrivialMoveConstructor.html" class="ref-link ref-type" title="Class BuiltInOperationHasTrivialMoveConstructor">BuiltInOperationHasTrivialMoveConstructor</a></td><td><span class="qldoc-summary"><p>The <code>__has_trivial_move_constructor</code> built-in operation (used by some  implementations of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationHasUserDestructor.html" class="ref-link ref-type" title="Class BuiltInOperationHasUserDestructor">BuiltInOperationHasUserDestructor</a></td><td><span class="qldoc-summary"><p>A C++ <code>__has_user_destructor</code> built-in operation (used by some  implementations of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationHasVirtualDestructor.html" class="ref-link ref-type" title="Class BuiltInOperationHasVirtualDestructor">BuiltInOperationHasVirtualDestructor</a></td><td><span class="qldoc-summary"><p>A C++ <code>__has_virtual_destructor</code> built-in operation (used by some  implementations of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsAbstract.html" class="ref-link ref-type" title="Class BuiltInOperationIsAbstract">BuiltInOperationIsAbstract</a></td><td><span class="qldoc-summary"><p>A C++ <code>__is_abstract</code> built-in operation (used by some implementations of the  <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsBaseOf.html" class="ref-link ref-type" title="Class BuiltInOperationIsBaseOf">BuiltInOperationIsBaseOf</a></td><td><span class="qldoc-summary"><p>A C++ <code>__is_base_of</code> built-in operation (used by some implementations of the  <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsClass.html" class="ref-link ref-type" title="Class BuiltInOperationIsClass">BuiltInOperationIsClass</a></td><td><span class="qldoc-summary"><p>A C++ <code>__is_class</code> built-in operation (used by some implementations of the  <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsConstructible.html" class="ref-link ref-type" title="Class BuiltInOperationIsConstructible">BuiltInOperationIsConstructible</a></td><td><span class="qldoc-summary"><p>The <code>__is_constructible</code> built-in operation (used by some implementations  of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsConvertibleTo.html" class="ref-link ref-type" title="Class BuiltInOperationIsConvertibleTo">BuiltInOperationIsConvertibleTo</a></td><td><span class="qldoc-summary"><p>A C++ <code>__is_convertible_to</code> built-in operation (used by some implementations  of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsDelegate.html" class="ref-link ref-type" title="Class BuiltInOperationIsDelegate">BuiltInOperationIsDelegate</a></td><td><span class="qldoc-summary"><p>The <code>__is_delegate</code> built-in operation.  This is a Microsoft extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsDestructible.html" class="ref-link ref-type" title="Class BuiltInOperationIsDestructible">BuiltInOperationIsDestructible</a></td><td><span class="qldoc-summary"><p>The <code>__is_destructible</code> built-in operation (used by some implementations  of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsEmpty.html" class="ref-link ref-type" title="Class BuiltInOperationIsEmpty">BuiltInOperationIsEmpty</a></td><td><span class="qldoc-summary"><p>A C++ <code>__is_empty</code> built-in operation (used by some implementations of the  <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsEnum.html" class="ref-link ref-type" title="Class BuiltInOperationIsEnum">BuiltInOperationIsEnum</a></td><td><span class="qldoc-summary"><p>A C++ <code>__is_enum</code> built-in operation (used by some implementations of the  <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsFinal.html" class="ref-link ref-type" title="Class BuiltInOperationIsFinal">BuiltInOperationIsFinal</a></td><td><span class="qldoc-summary"><p>The <code>__is_final</code> built-in operation (used by some implementations of the  <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsInterfaceClass.html" class="ref-link ref-type" title="Class BuiltInOperationIsInterfaceClass">BuiltInOperationIsInterfaceClass</a></td><td><span class="qldoc-summary"><p>The <code>__is_interface_class</code> built-in operation.  This is a Microsoft extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsLiteralType.html" class="ref-link ref-type" title="Class BuiltInOperationIsLiteralType">BuiltInOperationIsLiteralType</a></td><td><span class="qldoc-summary"><p>The <code>__is_literal_type</code> built-in operation (used by some implementations of  the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsNothrowAssignable.html" class="ref-link ref-type" title="Class BuiltInOperationIsNothrowAssignable">BuiltInOperationIsNothrowAssignable</a></td><td><span class="qldoc-summary"><p>The <code>__is_nothrow_assignable</code> built-in operation (used by some  implementations of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsNothrowConstructible.html" class="ref-link ref-type" title="Class BuiltInOperationIsNothrowConstructible">BuiltInOperationIsNothrowConstructible</a></td><td><span class="qldoc-summary"><p>The <code>__is_nothrow_constructible</code> built-in operation (used by some  implementations of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsNothrowDestructible.html" class="ref-link ref-type" title="Class BuiltInOperationIsNothrowDestructible">BuiltInOperationIsNothrowDestructible</a></td><td><span class="qldoc-summary"><p>The <code>__is_nothrow_destructible</code> built-in operation (used by some  implementations of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsPod.html" class="ref-link ref-type" title="Class BuiltInOperationIsPod">BuiltInOperationIsPod</a></td><td><span class="qldoc-summary"><p>A C++ <code>__is_pod</code> built-in operation (used by some implementations of the  <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsPolymorphic.html" class="ref-link ref-type" title="Class BuiltInOperationIsPolymorphic">BuiltInOperationIsPolymorphic</a></td><td><span class="qldoc-summary"><p>A C++ <code>__is_polymorphic</code> built-in operation (used by some implementations  of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsRefArray.html" class="ref-link ref-type" title="Class BuiltInOperationIsRefArray">BuiltInOperationIsRefArray</a></td><td><span class="qldoc-summary"><p>The <code>__is_ref_array</code> built-in operation.  This is a Microsoft extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsRefClass.html" class="ref-link ref-type" title="Class BuiltInOperationIsRefClass">BuiltInOperationIsRefClass</a></td><td><span class="qldoc-summary"><p>The <code>__is_ref_class</code> built-in operation.  This is a Microsoft extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsSealed.html" class="ref-link ref-type" title="Class BuiltInOperationIsSealed">BuiltInOperationIsSealed</a></td><td><span class="qldoc-summary"><p>The <code>__is_sealed</code> built-in operation.  This is a Microsoft extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsSimpleValueClass.html" class="ref-link ref-type" title="Class BuiltInOperationIsSimpleValueClass">BuiltInOperationIsSimpleValueClass</a></td><td><span class="qldoc-summary"><p>The <code>__is_simple_value_class</code> built-in operation.  This is a Microsoft extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsStandardLayout.html" class="ref-link ref-type" title="Class BuiltInOperationIsStandardLayout">BuiltInOperationIsStandardLayout</a></td><td><span class="qldoc-summary"><p>The <code>__is_standard_layout</code> built-in operation (used by some implementations  of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsTriviallyAssignable.html" class="ref-link ref-type" title="Class BuiltInOperationIsTriviallyAssignable">BuiltInOperationIsTriviallyAssignable</a></td><td><span class="qldoc-summary"><p>The <code>__is_trivially_assignable</code> built-in operation (used by some  implementations of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsTriviallyConstructible.html" class="ref-link ref-type" title="Class BuiltInOperationIsTriviallyConstructible">BuiltInOperationIsTriviallyConstructible</a></td><td><span class="qldoc-summary"><p>The <code>__is_trivially_constructible</code> built-in operation (used by some  implementations of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsTriviallyCopyable.html" class="ref-link ref-type" title="Class BuiltInOperationIsTriviallyCopyable">BuiltInOperationIsTriviallyCopyable</a></td><td><span class="qldoc-summary"><p>The <code>__is_trivially_copyable</code> built-in operation (used by some  implementations of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsTriviallyDestructible.html" class="ref-link ref-type" title="Class BuiltInOperationIsTriviallyDestructible">BuiltInOperationIsTriviallyDestructible</a></td><td><span class="qldoc-summary"><p>The <code>__is_trivially_destructible</code> built-in operation (used by some  implementations of the <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsUnion.html" class="ref-link ref-type" title="Class BuiltInOperationIsUnion">BuiltInOperationIsUnion</a></td><td><span class="qldoc-summary"><p>A C++ <code>__is_union</code> built-in operation (used by some implementations of the  <code>&lt;type_traits&gt;</code> header).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationIsValueClass.html" class="ref-link ref-type" title="Class BuiltInOperationIsValueClass">BuiltInOperationIsValueClass</a></td><td><span class="qldoc-summary"><p>The <code>__is_value_class</code> built-in operation.  This is a Microsoft extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$BuiltInType.html" class="ref-link ref-type" title="Class BuiltInType">BuiltInType</a></td><td><span class="qldoc-summary"><p>A C/C++ built-in primitive type (int, float, void, and so on). See 4.1.1.  In the following example, <code>unsigned int</code> and <code>double</code> denote primitive  built-in types:  <code>double a; unsigned int ua[40]; typedef double LargeFloat;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInVarArg.html" class="ref-link ref-type" title="Class BuiltInVarArg">BuiltInVarArg</a></td><td><span class="qldoc-summary"><p>A C/C++ <code>__builtin_va_arg</code> built-in operation (used by some implementations  of <code>va_arg</code>).  <code>ap = __builtin_va_arg(ap, long);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInVarArgCopy.html" class="ref-link ref-type" title="Class BuiltInVarArgCopy">BuiltInVarArgCopy</a></td><td><span class="qldoc-summary"><p>A C/C++ <code>__builtin_va_copy</code> built-in operation (used by some implementations  of <code>va_copy</code>).  <code>va_list ap, aq; __builtin_va_start(ap, last_named_param); va_copy(aq, ap);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInVarArgsEnd.html" class="ref-link ref-type" title="Class BuiltInVarArgsEnd">BuiltInVarArgsEnd</a></td><td><span class="qldoc-summary"><p>A C/C++ <code>__builtin_va_end</code> built-in operation (used by some implementations  of <code>va_end</code>).  <code>__builtin_va_start(ap, last_named_param); ap = __builtin_va_arg(ap, long); __builtin_va_end(ap);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/CommonType.qll/type.CommonType$BuiltInVarArgsList.html" class="ref-link ref-type" title="Class BuiltInVarArgsList">BuiltInVarArgsList</a></td><td><span class="qldoc-summary"><p>The <code>__builtin_va_list</code> type, used to provide variadic functionality.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInVarArgsStart.html" class="ref-link ref-type" title="Class BuiltInVarArgsStart">BuiltInVarArgsStart</a></td><td><span class="qldoc-summary"><p>A C/C++ <code>__builtin_va_start</code> built-in operation (used by some  implementations of <code>va_start</code>).  <code>__builtin_va_list ap; __builtin_va_start(ap, last_named_param);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/File.qll/type.File$CFile.html" class="ref-link ref-type" title="Class CFile">CFile</a></td><td><span class="qldoc-summary"><p>A C source file, as determined by file extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$CStyleCast.html" class="ref-link ref-type" title="Class CStyleCast">CStyleCast</a></td><td><span class="qldoc-summary"><p>A cast expression in C, or a C-style cast expression in C++.  <code>float f = 3.0f; int i = (int)f;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Comments.qll/type.Comments$CStyleComment.html" class="ref-link ref-type" title="Class CStyleComment">CStyleComment</a></td><td><span class="qldoc-summary"><p>A C style comment (one which starts with <code>/*</code>).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/TypedefType.qll/type.TypedefType$CTypedefType.html" class="ref-link ref-type" title="Class CTypedefType">CTypedefType</a></td><td><span class="qldoc-summary"><p>A traditional C/C++ typedef type. See 4.9.1.  For example the type declared in the following code:  <code>typedef int my_int;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$Call.html" class="ref-link ref-type" title="Class Call">Call</a></td><td><span class="qldoc-summary"><p>A C/C++ call.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$Cast.html" class="ref-link ref-type" title="Class Cast">Cast</a></td><td><span class="qldoc-summary"><p>A C/C++ cast expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$CatchAnyBlock.html" class="ref-link ref-type" title="Class CatchAnyBlock">CatchAnyBlock</a></td><td><span class="qldoc-summary"><p>A C++ &lsquo;catch-any block&rsquo;, for example the third block in the following code:  <code>try { f(); } catch(std::exception &amp;e) { g(); } catch(...) { h(); }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$CatchBlock.html" class="ref-link ref-type" title="Class CatchBlock">CatchBlock</a></td><td><span class="qldoc-summary"><p>A &lsquo;catch block&rsquo;, for example the second and third blocks in the following  code:  <code>try { f(); } catch(std::exception &amp;e) { g(); } catch(...) { h(); }</code></p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/ObjectiveC.qll/type.ObjectiveC$Category.html" class="ref-link ref-type" title="Class Category">Category</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C category or class extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$Char16Type.html" class="ref-link ref-type" title="Class Char16Type">Char16Type</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>char16_t</code> type.  This is available starting with C11 and C++11.  <code>char16_t c16;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$Char32Type.html" class="ref-link ref-type" title="Class Char32Type">Char32Type</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>char32_t</code> type.  This is available starting with C11 and C++11.  <code>char32_t c32;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$Char8Type.html" class="ref-link ref-type" title="Class Char8Type">Char8Type</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>char8_t</code> type.  This is available starting with C++20.  <code>char8_t c8;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Literal.qll/type.Literal$CharLiteral.html" class="ref-link ref-type" title="Class CharLiteral">CharLiteral</a></td><td><span class="qldoc-summary"><p>A character literal.  For example:  <code>char c1 = 'a'; wchar_t c2 = L'b';</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/CommonType.qll/type.CommonType$CharPointerType.html" class="ref-link ref-type" title="Class CharPointerType">CharPointerType</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>char*</code> type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$CharType.html" class="ref-link ref-type" title="Class CharType">CharType</a></td><td><span class="qldoc-summary"><p>The C/C++ character types. See 4.3.  This includes the <code>char</code>,  <code>signed char</code> and <code>unsigned char</code> types, all of which are  distinct from one another.  For example:  <code>char a, b; signed char c, d; unsigned char e, f;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Class.qll/type.Class$Class.html" class="ref-link ref-type" title="Class Class">Class</a></td><td><span class="qldoc-summary"><p>A class type [N4140 9].</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Literal.qll/type.Literal$ClassAggregateLiteral.html" class="ref-link ref-type" title="Class ClassAggregateLiteral">ClassAggregateLiteral</a></td><td><span class="qldoc-summary"><p>A C/C++ aggregate literal that initializes a <code>class</code>, <code>struct</code>, or <code>union</code>.  For example:  <code>S s = { arg1, arg2, { arg3, arg4 }, arg5 };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Class.qll/type.Class$ClassDerivation.html" class="ref-link ref-type" title="Class ClassDerivation">ClassDerivation</a></td><td><span class="qldoc-summary"><p>A class derivation, for example the <code>public B</code> in the following code:  <code>class D : public B { ... };</code></p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/ObjectiveC.qll/type.ObjectiveC$ClassExtension.html" class="ref-link ref-type" title="Class ClassExtension">ClassExtension</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C class extension.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/ObjectiveC.qll/type.ObjectiveC$ClassMessageExpr.html" class="ref-link ref-type" title="Class ClassMessageExpr">ClassMessageExpr</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C message expression whose receiver is the name of a class, and  is therefore calling a class method rather than an instance method. This occurs  most commonly for the &ldquo;+alloc&rdquo;, &ldquo;+new&rdquo;, and &ldquo;+class&rdquo; selectors.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Class.qll/type.Class$ClassTemplateInstantiation.html" class="ref-link ref-type" title="Class ClassTemplateInstantiation">ClassTemplateInstantiation</a></td><td><span class="qldoc-summary"><p>A class that is an instantiation of a template.  For example in the following  code there is a <code>MyTemplateClass&lt;int&gt;</code> instantiation:  ```  template<class T>  class MyTemplateClass {    &hellip;  };</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Class.qll/type.Class$ClassTemplateSpecialization.html" class="ref-link ref-type" title="Class ClassTemplateSpecialization">ClassTemplateSpecialization</a></td><td><span class="qldoc-summary"><p>A specialization of a class template (this may be a full or partial template  specialization - see <code>FullClassTemplateSpecialization</code> and  <code>PartialClassTemplateSpecialization</code>).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Lambda.qll/type.Lambda$Closure.html" class="ref-link ref-type" title="Class Closure">Closure</a></td><td><span class="qldoc-summary"><p>A class written by the compiler to be the type of a C++11 lambda expression.  For example the variable <code>a</code> in the following code has a closure type:  <code>auto a = [x, y](int z) -&gt; int { return x + y + z; };</code></p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/ObjectiveC.qll/type.ObjectiveC$CmdExpr.html" class="ref-link ref-type" title="Class CmdExpr">CmdExpr</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C _cmd expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$CoAwaitExpr.html" class="ref-link ref-type" title="Class CoAwaitExpr">CoAwaitExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ <code>co_await</code> expression.  <code>co_await foo();</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$CoReturnStmt.html" class="ref-link ref-type" title="Class CoReturnStmt">CoReturnStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ <code>co_return</code> statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$CoYieldExpr.html" class="ref-link ref-type" title="Class CoYieldExpr">CoYieldExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ <code>co_yield</code> expression.  <code>co_yield 1;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$CommaExpr.html" class="ref-link ref-type" title="Class CommaExpr">CommaExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ comma expression.  <code>int c = compute1(), compute2(), resulting_value;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Comments.qll/type.Comments$Comment.html" class="ref-link ref-type" title="Class Comment">Comment</a></td><td><span class="qldoc-summary"><p>A C/C++ comment. For example the comment in the following code:  <code>// C++ style single-line comment</code>  or a C style comment (which starts with <code>/*</code>).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ComparisonOperation.qll/type.ComparisonOperation$ComparisonOperation.html" class="ref-link ref-type" title="Class ComparisonOperation">ComparisonOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ comparison operation, that is, either an equality operation or a relational operation.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Compilation.qll/type.Compilation$Compilation.html" class="ref-link ref-type" title="Class Compilation">Compilation</a></td><td><span class="qldoc-summary"><p>An invocation of the compiler. Note that more than one file may be  compiled per invocation. For example, this command compiles three  source files:</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Diagnostics.qll/type.Diagnostics$CompilerCatastrophe.html" class="ref-link ref-type" title="Class CompilerCatastrophe">CompilerCatastrophe</a></td><td><span class="qldoc-summary"><p>A compiler error that prevents compilation from continuing.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Diagnostics.qll/type.Diagnostics$CompilerDiscretionaryError.html" class="ref-link ref-type" title="Class CompilerDiscretionaryError">CompilerDiscretionaryError</a></td><td><span class="qldoc-summary"><p>A compiler-generated discretionary error (a compile-time error that may  be suppressed).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Diagnostics.qll/type.Diagnostics$CompilerError.html" class="ref-link ref-type" title="Class CompilerError">CompilerError</a></td><td><span class="qldoc-summary"><p>A compiler error message.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Diagnostics.qll/type.Diagnostics$CompilerRemark.html" class="ref-link ref-type" title="Class CompilerRemark">CompilerRemark</a></td><td><span class="qldoc-summary"><p>A compiler-generated remark (milder than a warning).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Diagnostics.qll/type.Diagnostics$CompilerWarning.html" class="ref-link ref-type" title="Class CompilerWarning">CompilerWarning</a></td><td><span class="qldoc-summary"><p>A compiler-generated warning.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BitwiseOperation.qll/type.BitwiseOperation$ComplementExpr.html" class="ref-link ref-type" title="Class ComplementExpr">ComplementExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ complement expression.  <code>unsigned c = ~a;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$ComplexDomain.html" class="ref-link ref-type" title="Class ComplexDomain">ComplexDomain</a></td><td><span class="qldoc-summary"><p>The type domain of a floating-point type that represents a complex number.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$ComplexNumberType.html" class="ref-link ref-type" title="Class ComplexNumberType">ComplexNumberType</a></td><td><span class="qldoc-summary"><p>A floating-point type representing a complex number.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$ComputedGotoStmt.html" class="ref-link ref-type" title="Class ComputedGotoStmt">ComputedGotoStmt</a></td><td><span class="qldoc-summary"><p>A &lsquo;goto&rsquo; statement whose target is computed by a non-constant  expression (a non-standard extension to C/C++).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Assignment.qll/type.Assignment$ConditionDeclExpr.html" class="ref-link ref-type" title="Class ConditionDeclExpr">ConditionDeclExpr</a></td><td><span class="qldoc-summary"><p>A C++ variable declaration inside the conditional expression of a <code>while</code>, <code>if</code> or  <code>for</code> compound statement.  Declaring a variable this way narrows its lifetime and  scope to be strictly the compound statement itself.  For example:  <code>extern int x, y; if (bool c = x &lt; y) { do_something_with(c); } // c is no longer in scope while (int d = x - y) { do_something_else_with(d); } // d is no longer is scope</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/LogicalOperation.qll/type.LogicalOperation$ConditionalExpr.html" class="ref-link ref-type" title="Class ConditionalExpr">ConditionalExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ conditional ternary expression.  <code>a = (b &gt; c ? d : e);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$ConditionalStmt.html" class="ref-link ref-type" title="Class ConditionalStmt">ConditionalStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ conditional statement, that is, either an &lsquo;if&rsquo; statement or a  &lsquo;switch&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$ConjugationExpr.html" class="ref-link ref-type" title="Class ConjugationExpr">ConjugationExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ GNU conjugation expression.  It operates on <code>_Complex</code> or  <code>__complex__</code>numbers, and is similar to the C99 <code>conj</code>, <code>conjf</code> and <code>conjl</code>  functions.  <code>_Complex double a = ( 1.0, 2.0 ); _Complex double b = ~ a; // ( 1.0, - 2.0 )</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$ConstCast.html" class="ref-link ref-type" title="Class ConstCast">ConstCast</a></td><td><span class="qldoc-summary"><p>A C++ <code>const_cast</code> expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/MemberFunction.qll/type.MemberFunction$ConstMemberFunction.html" class="ref-link ref-type" title="Class ConstMemberFunction">ConstMemberFunction</a></td><td><span class="qldoc-summary"><p>A const C++ member function [N4140 9.3.1/4]. A const function has the  <code>const</code> specifier and does not modify the state of its class. For example  the member function <code>day</code> in the following code:  ```  class MyClass {    &hellip;</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$ConstexprIfStmt.html" class="ref-link ref-type" title="Class ConstexprIfStmt">ConstexprIfStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;constexpr if&rsquo; statement. For example, the <code>if constexpr</code> statement  in the following code:  <code>if constexpr (x) { ... }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/MemberFunction.qll/type.MemberFunction$Constructor.html" class="ref-link ref-type" title="Class Constructor">Constructor</a></td><td><span class="qldoc-summary"><p>A C++ constructor [N4140 12.1]. For example the function <code>MyClass</code> in the  following code is a constructor:  <code>class MyClass { public: MyClass() { ... } };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$ConstructorBaseInit.html" class="ref-link ref-type" title="Class ConstructorBaseInit">ConstructorBaseInit</a></td><td><span class="qldoc-summary"><p>A call to a constructor of a base class as part of a constructor&rsquo;s  initializer list or compiler-generated actions.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$ConstructorCall.html" class="ref-link ref-type" title="Class ConstructorCall">ConstructorCall</a></td><td><span class="qldoc-summary"><p>A call to a constructor.  <code>struct S { S(void) {} }; S s;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$ConstructorDelegationInit.html" class="ref-link ref-type" title="Class ConstructorDelegationInit">ConstructorDelegationInit</a></td><td><span class="qldoc-summary"><p>A call to a constructor of the same class as part of a constructor&rsquo;s  initializer list, which delegates object construction (C++11 only).  <code>struct S { int a; S(int b): a(b) { } S(): S(0) { } // delegation to another constructor };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$ConstructorDirectInit.html" class="ref-link ref-type" title="Class ConstructorDirectInit">ConstructorDirectInit</a></td><td><span class="qldoc-summary"><p>A call to a constructor of a direct non-virtual base class as part of a  constructor&rsquo;s initializer list or compiler-generated actions.  <code>struct S { int a; S(int b): a(b) {} }; struct T: S { T(): S(33) {} // S(33) is a constructor call };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$ConstructorFieldInit.html" class="ref-link ref-type" title="Class ConstructorFieldInit">ConstructorFieldInit</a></td><td><span class="qldoc-summary"><p>An initialization of a member variable performed as part of a  constructor&rsquo;s explicit initializer list or implicit actions.  In the example below, member variable <code>b</code> is being initialized by  constructor parameter <code>a</code>:  <code>struct S { int b; S(int a): b(a) {} } s(2);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$ConstructorInit.html" class="ref-link ref-type" title="Class ConstructorInit">ConstructorInit</a></td><td><span class="qldoc-summary"><p>An initialization of a base class or member variable performed as part  of a constructor&rsquo;s explicit initializer list or implicit actions.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$ConstructorVirtualInit.html" class="ref-link ref-type" title="Class ConstructorVirtualInit">ConstructorVirtualInit</a></td><td><span class="qldoc-summary"><p>A call to a constructor of a virtual base class as part of a  constructor&rsquo;s initializer list or compiler-generated actions.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/File.qll/type.File$Container.html" class="ref-link ref-type" title="Class Container">Container</a></td><td><span class="qldoc-summary"><p>A file or folder.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$ContinueStmt.html" class="ref-link ref-type" title="Class ContinueStmt">ContinueStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;continue&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNode.html" class="ref-link ref-type" title="Class ControlFlowNode">ControlFlowNode</a></td><td><span class="qldoc-summary"><p>A control-flow node is either a statement or an expression; in addition,  functions are control-flow nodes representing the exit point of the  function. The graph represents one possible evaluation order out of all the  ones the compiler might have picked.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNodeBase.html" class="ref-link ref-type" title="Class ControlFlowNodeBase">ControlFlowNodeBase</a></td><td><span class="qldoc-summary"><p>An element that is convertible to <code>ControlFlowNode</code>. This class is similar  to <code>ControlFlowNode</code> except that is has no member predicates apart from  <code>toString</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$ControlStructure.html" class="ref-link ref-type" title="Class ControlStructure">ControlStructure</a></td><td><span class="qldoc-summary"><p>A C/C++ control structure, that is, either a conditional statement or  a loop.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$Conversion.html" class="ref-link ref-type" title="Class Conversion">Conversion</a></td><td><span class="qldoc-summary"><p>A C/C++ cast expression or similar unary expression that doesn&rsquo;t affect the logical value of its operand.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/MemberFunction.qll/type.MemberFunction$ConversionConstructor.html" class="ref-link ref-type" title="Class ConversionConstructor">ConversionConstructor</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: as of C++11 this class does not correspond perfectly with the  language definition of a converting constructor.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/MemberFunction.qll/type.MemberFunction$ConversionOperator.html" class="ref-link ref-type" title="Class ConversionOperator">ConversionOperator</a></td><td><span class="qldoc-summary"><p>A C++ conversion operator [N4140 12.3.2]. For example the function  <code>operator int</code> in the following code is a <code>ConversionOperator</code>:  <code>class MyClass { public: operator int(); };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/MemberFunction.qll/type.MemberFunction$CopyAssignmentOperator.html" class="ref-link ref-type" title="Class CopyAssignmentOperator">CopyAssignmentOperator</a></td><td><span class="qldoc-summary"><p>A C++ copy assignment operator [N4140 12.8]. For example the function  <code>operator=</code> in the following code is a <code>CopyAssignmentOperator</code>:  <code>class MyClass { public: MyClass &amp;operator=(const MyClass &amp;other); };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/MemberFunction.qll/type.MemberFunction$CopyConstructor.html" class="ref-link ref-type" title="Class CopyConstructor">CopyConstructor</a></td><td><span class="qldoc-summary"><p>A C++ copy constructor [N4140 12.8]. For example the function <code>MyClass</code> in  the following code is a <code>CopyConstructor</code>:  <code>class MyClass { public: MyClass(const MyClass &amp;from) { ... } };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/File.qll/type.File$CppFile.html" class="ref-link ref-type" title="Class CppFile">CppFile</a></td><td><span class="qldoc-summary"><p>A C++ source file, as determined by file extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Comments.qll/type.Comments$CppStyleComment.html" class="ref-link ref-type" title="Class CppStyleComment">CppStyleComment</a></td><td><span class="qldoc-summary"><p>A CPP style comment. For example the comment in the following code:  <code>// C++ style single-line comment</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$CrementOperation.html" class="ref-link ref-type" title="Class CrementOperation">CrementOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ <code>++</code> or <code>--</code> expression (either prefix or postfix).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dataflow.qll/type.Dataflow$DataflowAnnotation.html" class="ref-link ref-type" title="Class DataflowAnnotation">DataflowAnnotation</a></td><td><span class="qldoc-summary"><p>INTERNAL: Do not use.  A string that identifies a data flow analysis along with a set of member  predicates that implement this analysis.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/Deallocation.qll/type.Deallocation$DeallocationExpr.html" class="ref-link ref-type" title="Class DeallocationExpr">DeallocationExpr</a></td><td><span class="qldoc-summary"><p>An deallocation expression such as call to <code>free</code> or a <code>delete</code> expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/Deallocation.qll/type.Deallocation$DeallocationFunction.html" class="ref-link ref-type" title="Class DeallocationFunction">DeallocationFunction</a></td><td><span class="qldoc-summary"><p>A deallocation function such as <code>free</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$Decimal128Type.html" class="ref-link ref-type" title="Class Decimal128Type">Decimal128Type</a></td><td><span class="qldoc-summary"><p>The GNU C <code>_Decimal128</code> primitive type.  This is not standard C/C++.  <code>_Decimal128 d128;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$Decimal32Type.html" class="ref-link ref-type" title="Class Decimal32Type">Decimal32Type</a></td><td><span class="qldoc-summary"><p>The GNU C <code>_Decimal32</code> primitive type.  This is not standard C/C++.  <code>_Decimal32 d32;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$Decimal64Type.html" class="ref-link ref-type" title="Class Decimal64Type">Decimal64Type</a></td><td><span class="qldoc-summary"><p>The GNU C <code>_Decimal64</code> primitive type.  This is not standard C/C++.  <code>_Decimal64 d64;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$DecimalFloatingPointType.html" class="ref-link ref-type" title="Class DecimalFloatingPointType">DecimalFloatingPointType</a></td><td><span class="qldoc-summary"><p>A floating-point type whose representation is base 10.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$DeclStmt.html" class="ref-link ref-type" title="Class DeclStmt">DeclStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;declaration&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></td><td><span class="qldoc-summary"><p>A C/C++ declaration: for example, a variable declaration, a type  declaration, or a function declaration.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Declaration.qll/type.Declaration$DeclarationEntry.html" class="ref-link ref-type" title="Class DeclarationEntry">DeclarationEntry</a></td><td><span class="qldoc-summary"><p>A C/C++ declaration entry. For example the following code contains five  declaration entries:  <code>extern int myGlobal; int myVariable; typedef char MyChar; void myFunction(); void myFunction() { // ... }</code>  See the comment above <code>Declaration</code> for an explanation of the relationship  between <code>Declaration</code> and <code>DeclarationEntry</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Specifier.qll/type.Specifier$Declspec.html" class="ref-link ref-type" title="Class Declspec">Declspec</a></td><td><span class="qldoc-summary"><p>An attribute introduced by Microsoft&rsquo;s <code>__declspec(name)</code> syntax, for  example: <code>__declspec(dllimport)</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$Decltype.html" class="ref-link ref-type" title="Class Decltype">Decltype</a></td><td><span class="qldoc-summary"><p>An instance of the C++11 <code>decltype</code> operator.  For example:  <code>int a; decltype(a) b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$DecrementOperation.html" class="ref-link ref-type" title="Class DecrementOperation">DecrementOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ <code>--</code> expression (either prefix or postfix).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/DefinitionsAndUses.qll/type.DefinitionsAndUses$Def.html" class="ref-link ref-type" title="Class Def">Def</a></td><td><span class="qldoc-summary"><p>A definition of a stack variable.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/DefinitionsAndUses.qll/type.DefinitionsAndUses$DefOrUse.html" class="ref-link ref-type" title="Class DefOrUse">DefOrUse</a></td><td><span class="qldoc-summary"><p>Utility class: A definition or use of a stack variable.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$DefaultCase.html" class="ref-link ref-type" title="Class DefaultCase">DefaultCase</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;default case&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/Synchronization.qll/type.Synchronization$DefaultMutexType.html" class="ref-link ref-type" title="Class DefaultMutexType">DefaultMutexType</a></td><td><span class="qldoc-summary"><p>A class or struct type that has both a lock and an unlock function  candidate, and is therefore a mutex.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$DeleteArrayExpr.html" class="ref-link ref-type" title="Class DeleteArrayExpr">DeleteArrayExpr</a></td><td><span class="qldoc-summary"><p>A C++ <code>delete[]</code> (array) expression.  <code>delete[] arr;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$DeleteExpr.html" class="ref-link ref-type" title="Class DeleteExpr">DeleteExpr</a></td><td><span class="qldoc-summary"><p>A C++ <code>delete</code> (non-array) expression.  <code>delete ptr;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$DerivedClassConversion.html" class="ref-link ref-type" title="Class DerivedClassConversion">DerivedClassConversion</a></td><td><span class="qldoc-summary"><p>A conversion from a pointer or <em>glvalue</em> to a base class to a pointer or <em>glvalue</em>  to a direct derived class.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$DerivedType.html" class="ref-link ref-type" title="Class DerivedType">DerivedType</a></td><td><span class="qldoc-summary"><p>A C/C++ derived type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/MemberFunction.qll/type.MemberFunction$Destructor.html" class="ref-link ref-type" title="Class Destructor">Destructor</a></td><td><span class="qldoc-summary"><p>A C++ destructor [N4140 12.4]. For example the function <code>~MyClass</code> in the  following code is a destructor:  <code>class MyClass { public: ~MyClass() { ... } };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$DestructorBaseDestruction.html" class="ref-link ref-type" title="Class DestructorBaseDestruction">DestructorBaseDestruction</a></td><td><span class="qldoc-summary"><p>A call to a destructor of a base class as part of a destructor&rsquo;s  compiler-generated actions.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$DestructorCall.html" class="ref-link ref-type" title="Class DestructorCall">DestructorCall</a></td><td><span class="qldoc-summary"><p>A call to a destructor.  <code>struct S { ~S(void) {} } *s; s-&gt;~S();</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$DestructorDestruction.html" class="ref-link ref-type" title="Class DestructorDestruction">DestructorDestruction</a></td><td><span class="qldoc-summary"><p>A call to a destructor of a base class or field as part of a destructor&rsquo;s  compiler-generated actions.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$DestructorDirectDestruction.html" class="ref-link ref-type" title="Class DestructorDirectDestruction">DestructorDirectDestruction</a></td><td><span class="qldoc-summary"><p>A call to a destructor of a direct non-virtual base class as part of a  destructor&rsquo;s compiler-generated actions.  <code>struct S { ~S(void) {} }; struct T: S { ~T(void) {} // will call ~S() };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$DestructorFieldDestruction.html" class="ref-link ref-type" title="Class DestructorFieldDestruction">DestructorFieldDestruction</a></td><td><span class="qldoc-summary"><p>A destruction of a member variable performed as part of a  destructor&rsquo;s compiler-generated actions.  <code>struct S { ~S(void) {} }; struct T { S s; ~T(void) {} // will call s.~S() };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$DestructorVirtualDestruction.html" class="ref-link ref-type" title="Class DestructorVirtualDestruction">DestructorVirtualDestruction</a></td><td><span class="qldoc-summary"><p>A call to a destructor of a direct virtual base class as part of a  destructor&rsquo;s compiler-generated actions.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Diagnostics.qll/type.Diagnostics$Diagnostic.html" class="ref-link ref-type" title="Class Diagnostic">Diagnostic</a></td><td><span class="qldoc-summary"><p>A compiler-generated error, warning or remark.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/ObjectiveC.qll/type.ObjectiveC$DictionaryLiteral.html" class="ref-link ref-type" title="Class DictionaryLiteral">DictionaryLiteral</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C @{&hellip;} literal.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$DivExpr.html" class="ref-link ref-type" title="Class DivExpr">DivExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ divide expression.  <code>c = a / b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$DoStmt.html" class="ref-link ref-type" title="Class DoStmt">DoStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;do&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Access.qll/type.Access$DotFieldAccess.html" class="ref-link ref-type" title="Class DotFieldAccess">DotFieldAccess</a></td><td><span class="qldoc-summary"><p>A field access of the form <code>obj.field</code>. The type of <code>obj</code> is either a  class/struct/union or a reference to one. <code>DotFieldAccess</code> has two  sub-classes, <code>ValueFieldAccess</code> and <code>ReferenceFieldAccess</code>, to  distinguish whether or not the type of <code>obj</code> is a reference type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$DoubleType.html" class="ref-link ref-type" title="Class DoubleType">DoubleType</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>double</code> type.  <code>double d;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$DynamicCast.html" class="ref-link ref-type" title="Class DynamicCast">DynamicCast</a></td><td><span class="qldoc-summary"><p>A C++ <code>dynamic_cast</code> expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ComparisonOperation.qll/type.ComparisonOperation$EQExpr.html" class="ref-link ref-type" title="Class EQExpr">EQExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ equal expression.  <code>bool c = (a == b);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></td><td><span class="qldoc-summary"><p>A C/C++ element. This class is the base class for all C/C++  elements, such as functions, classes, expressions, and so on.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Element.qll/type.Element$ElementBase.html" class="ref-link ref-type" title="Class ElementBase">ElementBase</a></td><td><span class="qldoc-summary"><p>A C/C++ element with no member predicates other than <code>toString</code>. Not for  general use. This class does not define a location, so classes wanting to  change their location without affecting other classes can extend  <code>ElementBase</code> instead of <code>Element</code> to create a new rootdef for <code>getURL</code>,  <code>getLocation</code>, or <code>hasLocationInfo</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$EmptyStmt.html" class="ref-link ref-type" title="Class EmptyStmt">EmptyStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;empty&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/BasicBlocks.qll/type.BasicBlocks$EntryBasicBlock.html" class="ref-link ref-type" title="Class EntryBasicBlock">EntryBasicBlock</a></td><td><span class="qldoc-summary"><p>An entry point of a function.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Enum.qll/type.Enum$Enum.html" class="ref-link ref-type" title="Class Enum">Enum</a></td><td><span class="qldoc-summary"><p>A C/C++ enum [N4140 7.2]. For example, the types <code>MyEnum</code> and  <code>MyScopedEnum</code> in:  ```  enum MyEnum {    MyEnumConstant  };</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Enum.qll/type.Enum$EnumConstant.html" class="ref-link ref-type" title="Class EnumConstant">EnumConstant</a></td><td><span class="qldoc-summary"><p>A C/C++ enumerator [N4140 7.2], also known as an enumeration constant.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Access.qll/type.Access$EnumConstantAccess.html" class="ref-link ref-type" title="Class EnumConstantAccess">EnumConstantAccess</a></td><td><span class="qldoc-summary"><p>A C/C++ <code>enum</code> constant access expression. For example the access to  <code>MYENUMCONST1</code> in <code>myFunction</code> in the following code:  ```  enum MyEnum {    MYENUMCONST1,    MYENUMCONST2  };</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$EnumSwitch.html" class="ref-link ref-type" title="Class EnumSwitch">EnumSwitch</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;switch&rsquo; statement where the controlling expression has an  enum type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ComparisonOperation.qll/type.ComparisonOperation$EqualityOperation.html" class="ref-link ref-type" title="Class EqualityOperation">EqualityOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ equality operation, that is, either &ldquo;==&rdquo; or &ldquo;!=&rdquo;.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$ErroneousType.html" class="ref-link ref-type" title="Class ErroneousType">ErroneousType</a></td><td><span class="qldoc-summary"><p>An erroneous type.  This type has no corresponding C/C++ syntax.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$ErrorExpr.html" class="ref-link ref-type" title="Class ErrorExpr">ErrorExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ expression that has not been resolved.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/BasicBlocks.qll/type.BasicBlocks$ExitBasicBlock.html" class="ref-link ref-type" title="Class ExitBasicBlock">ExitBasicBlock</a></td><td><span class="qldoc-summary"><p>A basic block whose last node is the exit point of a function.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></td><td><span class="qldoc-summary"><p>A C/C++ expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$ExprCall.html" class="ref-link ref-type" title="Class ExprCall">ExprCall</a></td><td><span class="qldoc-summary"><p>A C/C++ call which is performed through a function pointer.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/VoidContext.qll/type.VoidContext$ExprInVoidContext.html" class="ref-link ref-type" title="Class ExprInVoidContext">ExprInVoidContext</a></td><td><span class="qldoc-summary"><p>An expression that occurs in a void context, i.e. either as the toplevel expression of  an expression statement or on the left hand side of the comma operator.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/ObjectiveC.qll/type.ObjectiveC$ExprMessageExpr.html" class="ref-link ref-type" title="Class ExprMessageExpr">ExprMessageExpr</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C message expression whose receiver is an expression (which includes the  common case of the receiver being &ldquo;self&rdquo;).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$ExprStmt.html" class="ref-link ref-type" title="Class ExprStmt">ExprStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;expression&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Field.qll/type.Field$Field.html" class="ref-link ref-type" title="Class Field">Field</a></td><td><span class="qldoc-summary"><p>A C structure member or C++ non-static member variable. For example the  member variable <code>m</code> in the following code (but not <code>s</code>):  <code>class MyClass { public: int m; static int s; };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Access.qll/type.Access$FieldAccess.html" class="ref-link ref-type" title="Class FieldAccess">FieldAccess</a></td><td><span class="qldoc-summary"><p>A C/C++ field access expression. For example the accesses to  <code>x</code> and <code>y</code> in <code>myMethod</code> in the following code:  ```  class MyClass {  public:    void myMethod(MyClass &amp;other) {      x = other.y;    }</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/File.qll/type.File$File.html" class="ref-link ref-type" title="Class File">File</a></td><td><span class="qldoc-summary"><p>A file that was observed on disk during the build process.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/ObjectiveC.qll/type.ObjectiveC$FinallyBlock.html" class="ref-link ref-type" title="Class FinallyBlock">FinallyBlock</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C <code>@finally</code> block.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$FinallyEnd.html" class="ref-link ref-type" title="Class FinallyEnd">FinallyEnd</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  The end of a &lsquo;finally&rsquo; clause.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$Float128Type.html" class="ref-link ref-type" title="Class Float128Type">Float128Type</a></td><td><span class="qldoc-summary"><p>The GNU C <code>__float128</code> primitive type.  This is not standard C/C++.  <code>__float128 f128;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$FloatType.html" class="ref-link ref-type" title="Class FloatType">FloatType</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>float</code> type.  <code>float f;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$FloatingPointConversion.html" class="ref-link ref-type" title="Class FloatingPointConversion">FloatingPointConversion</a></td><td><span class="qldoc-summary"><p>A conversion from one floating point type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$FloatingPointToIntegralConversion.html" class="ref-link ref-type" title="Class FloatingPointToIntegralConversion">FloatingPointToIntegralConversion</a></td><td><span class="qldoc-summary"><p>A conversion from a floating point type to an integral or enum type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$FloatingPointType.html" class="ref-link ref-type" title="Class FloatingPointType">FloatingPointType</a></td><td><span class="qldoc-summary"><p>The C/C++ floating point types. See 4.5.  This includes <code>float</code>, <code>double</code> and <code>long double</code>, the  fixed-size floating-point types like <code>_Float32</code>, the extended-precision floating-point types like  <code>_Float64x</code>, and the decimal floating-point types like <code>_Decimal32</code>. It also includes the complex  and imaginary versions of all of these types.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$FoldExpr.html" class="ref-link ref-type" title="Class FoldExpr">FoldExpr</a></td><td><span class="qldoc-summary"><p>A C++17 fold expression. This will only appear in an uninstantiated template; any instantiations  of the template will instead contain the sequence of expressions given by expanding the fold.  <code>template &lt; typename... T &gt; auto sum ( T... t ) { return ( t + ... + 0 ); }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/File.qll/type.File$Folder.html" class="ref-link ref-type" title="Class Folder">Folder</a></td><td><span class="qldoc-summary"><p>A folder that was observed on disk during the build process.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/ObjectiveC.qll/type.ObjectiveC$ForInStmt.html" class="ref-link ref-type" title="Class ForInStmt">ForInStmt</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C for-in statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$ForStmt.html" class="ref-link ref-type" title="Class ForStmt">ForStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;for&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Specifier.qll/type.Specifier$FormatAttribute.html" class="ref-link ref-type" title="Class FormatAttribute">FormatAttribute</a></td><td><span class="qldoc-summary"><p>A GNU <code>format</code> attribute of the form <code>__attribute__((format(archetype, format-index, first-arg)))</code>  that declares a function to accept a <code>printf</code> style format string.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/Printf.qll/type.Printf$FormatLiteral.html" class="ref-link ref-type" title="Class FormatLiteral">FormatLiteral</a></td><td><span class="qldoc-summary"><p>A class to represent format strings that occur as arguments to invocations of formatting functions.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/FormattingFunction.qll/type.FormattingFunction$FormattingFunction.html" class="ref-link ref-type" title="Class FormattingFunction">FormattingFunction</a></td><td><span class="qldoc-summary"><p>A standard library function that uses a <code>printf</code>-like formatting string.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/Printf.qll/type.Printf$FormattingFunctionCall.html" class="ref-link ref-type" title="Class FormattingFunctionCall">FormattingFunctionCall</a></td><td><span class="qldoc-summary"><p>A call to one of the formatting functions.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/implementations/Printf.qll/type.Printf$Fprintf.html" class="ref-link ref-type" title="Class Fprintf">Fprintf</a></td><td><span class="qldoc-summary"><p>The standard functions <code>fprintf</code>, <code>fwprintf</code> and their glib variants.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/FriendDecl.qll/type.FriendDecl$FriendDecl.html" class="ref-link ref-type" title="Class FriendDecl">FriendDecl</a></td><td><span class="qldoc-summary"><p>A C++ friend declaration [N4140 11.3]. For example the two friend  declarations in class <code>A</code> of the following code:  ```  class A {    friend void f(int);    friend class X;  };</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Class.qll/type.Class$FullClassTemplateSpecialization.html" class="ref-link ref-type" title="Class FullClassTemplateSpecialization">FullClassTemplateSpecialization</a></td><td><span class="qldoc-summary"><p>A full specialization of a class template.  For example <code>MyTemplateClass&lt;int&gt;</code>  in the following code is a <code>FullClassTemplateSpecialization</code>:  ```  template<class T>  class MyTemplateClass {    &hellip;  };</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Function.qll/type.Function$Function.html" class="ref-link ref-type" title="Class Function">Function</a></td><td><span class="qldoc-summary"><p>A C/C++ function [N4140 8.3.5]. Both member functions and non-member  functions are included. For example the function <code>MyFunction</code> in:  <code>void MyFunction() { DoSomething(); }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Access.qll/type.Access$FunctionAccess.html" class="ref-link ref-type" title="Class FunctionAccess">FunctionAccess</a></td><td><span class="qldoc-summary"><p>A C/C++ function access expression. For example the access to  <code>myFunctionTarget</code> in <code>myFunction</code> in the following code:  ```  int myFunctionTarget(int);</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></td><td><span class="qldoc-summary"><p>A C/C++ function call where the name of the target function is known at compile-time.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Function.qll/type.Function$FunctionDeclarationEntry.html" class="ref-link ref-type" title="Class FunctionDeclarationEntry">FunctionDeclarationEntry</a></td><td><span class="qldoc-summary"><p>A particular declaration or definition of a C/C++ function. For example the  declaration and definition of <code>MyFunction</code> in the following code are each a  <code>FunctionDeclarationEntry</code>:  ```  void MyFunction();</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/FunctionInputsAndOutputs.qll/type.FunctionInputsAndOutputs$FunctionInput.html" class="ref-link ref-type" title="Class FunctionInput">FunctionInput</a></td><td><span class="qldoc-summary"><p>An input to a function. This can be:  - The value of one of the function&rsquo;s parameters  - The value pointed to by one of function&rsquo;s pointer or reference parameters  - The value of the function&rsquo;s <code>this</code> pointer  - The value pointed to by the function&rsquo;s <code>this</code> pointer</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/FunctionInputsAndOutputs.qll/type.FunctionInputsAndOutputs$FunctionOutput.html" class="ref-link ref-type" title="Class FunctionOutput">FunctionOutput</a></td><td><span class="qldoc-summary"><p>An output from a function. This can be:  - The value pointed to by one of function&rsquo;s pointer or reference parameters  - The value pointed to by the function&rsquo;s <code>this</code> pointer  - The function&rsquo;s return value  - The value pointed to by the function&rsquo;s return value, if the return value is a pointer or    reference</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$FunctionPointerIshType.html" class="ref-link ref-type" title="Class FunctionPointerIshType">FunctionPointerIshType</a></td><td><span class="qldoc-summary"><p>A C/C++ pointer to a function, a C++ function reference, or a clang/Apple block.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/Variable.qll/type.Variable$FunctionPointerMemberVariable.html" class="ref-link ref-type" title="Class FunctionPointerMemberVariable">FunctionPointerMemberVariable</a></span></td><td><span class="qldoc-summary"><p>A C/C++ function pointer member variable.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$FunctionPointerType.html" class="ref-link ref-type" title="Class FunctionPointerType">FunctionPointerType</a></td><td><span class="qldoc-summary"><p>A C/C++ pointer to a function. See 7.7.  <code>int(* pointer)(const void *element1, const void *element2);</code></p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/Variable.qll/type.Variable$FunctionPointerVariable.html" class="ref-link ref-type" title="Class FunctionPointerVariable">FunctionPointerVariable</a></span></td><td><span class="qldoc-summary"><p>A C/C++ function pointer variable.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$FunctionReferenceType.html" class="ref-link ref-type" title="Class FunctionReferenceType">FunctionReferenceType</a></td><td><span class="qldoc-summary"><p>A C++ reference to a function.  <code>int(&amp; reference)(const void *element1, const void *element2);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Specifier.qll/type.Specifier$FunctionSpecifier.html" class="ref-link ref-type" title="Class FunctionSpecifier">FunctionSpecifier</a></td><td><span class="qldoc-summary"><p>A C/C++ function specifier: <code>inline</code>, <code>virtual</code>, or <code>explicit</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Function.qll/type.Function$FunctionTemplateInstantiation.html" class="ref-link ref-type" title="Class FunctionTemplateInstantiation">FunctionTemplateInstantiation</a></td><td><span class="qldoc-summary"><p>A function that is an instantiation of a template. For example  the instantiation <code>myTemplateFunction&lt;int&gt;</code> in the following code:  ```  template<class T>  void myTemplateFunction(T t) {    &hellip;  }</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Function.qll/type.Function$FunctionTemplateSpecialization.html" class="ref-link ref-type" title="Class FunctionTemplateSpecialization">FunctionTemplateSpecialization</a></td><td><span class="qldoc-summary"><p>An explicit specialization of a C++ function template. For example the  function <code>myTemplateFunction&lt;int&gt;</code> in the following code:  ```  template<class T>  void myTemplateFunction(T t) {    &hellip;  }</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$FunctionTryStmt.html" class="ref-link ref-type" title="Class FunctionTryStmt">FunctionTryStmt</a></td><td><span class="qldoc-summary"><p>A C++ &lsquo;function try&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ComparisonOperation.qll/type.ComparisonOperation$GEExpr.html" class="ref-link ref-type" title="Class GEExpr">GEExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ greater than or equal expression.  <code>bool c = (a &gt;= b);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$GNUVectorType.html" class="ref-link ref-type" title="Class GNUVectorType">GNUVectorType</a></td><td><span class="qldoc-summary"><p>A GNU/Clang vector type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ComparisonOperation.qll/type.ComparisonOperation$GTExpr.html" class="ref-link ref-type" title="Class GTExpr">GTExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ greater than expression.  <code>bool c = (a &gt; b);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Namespace.qll/type.Namespace$GlobalNamespace.html" class="ref-link ref-type" title="Class GlobalNamespace">GlobalNamespace</a></td><td><span class="qldoc-summary"><p>The C/C++ global namespace.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Variable.qll/type.Variable$GlobalOrNamespaceVariable.html" class="ref-link ref-type" title="Class GlobalOrNamespaceVariable">GlobalOrNamespaceVariable</a></td><td><span class="qldoc-summary"><p>A C/C++ variable which has global scope or namespace scope. For example the  variables <code>a</code> and <code>b</code> in the following code:  ```  int a;</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Variable.qll/type.Variable$GlobalVariable.html" class="ref-link ref-type" title="Class GlobalVariable">GlobalVariable</a></td><td><span class="qldoc-summary"><p>A C/C++ variable which has global scope. For example the variable <code>a</code>  in the following code:  ```  int a;</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$GlvalueConversion.html" class="ref-link ref-type" title="Class GlvalueConversion">GlvalueConversion</a></td><td><span class="qldoc-summary"><p>A conversion of a <em>glvalue</em> from one type to another. The conversion does not  modify the address of the <em>glvalue</em>. For <em>glvalue</em> conversions involving base and  derived classes, see <code>BaseClassConversion</code> and <code>DerivedClassConversion</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Specifier.qll/type.Specifier$GnuAttribute.html" class="ref-link ref-type" title="Class GnuAttribute">GnuAttribute</a></td><td><span class="qldoc-summary"><p>An attribute introduced by GNU&rsquo;s <code>__attribute__((name))</code> syntax, for  example: <code>__attribute__((__noreturn__))</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$GotoStmt.html" class="ref-link ref-type" title="Class GotoStmt">GotoStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;goto&rsquo; statement which jumps to a label.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$Handler.html" class="ref-link ref-type" title="Class Handler">Handler</a></td><td><span class="qldoc-summary"><p>A handler for a &lsquo;try&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/File.qll/type.File$HeaderFile.html" class="ref-link ref-type" title="Class HeaderFile">HeaderFile</a></td><td><span class="qldoc-summary"><p>A C/C++ header file, as determined (mainly) by file extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Literal.qll/type.Literal$HexLiteral.html" class="ref-link ref-type" title="Class HexLiteral">HexLiteral</a></td><td><span class="qldoc-summary"><p>A hexadecimal literal.  <code>unsigned int32_t minus2 = 0xfffffffe;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$IfStmt.html" class="ref-link ref-type" title="Class IfStmt">IfStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;if&rsquo; statement. For example, the <code>if</code> statement in the following  code:  <code>if (x == 1) { ... }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$ImaginaryDivExpr.html" class="ref-link ref-type" title="Class ImaginaryDivExpr">ImaginaryDivExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ divide expression with an imaginary number.  This is specific to  C99 and later.  <code>double z; _Imaginary double y; z = z / y;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$ImaginaryDomain.html" class="ref-link ref-type" title="Class ImaginaryDomain">ImaginaryDomain</a></td><td><span class="qldoc-summary"><p>The type domain of a floating-point type that represents an imaginary number.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$ImaginaryMulExpr.html" class="ref-link ref-type" title="Class ImaginaryMulExpr">ImaginaryMulExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ multiply expression with an imaginary number.  This is specific to  C99 and later.  <code>double z; _Imaginary double x, y; z = x * y;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$ImaginaryNumberType.html" class="ref-link ref-type" title="Class ImaginaryNumberType">ImaginaryNumberType</a></td><td><span class="qldoc-summary"><p>A floating-point type representing an imaginary number.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$ImaginaryPartExpr.html" class="ref-link ref-type" title="Class ImaginaryPartExpr">ImaginaryPartExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ GNU imaginary part expression.  It operates on <code>_Complex</code> or  <code>__complex__</code> numbers.  <code>_Complex double f = { 2.0, 3.0 }; double d = __imag(f); // 3.0</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$ImaginaryRealAddExpr.html" class="ref-link ref-type" title="Class ImaginaryRealAddExpr">ImaginaryRealAddExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ add expression with an imaginary term and a real term.  This is  specific to C99 and later.  <code>double z; _Imaginary double x; _Complex double w; w = x + z;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$ImaginaryRealSubExpr.html" class="ref-link ref-type" title="Class ImaginaryRealSubExpr">ImaginaryRealSubExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ subtract expression with an imaginary term and a real term.  This is  specific to C99 and later.  <code>double z; _Imaginary double x; _Complex double w; w = x - z;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/MemberFunction.qll/type.MemberFunction$ImplicitConversionFunction.html" class="ref-link ref-type" title="Class ImplicitConversionFunction">ImplicitConversionFunction</a></td><td><span class="qldoc-summary"><p>A function that defines an implicit conversion.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Access.qll/type.Access$ImplicitThisFieldAccess.html" class="ref-link ref-type" title="Class ImplicitThisFieldAccess">ImplicitThisFieldAccess</a></td><td><span class="qldoc-summary"><p>A field access of a field of <code>this</code> which has no qualifier because  the use of <code>this</code> is implicit. For example, in the following code the  implicit call to the destructor of <code>A</code> has no qualifier because the  use of <code>this</code> is implicit:  ```  class A {  public:    ~A() {      // &hellip;    }  };</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Include.qll/type.Include$Import.html" class="ref-link ref-type" title="Class Import">Import</a></td><td><span class="qldoc-summary"><p>A <code>#import</code> preprocessor directive (used heavily in Objective C, and  supported by GCC as an extension in C). For example the following code  contains one <code>Import</code> directive:  <code>#import &lt;header3.h&gt;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/FunctionInputsAndOutputs.qll/type.FunctionInputsAndOutputs$InParameter.html" class="ref-link ref-type" title="Class InParameter">InParameter</a></td><td><span class="qldoc-summary"><p>The input value of a parameter.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/FunctionInputsAndOutputs.qll/type.FunctionInputsAndOutputs$InParameterDeref.html" class="ref-link ref-type" title="Class InParameterDeref">InParameterDeref</a></td><td><span class="qldoc-summary"><p>The input value pointed to by a pointer parameter to a function, or the input value referred to  by a reference parameter to a function.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/FunctionInputsAndOutputs.qll/type.FunctionInputsAndOutputs$InQualifierAddress.html" class="ref-link ref-type" title="Class InQualifierAddress">InQualifierAddress</a></td><td><span class="qldoc-summary"><p>The input value of the <code>this</code> pointer of an instance member function.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/FunctionInputsAndOutputs.qll/type.FunctionInputsAndOutputs$InQualifierObject.html" class="ref-link ref-type" title="Class InQualifierObject">InQualifierObject</a></td><td><span class="qldoc-summary"><p>The input value pointed to by the <code>this</code> pointer of an instance member function.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/FunctionInputsAndOutputs.qll/type.FunctionInputsAndOutputs$InReturnValueDeref.html" class="ref-link ref-type" title="Class InReturnValueDeref">InReturnValueDeref</a></td><td><span class="qldoc-summary"><p>The input value pointed to by the return value of a function, if the  function returns a pointer, or the input value referred to by the return  value of a function, if the function returns a reference.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Include.qll/type.Include$Include.html" class="ref-link ref-type" title="Class Include">Include</a></td><td><span class="qldoc-summary"><p>A C/C++ <code>#include</code>, <code>#include_next</code>, or <code>#import</code> preprocessor  directive. The following example contains four different <code>Include</code>  directives:  <code>#include &quot;header.h&quot; #include &lt;string&gt; #include_next &lt;header2.h&gt; #import &lt;header3.h&gt;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Include.qll/type.Include$IncludeNext.html" class="ref-link ref-type" title="Class IncludeNext">IncludeNext</a></td><td><span class="qldoc-summary"><p>A <code>#include_next</code> preprocessor directive (a non-standard extension to  C/C++). For example the following code contains one <code>IncludeNext</code> directive:  <code>#include_next &lt;header2.h&gt;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$IncrementOperation.html" class="ref-link ref-type" title="Class IncrementOperation">IncrementOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ <code>++</code> expression (either prefix or postfix).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$InheritanceConversion.html" class="ref-link ref-type" title="Class InheritanceConversion">InheritanceConversion</a></td><td><span class="qldoc-summary"><p>A conversion between two pointers or _glvalue_s related by inheritance.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Initializer.qll/type.Initializer$Initializer.html" class="ref-link ref-type" title="Class Initializer">Initializer</a></td><td><span class="qldoc-summary"><p>A C/C++ declaration initializer. For example the initializers <code>1</code>, <code>2</code> and  <code>3</code> in the following code:  ```  int myVariable = 1;</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$Int128Type.html" class="ref-link ref-type" title="Class Int128Type">Int128Type</a></td><td><span class="qldoc-summary"><p>The GNU C __int128 primitive types.  They are not part of standard C/C++.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/CommonType.qll/type.CommonType$IntPointerType.html" class="ref-link ref-type" title="Class IntPointerType">IntPointerType</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>int*</code> type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$IntType.html" class="ref-link ref-type" title="Class IntType">IntType</a></td><td><span class="qldoc-summary"><p>The C/C++ integer types. See 4.4.  This includes <code>int</code>, <code>signed int</code>  and <code>unsigned int</code>.  <code>unsigned int ui;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$IntegralConversion.html" class="ref-link ref-type" title="Class IntegralConversion">IntegralConversion</a></td><td><span class="qldoc-summary"><p>A conversion from one integral or enum type to another.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$IntegralOrEnumType.html" class="ref-link ref-type" title="Class IntegralOrEnumType">IntegralOrEnumType</a></td><td><span class="qldoc-summary"><p>A C/C++ integral or <code>enum</code> type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$IntegralToFloatingPointConversion.html" class="ref-link ref-type" title="Class IntegralToFloatingPointConversion">IntegralToFloatingPointConversion</a></td><td><span class="qldoc-summary"><p>A conversion from an integral or enum type to a floating point type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$IntegralToPointerConversion.html" class="ref-link ref-type" title="Class IntegralToPointerConversion">IntegralToPointerConversion</a></td><td><span class="qldoc-summary"><p>A conversion from an integral or enum type to a pointer type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$IntegralType.html" class="ref-link ref-type" title="Class IntegralType">IntegralType</a></td><td><span class="qldoc-summary"><p>The C/C++ integral types. See 4.1.1.  These are types that are represented  as integers of varying sizes.  Both <code>enum</code> types and floating-point types  are excluded.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/Class.qll/type.Class$Interface.html" class="ref-link ref-type" title="Class Interface">Interface</a></span></td><td><span class="qldoc-summary"><p>An &ldquo;interface&rdquo; is a class that only contains pure virtual functions (and contains  at least one such function).  For example:  <code>class MyInterfaceClass { public: virtual void myMethod1() = 0; virtual void myMethod2() = 0; };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/CommonType.qll/type.CommonType$Intmax_t.html" class="ref-link ref-type" title="Class Intmax_t">Intmax_t</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>intmax_t</code> type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$JumpStmt.html" class="ref-link ref-type" title="Class JumpStmt">JumpStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ jump statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ComparisonOperation.qll/type.ComparisonOperation$LEExpr.html" class="ref-link ref-type" title="Class LEExpr">LEExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ less than or equal expression.  <code>bool c = (a &lt;= b);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BitwiseOperation.qll/type.BitwiseOperation$LShiftExpr.html" class="ref-link ref-type" title="Class LShiftExpr">LShiftExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ left shift expression.  <code>unsigned c = a &lt;&lt; b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ComparisonOperation.qll/type.ComparisonOperation$LTExpr.html" class="ref-link ref-type" title="Class LTExpr">LTExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ less than expression.  <code>bool c = (a &lt; b);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$LValueReferenceType.html" class="ref-link ref-type" title="Class LValueReferenceType">LValueReferenceType</a></td><td><span class="qldoc-summary"><p>A C++11 lvalue reference type (e.g. <code>int &amp;</code>).  <code>int a; int&amp; b = a;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Literal.qll/type.Literal$LabelLiteral.html" class="ref-link ref-type" title="Class LabelLiteral">LabelLiteral</a></td><td><span class="qldoc-summary"><p>A label literal, that is, a use of the &lsquo;&amp;&amp;&rsquo; operator to take the address of a  label for use in a computed goto statement.  This is a non-standard C/C++ extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$LabelStmt.html" class="ref-link ref-type" title="Class LabelStmt">LabelStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;label&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Lambda.qll/type.Lambda$LambdaCapture.html" class="ref-link ref-type" title="Class LambdaCapture">LambdaCapture</a></td><td><span class="qldoc-summary"><p>Information about a value captured as part of a lambda expression.  For  example in the following code, information about <code>x</code> and <code>y</code> is captured:  <code>auto a = [x, y](int z) -&gt; int { return x + y + z; };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Lambda.qll/type.Lambda$LambdaExpression.html" class="ref-link ref-type" title="Class LambdaExpression">LambdaExpression</a></td><td><span class="qldoc-summary"><p>A C++11 lambda expression, for example the expression initializing <code>a</code> in  the following code:  <code>auto a = [x, y](int z) -&gt; int { return x + y + z; };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Linkage.qll/type.Linkage$LinkTarget.html" class="ref-link ref-type" title="Class LinkTarget">LinkTarget</a></td><td><span class="qldoc-summary"><p>A linker call during the build process, typically resulting in an  executable or a shared library.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Literal.qll/type.Literal$Literal.html" class="ref-link ref-type" title="Class Literal">Literal</a></td><td><span class="qldoc-summary"><p>A C/C++ literal.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Class.qll/type.Class$LocalClass.html" class="ref-link ref-type" title="Class LocalClass">LocalClass</a></td><td><span class="qldoc-summary"><p>A class, struct or union that is directly enclosed by a function.  For example  the <code>struct</code> in the following code is a <code>LocalClass</code>:  <code>void myFunction() { struct { int x; int y; } vec = { 1, 2 }; };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Enum.qll/type.Enum$LocalEnum.html" class="ref-link ref-type" title="Class LocalEnum">LocalEnum</a></td><td><span class="qldoc-summary"><p>A C/C++ enum that is directly enclosed by a function. For example, the type  <code>MyLocalEnum</code> in:  <code>void myFunction() { enum MyLocalEnum { MyLocalEnumConstant }; }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Variable.qll/type.Variable$LocalScopeVariable.html" class="ref-link ref-type" title="Class LocalScopeVariable">LocalScopeVariable</a></td><td><span class="qldoc-summary"><p>A C/C++ variable with block scope [N4140 3.3.3]. In other words, a local  variable or a function parameter. For example, the variables <code>a</code>, <code>b</code> and  <code>c</code> in the following code:  <code>void myFunction(int a) { int b; static int c; }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Struct.qll/type.Struct$LocalStruct.html" class="ref-link ref-type" title="Class LocalStruct">LocalStruct</a></td><td><span class="qldoc-summary"><p>A C/C++ struct that is directly enclosed by a function. For example, the type  <code>MyLocalStruct</code> in:  <code>void myFunction() { struct MyLocalStruct { int x, y, z; }; }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/TypedefType.qll/type.TypedefType$LocalTypedefType.html" class="ref-link ref-type" title="Class LocalTypedefType">LocalTypedefType</a></td><td><span class="qldoc-summary"><p>A C++ <code>typedef</code> type that is directly enclosed by a function.  For example the type declared inside the function <code>foo</code> in  the following code:  <code>int foo(void) { typedef int local; }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Union.qll/type.Union$LocalUnion.html" class="ref-link ref-type" title="Class LocalUnion">LocalUnion</a></td><td><span class="qldoc-summary"><p>A C/C++ union that is directly enclosed by a function. For example, the type  <code>MyLocalUnion</code> in:  <code>void myFunction() { union MyLocalUnion { int i; float f; }; }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Variable.qll/type.Variable$LocalVariable.html" class="ref-link ref-type" title="Class LocalVariable">LocalVariable</a></td><td><span class="qldoc-summary"><p>A C/C++ local variable. In other words, any variable that has block  scope [N4140 3.3.3], but is not a parameter of a <code>Function</code> or <code>CatchBlock</code>.  For example the variables <code>b</code> and <code>c</code> in the following code:  <code>void myFunction(int a) { int b; static int c; }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Location.qll/type.Location$Locatable.html" class="ref-link ref-type" title="Class Locatable">Locatable</a></td><td><span class="qldoc-summary"><p>A C/C++ element that has a location in a file</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Location.qll/type.Location$Location.html" class="ref-link ref-type" title="Class Location">Location</a></td><td><span class="qldoc-summary"><p>A location of a C/C++ artifact.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/Location.qll/type.Location$LocationDefault.html" class="ref-link ref-type" title="Class LocationDefault">LocationDefault</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Use <code>Location</code> instead.  A location of an element. Not used for expressions or statements, which  instead use LocationExpr and LocationStmt respectively.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/Location.qll/type.Location$LocationExpr.html" class="ref-link ref-type" title="Class LocationExpr">LocationExpr</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Use <code>Location</code> instead.  A location of an expression.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/Location.qll/type.Location$LocationStmt.html" class="ref-link ref-type" title="Class LocationStmt">LocationStmt</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Use <code>Location</code> instead.  A location of a statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/LogicalOperation.qll/type.LogicalOperation$LogicalAndExpr.html" class="ref-link ref-type" title="Class LogicalAndExpr">LogicalAndExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ logical AND expression.  <code>if (a &amp;&amp; b) { }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/LogicalOperation.qll/type.LogicalOperation$LogicalOrExpr.html" class="ref-link ref-type" title="Class LogicalOrExpr">LogicalOrExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ logical OR expression.  <code>if (a || b) { }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$LongDoubleType.html" class="ref-link ref-type" title="Class LongDoubleType">LongDoubleType</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>long double</code> type.  <code>long double ld;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$LongLongType.html" class="ref-link ref-type" title="Class LongLongType">LongLongType</a></td><td><span class="qldoc-summary"><p>The C/C++ long long types. See 4.4.  This includes <code>long long</code>, <code>signed long long</code>  and <code>unsigned long long</code>.  <code>signed long long sll;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$LongType.html" class="ref-link ref-type" title="Class LongType">LongType</a></td><td><span class="qldoc-summary"><p>The C/C++ long types. See 4.4.  This includes <code>long</code>, <code>signed long</code>  and <code>unsigned long</code>.  <code>long l;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$Loop.html" class="ref-link ref-type" title="Class Loop">Loop</a></td><td><span class="qldoc-summary"><p>A C/C++ loop, that is, either a &lsquo;while&rsquo; loop, a &lsquo;for&rsquo; loop, or a  &lsquo;do&rsquo; loop.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Iteration.qll/type.Iteration$LoopControlVariable.html" class="ref-link ref-type" title="Class LoopControlVariable">LoopControlVariable</a></td><td><span class="qldoc-summary"><p>A C/C++ variable which is used within the initialization, condition, or  update expression of a &lsquo;for&rsquo; loop.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Iteration.qll/type.Iteration$LoopCounter.html" class="ref-link ref-type" title="Class LoopCounter">LoopCounter</a></td><td><span class="qldoc-summary"><p>A C/C++ variable which is used within the condition of a &lsquo;for&rsquo; loop, and  mutated within the update expression of the same &lsquo;for&rsquo; loop.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Macro.qll/type.Macro$Macro.html" class="ref-link ref-type" title="Class Macro">Macro</a></td><td><span class="qldoc-summary"><p>A macro. For example, the macro <code>MYMACRO</code> in the following code:  <code>#define MYMACRO 1</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Macro.qll/type.Macro$MacroAccess.html" class="ref-link ref-type" title="Class MacroAccess">MacroAccess</a></td><td><span class="qldoc-summary"><p>A macro access.  For example:  <code>#ifdef MACRO1 // this line contains a MacroAccess int x = MACRO2; // this line contains a MacroAccess #endif</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Macro.qll/type.Macro$MacroInvocation.html" class="ref-link ref-type" title="Class MacroInvocation">MacroInvocation</a></td><td><span class="qldoc-summary"><p>A macro invocation (macro access that is expanded).  For example:  <code>#ifdef MACRO1 int x = MACRO2; // this line contains a MacroInvocation #endif</code></p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/Macro.qll/type.Macro$MacroInvocationExpr.html" class="ref-link ref-type" title="Class MacroInvocationExpr">MacroInvocationExpr</a></span></td><td><span class="qldoc-summary"><p>A top-level expression generated by a macro invocation.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/Macro.qll/type.Macro$MacroInvocationStmt.html" class="ref-link ref-type" title="Class MacroInvocationStmt">MacroInvocationStmt</a></span></td><td><span class="qldoc-summary"><p>A top-level statement generated by a macro invocation.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$MaxExpr.html" class="ref-link ref-type" title="Class MaxExpr">MaxExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ GNU max expression.  <code>c = a &gt;? b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/MemberFunction.qll/type.MemberFunction$MemberFunction.html" class="ref-link ref-type" title="Class MemberFunction">MemberFunction</a></td><td><span class="qldoc-summary"><p>A C++ function declared as a member of a class [N4140 9.3]. This includes  static member functions. For example the functions <code>MyStaticMemberFunction</code>  and <code>MyMemberFunction</code> in:  ```  class MyClass {  public:    void MyMemberFunction() {      DoSomething();    }</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Variable.qll/type.Variable$MemberVariable.html" class="ref-link ref-type" title="Class MemberVariable">MemberVariable</a></td><td><span class="qldoc-summary"><p>A C structure member or C++ member variable. For example the member  variables <code>m</code> and <code>s</code> in the following code:  <code>class MyClass { public: int m; static int s; };</code></p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/ObjectiveC.qll/type.ObjectiveC$MessageExpr.html" class="ref-link ref-type" title="Class MessageExpr">MessageExpr</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C message expression, for example <code>[myColor changeColorToRed:5.0 green:2.0 blue:6.0]</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/metrics/MetricClass.qll/type.MetricClass$MetricClass.html" class="ref-link ref-type" title="Class MetricClass">MetricClass</a></td><td><span class="qldoc-summary"><p>A wrapper that provides metrics for a C++ class.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/metrics/MetricFile.qll/type.MetricFile$MetricFile.html" class="ref-link ref-type" title="Class MetricFile">MetricFile</a></td><td><span class="qldoc-summary"><p>A wrapper that provides metrics for a C/C++ file.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/metrics/MetricFunction.qll/type.MetricFunction$MetricFunction.html" class="ref-link ref-type" title="Class MetricFunction">MetricFunction</a></td><td><span class="qldoc-summary"><p>A wrapper that provides metrics for a C/C++ function.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/metrics/MetricNamespace.qll/type.MetricNamespace$MetricNamespace.html" class="ref-link ref-type" title="Class MetricNamespace">MetricNamespace</a></td><td><span class="qldoc-summary"><p>A wrapper that provides metrics for a C/C++ namespace.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Specifier.qll/type.Specifier$MicrosoftAttribute.html" class="ref-link ref-type" title="Class MicrosoftAttribute">MicrosoftAttribute</a></td><td><span class="qldoc-summary"><p>An attribute introduced by Microsoft&rsquo;s &ldquo;[name]&rdquo; syntax, for example &ldquo;[SA_Pre(Deref=1,Access=SA_Read)]&rdquo;.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/CommonType.qll/type.CommonType$MicrosoftInt16Type.html" class="ref-link ref-type" title="Class MicrosoftInt16Type">MicrosoftInt16Type</a></td><td><span class="qldoc-summary"><p>The type that the Microsoft C/C++ <code>__int16</code> type specifier is a  synonym for.  Note that since <code>__int16</code> is not a distinct type,  <code>MicrosoftInt16Type</code> corresponds to an existing <code>IntegralType</code> as  well.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/CommonType.qll/type.CommonType$MicrosoftInt32Type.html" class="ref-link ref-type" title="Class MicrosoftInt32Type">MicrosoftInt32Type</a></td><td><span class="qldoc-summary"><p>The type that the Microsoft C/C++ <code>__int32</code> type specifier is a  synonym for.  Note that since <code>__int32</code> is not a distinct type,  <code>MicrosoftInt32Type</code> corresponds to an existing <code>IntegralType</code> as  well.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/CommonType.qll/type.CommonType$MicrosoftInt64Type.html" class="ref-link ref-type" title="Class MicrosoftInt64Type">MicrosoftInt64Type</a></td><td><span class="qldoc-summary"><p>The type that the Microsoft C/C++ <code>__int64</code> type specifier is a  synonym for.  Note that since <code>__int64</code> is not a distinct type,  <code>MicrosoftInt64Type</code> corresponds to an existing <code>IntegralType</code> as  well.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/CommonType.qll/type.CommonType$MicrosoftInt8Type.html" class="ref-link ref-type" title="Class MicrosoftInt8Type">MicrosoftInt8Type</a></td><td><span class="qldoc-summary"><p>The type that the Microsoft C/C++ <code>__int8</code> type specifier is a  synonym for.  Note that since <code>__int8</code> is not a distinct type,  <code>MicrosoftInt8Type</code> corresponds to an existing <code>IntegralType</code> as  well.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$MicrosoftTryExceptStmt.html" class="ref-link ref-type" title="Class MicrosoftTryExceptStmt">MicrosoftTryExceptStmt</a></td><td><span class="qldoc-summary"><p>A structured exception handling &lsquo;try except&rsquo; statement, for example the  <code>__try</code> statement in the following code:  <code>__try { f(); } __except(myExceptionFilter()) { g() }</code>  This is a Microsoft C/C++ extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$MicrosoftTryFinallyStmt.html" class="ref-link ref-type" title="Class MicrosoftTryFinallyStmt">MicrosoftTryFinallyStmt</a></td><td><span class="qldoc-summary"><p>A structured exception handling &lsquo;try finally&rsquo; statement, for example the  <code>__try</code> statement in the following code:  <code>__try { f(); } __finally { g() }</code>  This is a Microsoft C/C++ extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$MicrosoftTryStmt.html" class="ref-link ref-type" title="Class MicrosoftTryStmt">MicrosoftTryStmt</a></td><td><span class="qldoc-summary"><p>A structured exception handling &lsquo;try&rsquo; statement, that is, a  <code>__try __except</code> or <code>__try __finally</code> statement. This is a Microsoft  C/C++ extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$MinExpr.html" class="ref-link ref-type" title="Class MinExpr">MinExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ GNU min expression.  <code>c = a &lt;? b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/MemberFunction.qll/type.MemberFunction$MoveAssignmentOperator.html" class="ref-link ref-type" title="Class MoveAssignmentOperator">MoveAssignmentOperator</a></td><td><span class="qldoc-summary"><p>A C++ move assignment operator [N4140 12.8]. For example the function  <code>operator=</code> in the following code is a <code>MoveAssignmentOperator</code>:  <code>class MyClass { public: MyClass &amp;operator=(MyClass &amp;&amp;other); };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/MemberFunction.qll/type.MemberFunction$MoveConstructor.html" class="ref-link ref-type" title="Class MoveConstructor">MoveConstructor</a></td><td><span class="qldoc-summary"><p>A C++ move constructor [N4140 12.8]. For example the function <code>MyClass</code> in  the following code is a <code>MoveConstructor</code>:  <code>class MyClass { public: MyClass(MyClass &amp;&amp;from) { ... } };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$MulExpr.html" class="ref-link ref-type" title="Class MulExpr">MulExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ multiply expression.  <code>c = a * b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/Synchronization.qll/type.Synchronization$MutexType.html" class="ref-link ref-type" title="Class MutexType">MutexType</a></td><td><span class="qldoc-summary"><p>A type that acts as a mutex.  This class is extended below and and may  be extended in <code>Options.qll</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ComparisonOperation.qll/type.ComparisonOperation$NEExpr.html" class="ref-link ref-type" title="Class NEExpr">NEExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ not equal expression.  <code>bool c = (a != b);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/NULL.qll/type.NULL$NULL.html" class="ref-link ref-type" title="Class NULL">NULL</a></td><td><span class="qldoc-summary"><p>A use of the NULL macro.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/NULL.qll/type.NULL$NULLMacro.html" class="ref-link ref-type" title="Class NULLMacro">NULLMacro</a></td><td><span class="qldoc-summary"><p>A macro defining NULL.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/NameQualifiers.qll/type.NameQualifiers$NameQualifiableElement.html" class="ref-link ref-type" title="Class NameQualifiableElement">NameQualifiableElement</a></td><td><span class="qldoc-summary"><p>A C++ element that can be qualified with a name. This is in practice  either an expression or a name qualifier. For example, there are two  name-qualifiable elements in the following code, the expression <code>f()</code>  (which is qualified by <code>N::</code>), and the qualifier <code>N::</code> (which is not  itself qualified in this example):  ```  namespace N {    int f() {      &hellip;    }  }</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/NameQualifiers.qll/type.NameQualifiers$NameQualifier.html" class="ref-link ref-type" title="Class NameQualifier">NameQualifier</a></td><td><span class="qldoc-summary"><p>A C++ name qualifier, for example <code>N::</code> in the following code:  ```  namespace N {    int f() {      &hellip;    }  }</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/NameQualifiers.qll/type.NameQualifiers$NameQualifyingElement.html" class="ref-link ref-type" title="Class NameQualifyingElement">NameQualifyingElement</a></td><td><span class="qldoc-summary"><p>A C++ element that can qualify a name. For example, the namespaces <code>A</code> and  <code>A::B</code> and the class <code>A::C</code> in the following code:  ```  namespace A {    namespace B {      &hellip;    }</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Namespace.qll/type.Namespace$Namespace.html" class="ref-link ref-type" title="Class Namespace">Namespace</a></td><td><span class="qldoc-summary"><p>A C++ namespace.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Namespace.qll/type.Namespace$NamespaceDeclarationEntry.html" class="ref-link ref-type" title="Class NamespaceDeclarationEntry">NamespaceDeclarationEntry</a></td><td><span class="qldoc-summary"><p>A declaration of (part of) a C++ namespace.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Variable.qll/type.Variable$NamespaceVariable.html" class="ref-link ref-type" title="Class NamespaceVariable">NamespaceVariable</a></td><td><span class="qldoc-summary"><p>A C/C++ variable which has namespace scope. For example the variable <code>b</code>  in the following code:  ```  int a;</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Class.qll/type.Class$NestedClass.html" class="ref-link ref-type" title="Class NestedClass">NestedClass</a></td><td><span class="qldoc-summary"><p>A class, struct or union that is declared within another class.  For example  the struct <code>PairT</code> in the following code is a nested class:  <code>template&lt;class T&gt; class MyTemplateClass { public: struct PairT { T first, second; }; };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Enum.qll/type.Enum$NestedEnum.html" class="ref-link ref-type" title="Class NestedEnum">NestedEnum</a></td><td><span class="qldoc-summary"><p>A C/C++ enum that is declared within a class/struct. For example, the type  <code>MyNestedEnum</code> in:  <code>class MyClass { public: enum MyNestedEnum { MyNestedEnumConstant }; };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Struct.qll/type.Struct$NestedStruct.html" class="ref-link ref-type" title="Class NestedStruct">NestedStruct</a></td><td><span class="qldoc-summary"><p>A C/C++ nested struct. See 11.12. For example, the type <code>MyNestedStruct</code> in:  <code>class MyClass { public: struct MyNestedStruct { int x, y, z; }; };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/TypedefType.qll/type.TypedefType$NestedTypedefType.html" class="ref-link ref-type" title="Class NestedTypedefType">NestedTypedefType</a></td><td><span class="qldoc-summary"><p>A C++ <code>typedef</code> type that is directly enclosed by a <code>class</code>, <code>struct</code> or <code>union</code>.  For example the type declared inside  the class <code>C</code> in the following code:  <code>class C { typedef int nested; };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Union.qll/type.Union$NestedUnion.html" class="ref-link ref-type" title="Class NestedUnion">NestedUnion</a></td><td><span class="qldoc-summary"><p>A C/C++ nested union. For example, the type <code>MyNestedUnion</code> in:  <code>class MyClass { public: union MyNestedUnion { int i; float f; }; };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$NewArrayExpr.html" class="ref-link ref-type" title="Class NewArrayExpr">NewArrayExpr</a></td><td><span class="qldoc-summary"><p>A C++ <code>new[]</code> (array) expression.  <code>Foo *foo = new Foo[]{1, 3, 5}; Bar *bar = new Bar[5];</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$NewExpr.html" class="ref-link ref-type" title="Class NewExpr">NewExpr</a></td><td><span class="qldoc-summary"><p>A C++ <code>new</code> (non-array) expression.  <code>Foo *ptr = new Foo(3);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$NewOrNewArrayExpr.html" class="ref-link ref-type" title="Class NewOrNewArrayExpr">NewOrNewArrayExpr</a></td><td><span class="qldoc-summary"><p>A C++ <code>new</code> or <code>new[]</code> expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/MemberFunction.qll/type.MemberFunction$NoArgConstructor.html" class="ref-link ref-type" title="Class NoArgConstructor">NoArgConstructor</a></td><td><span class="qldoc-summary"><p>A C++ constructor that takes no arguments (&lsquo;default&rsquo; constructor). This  is the constructor that is invoked when no initializer is given. For  example the function <code>MyClass</code> in the following code is a  <code>NoArgConstructor</code>:  <code>class MyClass { public: MyClass() { ... } };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$NoExceptExpr.html" class="ref-link ref-type" title="Class NoExceptExpr">NoExceptExpr</a></td><td><span class="qldoc-summary"><p>A C++11 <code>noexcept</code> expression, returning <code>true</code> if its subexpression is guaranteed  not to <code>throw</code> exceptions.  For example:  <code>if (noexcept(func_1() + func_2())) { }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/LogicalOperation.qll/type.LogicalOperation$NotExpr.html" class="ref-link ref-type" title="Class NotExpr">NotExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ logical not expression.  <code>c = !a;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$NullPointerType.html" class="ref-link ref-type" title="Class NullPointerType">NullPointerType</a></td><td><span class="qldoc-summary"><p>The (primitive) type of the C++11 <code>nullptr</code> constant.  It is a  distinct type, denoted by <code>decltype(nullptr)</code>, that is not itself a pointer  type or a pointer to member type.  The <code>&lt;cstddef&gt;</code> header usually defines  the <code>std::nullptr_t</code> type as follows:  <code>typedef decltype(nullptr) nullptr_t;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Nullness.qll/type.Nullness$NullValue.html" class="ref-link ref-type" title="Class NullValue">NullValue</a></td><td><span class="qldoc-summary"><p>A C/C++ literal whose value is considered null.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Dataflow.qll/type.Dataflow$NullnessAnnotation.html" class="ref-link ref-type" title="Class NullnessAnnotation">NullnessAnnotation</a></td><td><span class="qldoc-summary"><p>INTERNAL: Do not use.  Two analyses relating to nullness: <code>&quot;pointer-null&quot;</code> and <code>&quot;pointer-valid&quot;</code>.  These analyses mark expressions that are possibly null or possibly non-null,  respectively.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/File.qll/type.File$ObjCFile.html" class="ref-link ref-type" title="Class ObjCFile">ObjCFile</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C source file, as determined by file extension.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/ObjectiveC.qll/type.ObjectiveC$ObjCLiteralString.html" class="ref-link ref-type" title="Class ObjCLiteralString">ObjCLiteralString</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C @&ldquo;&hellip;&rdquo; string literal.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/File.qll/type.File$ObjCppFile.html" class="ref-link ref-type" title="Class ObjCppFile">ObjCppFile</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C++ source file, as determined by file extension.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/ObjectiveC.qll/type.ObjectiveC$ObjcReThrowExpr.html" class="ref-link ref-type" title="Class ObjcReThrowExpr">ObjcReThrowExpr</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C throw expression with no argument (which causes the  current exception to be re-thrown).</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/ObjectiveC.qll/type.ObjectiveC$ObjcThrowExpr.html" class="ref-link ref-type" title="Class ObjcThrowExpr">ObjcThrowExpr</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C throw expression.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/ObjectiveC.qll/type.ObjectiveC$ObjcTryStmt.html" class="ref-link ref-type" title="Class ObjcTryStmt">ObjcTryStmt</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C try statement.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/ObjectiveC.qll/type.ObjectiveC$ObjectiveClass.html" class="ref-link ref-type" title="Class ObjectiveClass">ObjectiveClass</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C class.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Literal.qll/type.Literal$OctalLiteral.html" class="ref-link ref-type" title="Class OctalLiteral">OctalLiteral</a></td><td><span class="qldoc-summary"><p>An octal literal. For example:  <code>char esc = 033;</code>  Octal literals must always start with the digit <code>0</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$Operation.html" class="ref-link ref-type" title="Class Operation">Operation</a></td><td><span class="qldoc-summary"><p>A C/C++ operation.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Function.qll/type.Function$Operator.html" class="ref-link ref-type" title="Class Operator">Operator</a></td><td><span class="qldoc-summary"><p>A C++ user-defined operator [N4140 13.5].</p>
</span></td></tr><tr><td><a href="../DefaultOptions.qll/type.DefaultOptions$Options.html" class="ref-link ref-type" title="Class Options">Options</a></td><td><span class="qldoc-summary"><p>Default predicates that specify information about the behavior of  the program being analyzed.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/FunctionInputsAndOutputs.qll/type.FunctionInputsAndOutputs$OutParameterDeref.html" class="ref-link ref-type" title="Class OutParameterDeref">OutParameterDeref</a></td><td><span class="qldoc-summary"><p>The output value pointed to by a pointer parameter to a function, or the output value referred to  by a reference parameter to a function.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/FunctionInputsAndOutputs.qll/type.FunctionInputsAndOutputs$OutQualifierObject.html" class="ref-link ref-type" title="Class OutQualifierObject">OutQualifierObject</a></td><td><span class="qldoc-summary"><p>The output value pointed to by the <code>this</code> pointer of an instance member function.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/FunctionInputsAndOutputs.qll/type.FunctionInputsAndOutputs$OutReturnValue.html" class="ref-link ref-type" title="Class OutReturnValue">OutReturnValue</a></td><td><span class="qldoc-summary"><p>The value returned by a function.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/FunctionInputsAndOutputs.qll/type.FunctionInputsAndOutputs$OutReturnValueDeref.html" class="ref-link ref-type" title="Class OutReturnValueDeref">OutReturnValueDeref</a></td><td><span class="qldoc-summary"><p>The output value pointed to by the return value of a function, if the function returns a pointer,  or the output value referred to by the return value of a function, if the function returns a  reference.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$OverloadedArrayExpr.html" class="ref-link ref-type" title="Class OverloadedArrayExpr">OverloadedArrayExpr</a></td><td><span class="qldoc-summary"><p>An instance of a <em>user-defined</em> binary <code>operator[]</code> applied to its arguments.  <code>struct T2 { T1 operator[](const T3 &amp;); }; T1 a; T2 b; T3 c; a = b[c];</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$OverloadedPointerDereferenceExpr.html" class="ref-link ref-type" title="Class OverloadedPointerDereferenceExpr">OverloadedPointerDereferenceExpr</a></td><td><span class="qldoc-summary"><p>An instance of a <em>user-defined</em> unary <code>operator*</code> applied to its argument.  ```  T1 operator*(const T2 &amp;);  T1 a; T2 b;  a = *b;</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Access.qll/type.Access$ParamAccessForType.html" class="ref-link ref-type" title="Class ParamAccessForType">ParamAccessForType</a></td><td><span class="qldoc-summary"><p>An access to a parameter of a function signature for the purposes of a <code>decltype</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Parameter.qll/type.Parameter$Parameter.html" class="ref-link ref-type" title="Class Parameter">Parameter</a></td><td><span class="qldoc-summary"><p>A C/C++ function parameter or catch block parameter. For example the  function parameter <code>p</code> and the catch block parameter <code>e</code> in the following  code:  <code>void myFunction(int p) { try { ... } catch (const std::exception &amp;e) { ... } }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Variable.qll/type.Variable$ParameterDeclarationEntry.html" class="ref-link ref-type" title="Class ParameterDeclarationEntry">ParameterDeclarationEntry</a></td><td><span class="qldoc-summary"><p>A parameter as described within a particular declaration or definition  of a C/C++ function. For example the declaration of <code>a</code> in the following  code:  <code>void myFunction(int a) { int b; }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/DefinitionsAndUses.qll/type.DefinitionsAndUses$ParameterDef.html" class="ref-link ref-type" title="Class ParameterDef">ParameterDef</a></td><td><span class="qldoc-summary"><p>A definition of a parameter.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Parameter.qll/type.Parameter$ParameterIndex.html" class="ref-link ref-type" title="Class ParameterIndex">ParameterIndex</a></td><td><span class="qldoc-summary"><p>An <code>int</code> that is a parameter index for some function.  This is needed for binding in certain cases.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$ParenthesisExpr.html" class="ref-link ref-type" title="Class ParenthesisExpr">ParenthesisExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ parenthesis expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$ParenthesizedBracedInitializerList.html" class="ref-link ref-type" title="Class ParenthesizedBracedInitializerList">ParenthesizedBracedInitializerList</a></td><td><span class="qldoc-summary"><p>A C++11 parenthesized braced initializer list within a template.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Class.qll/type.Class$PartialClassTemplateSpecialization.html" class="ref-link ref-type" title="Class PartialClassTemplateSpecialization">PartialClassTemplateSpecialization</a></td><td><span class="qldoc-summary"><p>A partial specialization of a class template.  For example <code>MyTemplateClass&lt;int, T&gt;</code>  in the following code is a <code>PartialClassTemplateSpecialization</code>:  ```  template&lt;class S, class T&gt;  class MyTemplateClass {    &hellip;  };</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$PlainCharType.html" class="ref-link ref-type" title="Class PlainCharType">PlainCharType</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>char</code> type (which is distinct from <code>signed char</code> and  <code>unsigned char</code>).  For example:  <code>char a, b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$PointerAddExpr.html" class="ref-link ref-type" title="Class PointerAddExpr">PointerAddExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ pointer add expression.  <code>foo *ptr = &amp;f[0]; ptr = ptr + 2;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$PointerArithmeticOperation.html" class="ref-link ref-type" title="Class PointerArithmeticOperation">PointerArithmeticOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ pointer arithmetic operation.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$PointerConversion.html" class="ref-link ref-type" title="Class PointerConversion">PointerConversion</a></td><td><span class="qldoc-summary"><p>A conversion from one pointer type to another.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$PointerDereferenceExpr.html" class="ref-link ref-type" title="Class PointerDereferenceExpr">PointerDereferenceExpr</a></td><td><span class="qldoc-summary"><p>An instance of the built-in unary <code>operator *</code> applied to a type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$PointerDiffExpr.html" class="ref-link ref-type" title="Class PointerDiffExpr">PointerDiffExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ pointer difference expression.  <code>foo *start = &amp;f[0], *end = &amp;f[4]; int size = end - size;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Access.qll/type.Access$PointerFieldAccess.html" class="ref-link ref-type" title="Class PointerFieldAccess">PointerFieldAccess</a></td><td><span class="qldoc-summary"><p>A field access whose qualifier is a pointer to a class, struct or union.  These typically take the form <code>obj-&gt;field</code>. Another case is a field access  with an implicit <code>this-&gt;</code> qualifier, which is often a <code>PointerFieldAccess</code>  (but see also <code>ImplicitThisFieldAccess</code>).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$PointerSubExpr.html" class="ref-link ref-type" title="Class PointerSubExpr">PointerSubExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ pointer subtract expression.  <code>foo *ptr = &amp;f[3]; ptr = ptr - 2;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Access.qll/type.Access$PointerToFieldLiteral.html" class="ref-link ref-type" title="Class PointerToFieldLiteral">PointerToFieldLiteral</a></td><td><span class="qldoc-summary"><p>A C++ <em>pointer to non-static data member</em> literal. For example, <code>&amp;C::x</code> is  an expression that refers to field <code>x</code> of class <code>C</code>. If the type of that  field is <code>int</code>, then <code>&amp;C::x</code> ought to have type <code>int C::*</code>. It is currently  modeled in QL as having type <code>int</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$PointerToIntegralConversion.html" class="ref-link ref-type" title="Class PointerToIntegralConversion">PointerToIntegralConversion</a></td><td><span class="qldoc-summary"><p>A conversion from a pointer type to an integral or enum type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$PointerToMemberBaseClassConversion.html" class="ref-link ref-type" title="Class PointerToMemberBaseClassConversion">PointerToMemberBaseClassConversion</a></td><td><span class="qldoc-summary"><p>A conversion from a pointer-to-member of a derived class to a pointer-to-member  of an immediate base class.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$PointerToMemberConversion.html" class="ref-link ref-type" title="Class PointerToMemberConversion">PointerToMemberConversion</a></td><td><span class="qldoc-summary"><p>A conversion from one pointer-to-member type to another.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$PointerToMemberDerivedClassConversion.html" class="ref-link ref-type" title="Class PointerToMemberDerivedClassConversion">PointerToMemberDerivedClassConversion</a></td><td><span class="qldoc-summary"><p>A conversion from a pointer-to-member of a base class to a pointer-to-member  of an immediate derived class.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$PointerToMemberType.html" class="ref-link ref-type" title="Class PointerToMemberType">PointerToMemberType</a></td><td><span class="qldoc-summary"><p>A C++ pointer to data member. See 15.5.  <code>class C { int m; }; int C::* p = &amp;C::m; // pointer to data member m of class C class C *; int val = c.*p; // access data member</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$PointerType.html" class="ref-link ref-type" title="Class PointerType">PointerType</a></td><td><span class="qldoc-summary"><p>A C/C++ pointer type. See 4.9.1.  <code>void *ptr; void **ptr2 = &amp;ptr;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/PolymorphicClass.qll/type.PolymorphicClass$PolymorphicClass.html" class="ref-link ref-type" title="Class PolymorphicClass">PolymorphicClass</a></td><td><span class="qldoc-summary"><p>A C++ class or structure which (possibly by inheritance) has at least one virtual method.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$PostfixCrementOperation.html" class="ref-link ref-type" title="Class PostfixCrementOperation">PostfixCrementOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ <code>++</code> or <code>--</code> postfix expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$PostfixDecrExpr.html" class="ref-link ref-type" title="Class PostfixDecrExpr">PostfixDecrExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ postfix decrement expression, as in <code>x--</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$PostfixIncrExpr.html" class="ref-link ref-type" title="Class PostfixIncrExpr">PostfixIncrExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ postfix increment expression, as in <code>x++</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$PrefixCrementOperation.html" class="ref-link ref-type" title="Class PrefixCrementOperation">PrefixCrementOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ <code>++</code> or <code>--</code> prefix expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$PrefixDecrExpr.html" class="ref-link ref-type" title="Class PrefixDecrExpr">PrefixDecrExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ prefix decrement expression, as in <code>--x</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$PrefixIncrExpr.html" class="ref-link ref-type" title="Class PrefixIncrExpr">PrefixIncrExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ prefix increment expression, as in <code>++x</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorBranch.html" class="ref-link ref-type" title="Class PreprocessorBranch">PreprocessorBranch</a></td><td><span class="qldoc-summary"><p>A C/C++ preprocessor branching directive: <code>#if</code>, <code>#ifdef</code>, <code>#ifndef</code>, or  <code>#elif</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorBranchDirective.html" class="ref-link ref-type" title="Class PreprocessorBranchDirective">PreprocessorBranchDirective</a></td><td><span class="qldoc-summary"><p>A C/C++ preprocessor branch related directive: <code>#if</code>, <code>#ifdef</code>,  <code>#ifndef</code>, <code>#elif</code>, <code>#else</code> or <code>#endif</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorDirective.html" class="ref-link ref-type" title="Class PreprocessorDirective">PreprocessorDirective</a></td><td><span class="qldoc-summary"><p>A C/C++ preprocessor directive.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorElif.html" class="ref-link ref-type" title="Class PreprocessorElif">PreprocessorElif</a></td><td><span class="qldoc-summary"><p>A C/C++ preprocessor <code>#elif</code> directive.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorElse.html" class="ref-link ref-type" title="Class PreprocessorElse">PreprocessorElse</a></td><td><span class="qldoc-summary"><p>A C/C++ preprocessor <code>#else</code> directive.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorEndif.html" class="ref-link ref-type" title="Class PreprocessorEndif">PreprocessorEndif</a></td><td><span class="qldoc-summary"><p>A C/C++ preprocessor <code>#endif</code> directive.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorError.html" class="ref-link ref-type" title="Class PreprocessorError">PreprocessorError</a></td><td><span class="qldoc-summary"><p>A C/C++ preprocessor <code>#error</code> directive.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorIf.html" class="ref-link ref-type" title="Class PreprocessorIf">PreprocessorIf</a></td><td><span class="qldoc-summary"><p>A C/C++ preprocessor <code>#if</code> directive.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorIfdef.html" class="ref-link ref-type" title="Class PreprocessorIfdef">PreprocessorIfdef</a></td><td><span class="qldoc-summary"><p>A C/C++ preprocessor <code>#ifdef</code> directive.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorIfndef.html" class="ref-link ref-type" title="Class PreprocessorIfndef">PreprocessorIfndef</a></td><td><span class="qldoc-summary"><p>A C/C++ preprocessor <code>#ifndef</code> directive.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorLine.html" class="ref-link ref-type" title="Class PreprocessorLine">PreprocessorLine</a></td><td><span class="qldoc-summary"><p>A C/C++ preprocessor <code>#line</code> directive.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorPragma.html" class="ref-link ref-type" title="Class PreprocessorPragma">PreprocessorPragma</a></td><td><span class="qldoc-summary"><p>A C/C++ preprocessor <code>#pragma</code> directive.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorUndef.html" class="ref-link ref-type" title="Class PreprocessorUndef">PreprocessorUndef</a></td><td><span class="qldoc-summary"><p>A C/C++ preprocessor <code>#undef</code> directive.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorWarning.html" class="ref-link ref-type" title="Class PreprocessorWarning">PreprocessorWarning</a></td><td><span class="qldoc-summary"><p>A C/C++ preprocessor <code>#warning</code> directive.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/implementations/Printf.qll/type.Printf$Printf.html" class="ref-link ref-type" title="Class Printf">Printf</a></td><td><span class="qldoc-summary"><p>The standard functions <code>printf</code>, <code>wprintf</code> and their glib variants.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/Printf.qll/type.Printf$PrintfFormatAttribute.html" class="ref-link ref-type" title="Class PrintfFormatAttribute">PrintfFormatAttribute</a></td><td></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/ObjectiveC.qll/type.ObjectiveC$Property.html" class="ref-link ref-type" title="Class Property">Property</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C <code>@property</code>.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/ObjectiveC.qll/type.ObjectiveC$PropertyAccess.html" class="ref-link ref-type" title="Class PropertyAccess">PropertyAccess</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An access to an Objective C property using dot syntax.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/ObjectiveC.qll/type.ObjectiveC$Protocol.html" class="ref-link ref-type" title="Class Protocol">Protocol</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C protocol.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Class.qll/type.Class$ProxyClass.html" class="ref-link ref-type" title="Class ProxyClass">ProxyClass</a></td><td><span class="qldoc-summary"><p>The proxy class (where needed) associated with a template parameter, as  in the following code:  <code>template &lt;typename T&gt; struct S : T { // the type of this T is a proxy class ... };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$PrvalueAdjustmentConversion.html" class="ref-link ref-type" title="Class PrvalueAdjustmentConversion">PrvalueAdjustmentConversion</a></td><td><span class="qldoc-summary"><p>The adjustment of the type of a class <em>prvalue</em>. Most commonly seen in code  similar to:  <code>class String { ... }; String func(); void caller() { const String&amp; r = func(); }</code>  In the above example, the result of the call to <code>func</code> is a <em>prvalue</em> of type  <code>String</code>, which will be adjusted to type <code>const String</code> before being bound  to the reference.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/CommonType.qll/type.CommonType$Ptrdiff_t.html" class="ref-link ref-type" title="Class Ptrdiff_t">Ptrdiff_t</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>ptrdiff_t</code> type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/MemberFunction.qll/type.MemberFunction$PureVirtualFunction.html" class="ref-link ref-type" title="Class PureVirtualFunction">PureVirtualFunction</a></td><td><span class="qldoc-summary"><p>A C++ pure virtual function [N4140 10.4]. For example the first function  called <code>myVirtualFunction</code> in the following code:  ```  class A {  public:    virtual void myVirtualFunction() = 0;  };</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/VoidContext.qll/type.VoidContext$Qualifier.html" class="ref-link ref-type" title="Class Qualifier">Qualifier</a></td><td><span class="qldoc-summary"><p>An expression that is used to qualify some other expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BitwiseOperation.qll/type.BitwiseOperation$RShiftExpr.html" class="ref-link ref-type" title="Class RShiftExpr">RShiftExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ right shift expression.  <code>unsigned c = a &gt;&gt; b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$RValueReferenceType.html" class="ref-link ref-type" title="Class RValueReferenceType">RValueReferenceType</a></td><td><span class="qldoc-summary"><p>A C++11 rvalue reference type (e.g., <code>int &amp;&amp;</code>).  It is used to  implement &ldquo;move&rdquo; semantics for object construction and assignment.  <code>class C { E e; C(C&amp;&amp; from): e(std::move(from.e)) { } };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$RangeBasedForStmt.html" class="ref-link ref-type" title="Class RangeBasedForStmt">RangeBasedForStmt</a></td><td><span class="qldoc-summary"><p>A C++11 range-based &lsquo;for&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/rangeanalysis/RangeSSA.qll/type.RangeSSA$RangeSSA.html" class="ref-link ref-type" title="Class RangeSSA">RangeSSA</a></td><td><span class="qldoc-summary"><p>The SSA logic comes in two versions: the standard SSA and range-analysis RangeSSA.  This class provides the range-analysis SSA logic.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/rangeanalysis/RangeSSA.qll/type.RangeSSA$RangeSsaDefinition.html" class="ref-link ref-type" title="Class RangeSsaDefinition">RangeSsaDefinition</a></td><td><span class="qldoc-summary"><p>A definition of one or more SSA variables, including phi node  definitions.  An SSA variable is effectively the pair of a definition  and the (non-SSA) variable that it defines.  Note definitions and uses  can be coincident, due to the presence of parameter definitions and phi  nodes.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$ReThrowExpr.html" class="ref-link ref-type" title="Class ReThrowExpr">ReThrowExpr</a></td><td><span class="qldoc-summary"><p>A C++ <code>throw</code> expression with no argument (which causes the current exception to be re-thrown).  <code>throw;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$RealDomain.html" class="ref-link ref-type" title="Class RealDomain">RealDomain</a></td><td><span class="qldoc-summary"><p>The type domain of a floating-point type that represents a real number.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$RealImaginaryAddExpr.html" class="ref-link ref-type" title="Class RealImaginaryAddExpr">RealImaginaryAddExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ add expression with a real term and an imaginary term.  This is  specific to C99 and later.  <code>double z; _Imaginary double x; _Complex double w; w = z + x;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$RealImaginarySubExpr.html" class="ref-link ref-type" title="Class RealImaginarySubExpr">RealImaginarySubExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ subtract expression with a real term and an imaginary term.  This is  specific to C99 and later.  <code>double z; _Imaginary double x; _Complex double w; w = z - x;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$RealNumberType.html" class="ref-link ref-type" title="Class RealNumberType">RealNumberType</a></td><td><span class="qldoc-summary"><p>A floating-point type representing a real number.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$RealPartExpr.html" class="ref-link ref-type" title="Class RealPartExpr">RealPartExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ GNU real part expression.  It operates on <code>_Complex</code> or  <code>__complex__</code> numbers.  <code>_Complex double f = { 2.0, 3.0 }; double d = __real(f); // 2.0</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$ReferenceDereferenceExpr.html" class="ref-link ref-type" title="Class ReferenceDereferenceExpr">ReferenceDereferenceExpr</a></td><td><span class="qldoc-summary"><p>An implicit conversion from type <code>T &amp;</code> to type <code>T</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Access.qll/type.Access$ReferenceFieldAccess.html" class="ref-link ref-type" title="Class ReferenceFieldAccess">ReferenceFieldAccess</a></td><td><span class="qldoc-summary"><p>A field access of the form <code>obj.field</code>, where the type of <code>obj</code> is a  reference to a class/struct/union. For example the accesses to <code>y</code> in  <code>myMethod</code> in the following code:  ```  class MyClass {  public:    void myMethod(MyClass a, MyClass &amp;b) {      a.x = b.y;    }</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$ReferenceToExpr.html" class="ref-link ref-type" title="Class ReferenceToExpr">ReferenceToExpr</a></td><td><span class="qldoc-summary"><p>An implicit conversion from type <code>T</code> to type <code>T &amp;</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$ReferenceType.html" class="ref-link ref-type" title="Class ReferenceType">ReferenceType</a></td><td><span class="qldoc-summary"><p>A C++ reference type. See 4.9.1.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$ReinterpretCast.html" class="ref-link ref-type" title="Class ReinterpretCast">ReinterpretCast</a></td><td><span class="qldoc-summary"><p>A C++ <code>reinterpret_cast</code> expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ComparisonOperation.qll/type.ComparisonOperation$RelationalOperation.html" class="ref-link ref-type" title="Class RelationalOperation">RelationalOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ relational operation, that is, one of <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;</code>, or <code>&gt;=</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$RemExpr.html" class="ref-link ref-type" title="Class RemExpr">RemExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ remainder expression.  <code>c = a % b;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$ReturnStmt.html" class="ref-link ref-type" title="Class ReturnStmt">ReturnStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;return&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$RoutineType.html" class="ref-link ref-type" title="Class RoutineType">RoutineType</a></td><td><span class="qldoc-summary"><p>A C/C++ routine type. Conceptually, this is what results from stripping  away the pointer from a function pointer type.  It can also occur in C++  code, for example the base type of <code>myRoutineType</code> in the following code:  ```  using myRoutineType = int(int);</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/SSAUtils.qll/type.SSAUtils$SSAHelper.html" class="ref-link ref-type" title="Class SSAHelper">SSAHelper</a></td><td><span class="qldoc-summary"><p>Common SSA logic for standard SSA and range-analysis SSA.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Enum.qll/type.Enum$ScopedEnum.html" class="ref-link ref-type" title="Class ScopedEnum">ScopedEnum</a></td><td><span class="qldoc-summary"><p>A C++ scoped enum, that is, an enum whose constants must be qualified with  the name of the enum. For example, the type <code>Color</code> in:  <code>enum class Color { red, blue }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Variable.qll/type.Variable$SemanticStackVariable.html" class="ref-link ref-type" title="Class SemanticStackVariable">SemanticStackVariable</a></td><td><span class="qldoc-summary"><p>A non-static local variable or parameter that is not part of an  uninstantiated template. Uninstantiated templates are purely syntax, and  only on instantiation will they be complete with information about types,  conversions, call targets, etc. For example in the following code, the  variables <code>a</code> in <code>myFunction</code> and <code>b</code> in the instantiation  <code>myTemplateFunction&lt;int&gt;</code>, but not <code>b</code> in the template  <code>myTemplateFunction&lt;T&gt;</code>:  ```  void myFunction() {    float a;  }</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$ShortType.html" class="ref-link ref-type" title="Class ShortType">ShortType</a></td><td><span class="qldoc-summary"><p>The C/C++ short types. See 4.3.  This includes <code>short</code>, <code>signed short</code>  and <code>unsigned short</code>.  <code>signed short ss;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$SignedCharType.html" class="ref-link ref-type" title="Class SignedCharType">SignedCharType</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>signed char</code> type (which is distinct from plain <code>char</code>  even when <code>char</code> is <code>signed</code> by default).  <code>signed char c, d;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/CommonType.qll/type.CommonType$Size_t.html" class="ref-link ref-type" title="Class Size_t">Size_t</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>size_t</code> type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$SizeofExprOperator.html" class="ref-link ref-type" title="Class SizeofExprOperator">SizeofExprOperator</a></td><td><span class="qldoc-summary"><p>A C/C++ sizeof expression whose operand is an expression.  <code>if (sizeof(a) == sizeof(b)) { c = (b)a; }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$SizeofOperator.html" class="ref-link ref-type" title="Class SizeofOperator">SizeofOperator</a></td><td><span class="qldoc-summary"><p>A C/C++ sizeof expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$SizeofPackOperator.html" class="ref-link ref-type" title="Class SizeofPackOperator">SizeofPackOperator</a></td><td><span class="qldoc-summary"><p>A C++11 <code>sizeof...</code> expression which determines the size of a template parameter pack.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$SizeofTypeOperator.html" class="ref-link ref-type" title="Class SizeofTypeOperator">SizeofTypeOperator</a></td><td><span class="qldoc-summary"><p>A C/C++ sizeof expression whose operand is a type name.  <code>int szlong = sizeof(int) == sizeof(long)? 4 : 8;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/implementations/Printf.qll/type.Printf$Snprintf.html" class="ref-link ref-type" title="Class Snprintf">Snprintf</a></td><td><span class="qldoc-summary"><p>The standard functions <code>snprintf</code> and <code>swprintf</code>, and their  Microsoft and glib variants.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$SpaceshipExpr.html" class="ref-link ref-type" title="Class SpaceshipExpr">SpaceshipExpr</a></td><td><span class="qldoc-summary"><p>A C++ three-way comparison operation, also known as the <em>spaceship  operation</em>.  This is specific to C++20 and later.  <code>auto c = (a &lt;=&gt; b);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/NameQualifiers.qll/type.NameQualifiers$SpecialNameQualifyingElement.html" class="ref-link ref-type" title="Class SpecialNameQualifyingElement">SpecialNameQualifyingElement</a></td><td><span class="qldoc-summary"><p>A special name-qualifying element. For example: <code>__super</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$SpecifiedType.html" class="ref-link ref-type" title="Class SpecifiedType">SpecifiedType</a></td><td><span class="qldoc-summary"><p>A type with specifiers.  <code>const int a; volatile char v;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Specifier.qll/type.Specifier$Specifier.html" class="ref-link ref-type" title="Class Specifier">Specifier</a></td><td><span class="qldoc-summary"><p>A C/C++ specifier: <code>friend</code>, <code>auto</code>, <code>register</code>, <code>static</code>, <code>extern</code>,  <code>mutable</code>, <code>inline</code>, <code>virtual</code>, or <code>explicit</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/implementations/Printf.qll/type.Printf$Sprintf.html" class="ref-link ref-type" title="Class Sprintf">Sprintf</a></td><td><span class="qldoc-summary"><p>The standard function <code>sprintf</code> and its Microsoft and glib variants.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/SSA.qll/type.SSA$SsaDefinition.html" class="ref-link ref-type" title="Class SsaDefinition">SsaDefinition</a></td><td><span class="qldoc-summary"><p>A definition of one or more SSA variables, including phi node definitions.  An <em>SSA variable</em>, as defined in the literature, is effectively the pair of  an <code>SsaDefinition d</code> and a <code>StackVariable v</code>, written <code>(d, v)</code> in this  documentation. Note that definitions and uses can be coincident due to the  presence of parameter definitions and phi nodes.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/CommonType.qll/type.CommonType$Ssize_t.html" class="ref-link ref-type" title="Class Ssize_t">Ssize_t</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>ssize_t</code> type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Variable.qll/type.Variable$StackVariable.html" class="ref-link ref-type" title="Class StackVariable">StackVariable</a></td><td><span class="qldoc-summary"><p>A C/C++ variable with <em>automatic storage duration</em>. In other words, a  function parameter or a local variable that is not static or thread-local.  For example, the variables <code>a</code> and <code>b</code> in the following code.  <code>void myFunction(int a) { int b; static int c; }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/SSA.qll/type.SSA$StandardSSA.html" class="ref-link ref-type" title="Class StandardSSA">StandardSSA</a></td><td><span class="qldoc-summary"><p>The SSA logic comes in two versions: the standard SSA and range-analysis RangeSSA.  This class provides the standard SSA logic.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Element.qll/type.Element$StaticAssert.html" class="ref-link ref-type" title="Class StaticAssert">StaticAssert</a></td><td><span class="qldoc-summary"><p>A C++11 <code>static_assert</code> or C11 <code>_Static_assert</code> construct.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$StaticCast.html" class="ref-link ref-type" title="Class StaticCast">StaticCast</a></td><td><span class="qldoc-summary"><p>A C++ <code>static_cast</code> expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Variable.qll/type.Variable$StaticLocalVariable.html" class="ref-link ref-type" title="Class StaticLocalVariable">StaticLocalVariable</a></td><td><span class="qldoc-summary"><p>A C++ local variable declared as <code>static</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Variable.qll/type.Variable$StaticStorageDurationVariable.html" class="ref-link ref-type" title="Class StaticStorageDurationVariable">StaticStorageDurationVariable</a></td><td><span class="qldoc-summary"><p>A variable whose contents always have static storage duration. This can be a  global variable, a namespace variable, a static local variable, or a static  member variable.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Specifier.qll/type.Specifier$StdAttribute.html" class="ref-link ref-type" title="Class StdAttribute">StdAttribute</a></td><td><span class="qldoc-summary"><p>An attribute introduced by the C++11 standard <code>[[name]]</code> syntax, for  example: <code>[[clang::fallthrough]]</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Namespace.qll/type.Namespace$StdNamespace.html" class="ref-link ref-type" title="Class StdNamespace">StdNamespace</a></td><td><span class="qldoc-summary"><p>The C++ <code>std::</code> namespace.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$Stmt.html" class="ref-link ref-type" title="Class Stmt">Stmt</a></td><td><span class="qldoc-summary"><p>A C/C++ statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$StmtExpr.html" class="ref-link ref-type" title="Class StmtExpr">StmtExpr</a></td><td><span class="qldoc-summary"><p>A compound statement enclosed in parentheses used as an expression (a GNU extension to C/C++).  In the example below, <code>b</code> is the return value from the compound statement.  <code>int a = ({ int b = c + d; b; });</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$StmtParent.html" class="ref-link ref-type" title="Class StmtParent">StmtParent</a></td><td><span class="qldoc-summary"><p>An element that is the parent of a statement in the C/C++ AST.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Specifier.qll/type.Specifier$StorageClassSpecifier.html" class="ref-link ref-type" title="Class StorageClassSpecifier">StorageClassSpecifier</a></td><td><span class="qldoc-summary"><p>A C/C++ storage class specifier: <code>auto</code>, <code>register</code>, <code>static</code>, <code>extern</code>,  or `mutable&quot;.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/implementations/Printf.qll/type.Printf$StringCchPrintf.html" class="ref-link ref-type" title="Class StringCchPrintf">StringCchPrintf</a></td><td><span class="qldoc-summary"><p>The Microsoft <code>StringCchPrintf</code> function and variants.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Literal.qll/type.Literal$StringLiteral.html" class="ref-link ref-type" title="Class StringLiteral">StringLiteral</a></td><td><span class="qldoc-summary"><p>A string literal. For example:  <code>const char *s1 = &quot;abcdef&quot;; const wchar_t *s2 = L&quot;123456&quot;;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/StringAnalysis.qll/type.StringAnalysis$StrlenCall.html" class="ref-link ref-type" title="Class StrlenCall">StrlenCall</a></td><td><span class="qldoc-summary"><p>A call to a strlen like function.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Struct.qll/type.Struct$Struct.html" class="ref-link ref-type" title="Class Struct">Struct</a></td><td><span class="qldoc-summary"><p>A C/C++ structure or union. For example, the types <code>MyStruct</code> and <code>MyUnion</code>  in:  ```  struct MyStruct {    int x, y, z;  };</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/StructLikeClass.qll/type.StructLikeClass$StructLikeClass.html" class="ref-link ref-type" title="Class StructLikeClass">StructLikeClass</a></td><td><span class="qldoc-summary"><p>A class that is either a <code>struct</code> or just has getters and setters  for its members. In either case it just stores data and has no  real encapsulation.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$SubExpr.html" class="ref-link ref-type" title="Class SubExpr">SubExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ subtract expression.  <code>c = a - b;</code></p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/ObjectiveC.qll/type.ObjectiveC$SubscriptExpr.html" class="ref-link ref-type" title="Class SubscriptExpr">SubscriptExpr</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C/C++ overloaded subscripting access expression.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/ObjectiveC.qll/type.ObjectiveC$SuperMessageExpr.html" class="ref-link ref-type" title="Class SuperMessageExpr">SuperMessageExpr</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C message expression whose receiver is <code>super</code>, for example <code>[super init]</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$SwitchCase.html" class="ref-link ref-type" title="Class SwitchCase">SwitchCase</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;switch case&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$SwitchStmt.html" class="ref-link ref-type" title="Class SwitchStmt">SwitchStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;switch&rsquo; statement.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/ObjectiveC.qll/type.ObjectiveC$SynchronizedStmt.html" class="ref-link ref-type" title="Class SynchronizedStmt">SynchronizedStmt</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  An Objective C <code>@synchronized statement</code>, for example  <code>@synchronized (x) { [x complicationOperation]; }</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/implementations/Printf.qll/type.Printf$Syslog.html" class="ref-link ref-type" title="Class Syslog">Syslog</a></td><td><span class="qldoc-summary"><p>The standard function <code>syslog</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/models/interfaces/Taint.qll/type.Taint$TaintFunction.html" class="ref-link ref-type" title="Class TaintFunction">TaintFunction</a></td><td><span class="qldoc-summary"><p>A library function for which a taint-tracking library should propagate taint  from a parameter or qualifier to an output buffer, return value, or qualifier.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Class.qll/type.Class$TemplateClass.html" class="ref-link ref-type" title="Class TemplateClass">TemplateClass</a></td><td><span class="qldoc-summary"><p>A class template (this class also finds partial specializations  of class templates).  For example in the following code there is a  <code>MyTemplateClass&lt;T&gt;</code> template:  <code>template&lt;class T&gt; class MyTemplateClass { ... };</code>  Note that this does not include template instantiations, and full  specializations.  See <code>ClassTemplateInstantiation</code> and  <code>FullClassTemplateSpecialization</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Function.qll/type.Function$TemplateFunction.html" class="ref-link ref-type" title="Class TemplateFunction">TemplateFunction</a></td><td><span class="qldoc-summary"><p>A C++ function which has a non-empty template argument list. For example  the function <code>myTemplateFunction</code> in the following code:  <code>template&lt;class T&gt; void myTemplateFunction(T t) { ... }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$TemplateParameter.html" class="ref-link ref-type" title="Class TemplateParameter">TemplateParameter</a></td><td><span class="qldoc-summary"><p>A C++ <code>typename</code> (or <code>class</code>) template parameter.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$TemplateTemplateParameter.html" class="ref-link ref-type" title="Class TemplateTemplateParameter">TemplateTemplateParameter</a></td><td><span class="qldoc-summary"><p>A C++ template template parameter.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Variable.qll/type.Variable$TemplateVariable.html" class="ref-link ref-type" title="Class TemplateVariable">TemplateVariable</a></td><td><span class="qldoc-summary"><p>A C++14 variable template. For example, in the following code the variable  template <code>v</code> defines a family of variables:  <code>template&lt;class T&gt; T v;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Literal.qll/type.Literal$TextLiteral.html" class="ref-link ref-type" title="Class TextLiteral">TextLiteral</a></td><td><span class="qldoc-summary"><p>A character literal or a string literal.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$ThisExpr.html" class="ref-link ref-type" title="Class ThisExpr">ThisExpr</a></td><td><span class="qldoc-summary"><p>A C++ <code>this</code> expression.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$ThrowExpr.html" class="ref-link ref-type" title="Class ThrowExpr">ThrowExpr</a></td><td><span class="qldoc-summary"><p>A C++ <code>throw</code> expression.  <code>throw Exc(2);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Function.qll/type.Function$TopLevelFunction.html" class="ref-link ref-type" title="Class TopLevelFunction">TopLevelFunction</a></td><td><span class="qldoc-summary"><p>A C/C++ non-member function (a function that is not a member of any  class). For example the in the following code, <code>MyFunction</code> is a  <code>TopLevelFunction</code> but <code>MyMemberFunction</code> is not:  ```  void MyFunction() {    DoSomething();  }</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$TryStmt.html" class="ref-link ref-type" title="Class TryStmt">TryStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;try&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></td><td><span class="qldoc-summary"><p>A C/C++ type.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/ObjectiveC.qll/type.ObjectiveC$TypeConformingToProtocol.html" class="ref-link ref-type" title="Class TypeConformingToProtocol">TypeConformingToProtocol</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Objective-C is no longer supported.  A type which conforms to a protocol. Use <code>getAProtocol</code> to get a  protocol that this type conforms to.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/UserType.qll/type.UserType$TypeDeclarationEntry.html" class="ref-link ref-type" title="Class TypeDeclarationEntry">TypeDeclarationEntry</a></td><td><span class="qldoc-summary"><p>A particular definition or forward declaration of a C/C++ user-defined type.  <code>class C; typedef int ti;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$TypeDomain.html" class="ref-link ref-type" title="Class TypeDomain">TypeDomain</a></td><td><span class="qldoc-summary"><p>The type domain of a floating-point type. One of <code>RealDomain</code>, <code>ComplexDomain</code>, or  <code>ImaginaryDomain</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$TypeMention.html" class="ref-link ref-type" title="Class TypeMention">TypeMention</a></td><td><span class="qldoc-summary"><p>A source code location referring to a type</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Access.qll/type.Access$TypeName.html" class="ref-link ref-type" title="Class TypeName">TypeName</a></td><td><span class="qldoc-summary"><p>An access to a type.  This occurs in certain contexts where a built-in  works on types directly rather than variables, expressions etc.  For  example the reference to <code>MyClass</code> in <code>__is_pod</code> in the following code:  ```  class MyClass {    &hellip;  };</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/TypedefType.qll/type.TypedefType$TypedefType.html" class="ref-link ref-type" title="Class TypedefType">TypedefType</a></td><td><span class="qldoc-summary"><p>A C/C++ typedef type. See 4.9.1.  For example the types declared on each line of the following code:  <code>typedef int my_int; using my_int2 = int;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$TypeidOperator.html" class="ref-link ref-type" title="Class TypeidOperator">TypeidOperator</a></td><td><span class="qldoc-summary"><p>A C++ <code>typeid</code> expression which provides run-time type information (RTTI)  about its argument.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/CommonType.qll/type.CommonType$Uintmax_t.html" class="ref-link ref-type" title="Class Uintmax_t">Uintmax_t</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>uintmax_t</code> type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$UnaryArithmeticOperation.html" class="ref-link ref-type" title="Class UnaryArithmeticOperation">UnaryArithmeticOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ unary arithmetic operation.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BitwiseOperation.qll/type.BitwiseOperation$UnaryBitwiseOperation.html" class="ref-link ref-type" title="Class UnaryBitwiseOperation">UnaryBitwiseOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ unary bitwise operation.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/LogicalOperation.qll/type.LogicalOperation$UnaryLogicalOperation.html" class="ref-link ref-type" title="Class UnaryLogicalOperation">UnaryLogicalOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ unary logical operation.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$UnaryMinusExpr.html" class="ref-link ref-type" title="Class UnaryMinusExpr">UnaryMinusExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ unary minus expression.  <code>b = - a;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Expr.qll/type.Expr$UnaryOperation.html" class="ref-link ref-type" title="Class UnaryOperation">UnaryOperation</a></td><td><span class="qldoc-summary"><p>A C/C++ unary operation.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$UnaryPlusExpr.html" class="ref-link ref-type" title="Class UnaryPlusExpr">UnaryPlusExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ unary plus expression.  <code>b = + a;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Union.qll/type.Union$Union.html" class="ref-link ref-type" title="Class Union">Union</a></td><td><span class="qldoc-summary"><p>A C/C++ union. See C.8.2. For example, the type <code>MyUnion</code> in:  <code>union MyUnion { int i; float f; };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Location.qll/type.Location$UnknownDefaultLocation.html" class="ref-link ref-type" title="Class UnknownDefaultLocation">UnknownDefaultLocation</a></td><td><span class="qldoc-summary"><p>A dummy location which is used when something doesn&rsquo;t have a location in  the source code but needs to have a <code>Location</code> associated with it.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Location.qll/type.Location$UnknownExprLocation.html" class="ref-link ref-type" title="Class UnknownExprLocation">UnknownExprLocation</a></td><td><span class="qldoc-summary"><p>A dummy location which is used when an expression doesn&rsquo;t have a  location in the source code but needs to have a <code>Location</code> associated  with it.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Location.qll/type.Location$UnknownLocation.html" class="ref-link ref-type" title="Class UnknownLocation">UnknownLocation</a></td><td><span class="qldoc-summary"><p>A dummy location which is used when something doesn&rsquo;t have a location in  the source code but needs to have a <code>Location</code> associated with it. There  may be several distinct kinds of unknown locations. For example: one for  expressions, one for statements and one for other program elements.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Location.qll/type.Location$UnknownStmtLocation.html" class="ref-link ref-type" title="Class UnknownStmtLocation">UnknownStmtLocation</a></td><td><span class="qldoc-summary"><p>A dummy location which is used when a statement doesn&rsquo;t have a location  in the source code but needs to have a <code>Location</code> associated with it.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$UnknownType.html" class="ref-link ref-type" title="Class UnknownType">UnknownType</a></td><td><span class="qldoc-summary"><p>The unknown type.  This type has no corresponding C/C++ syntax.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$UnsignedCharType.html" class="ref-link ref-type" title="Class UnsignedCharType">UnsignedCharType</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>unsigned char</code> type (which is distinct from plain <code>char</code>  even when <code>char</code> is <code>unsigned</code> by default).  <code>unsigned char e, f;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/DefinitionsAndUses.qll/type.DefinitionsAndUses$Use.html" class="ref-link ref-type" title="Class Use">Use</a></td><td><span class="qldoc-summary"><p>A use of a stack variable.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/Printf.qll/type.Printf$UserDefinedFormattingFunction.html" class="ref-link ref-type" title="Class UserDefinedFormattingFunction">UserDefinedFormattingFunction</a></td><td><span class="qldoc-summary"><p>A function not in the standard library which takes a <code>printf</code>-like formatting  string and a variable number of arguments.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></td><td><span class="qldoc-summary"><p>A C/C++ user-defined type. Examples include <code>class</code>, <code>struct</code>, <code>union</code>,  <code>enum</code> and <code>typedef</code> types.  <code>enum e1 { val1, val2 } b; enum class e2: short { val3, val4 } c; typedef int my_int; class C { int a, b; };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/TypedefType.qll/type.TypedefType$UsingAliasTypedefType.html" class="ref-link ref-type" title="Class UsingAliasTypedefType">UsingAliasTypedefType</a></td><td><span class="qldoc-summary"><p>A using alias C++ typedef type.  For example the type declared in the following code:  <code>using my_int2 = int;</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Namespace.qll/type.Namespace$UsingDeclarationEntry.html" class="ref-link ref-type" title="Class UsingDeclarationEntry">UsingDeclarationEntry</a></td><td><span class="qldoc-summary"><p>A C++ <code>using</code> declaration. For example:</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Namespace.qll/type.Namespace$UsingDirectiveEntry.html" class="ref-link ref-type" title="Class UsingDirectiveEntry">UsingDirectiveEntry</a></td><td><span class="qldoc-summary"><p>A C++ <code>using</code> directive. For example:</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Namespace.qll/type.Namespace$UsingEntry.html" class="ref-link ref-type" title="Class UsingEntry">UsingEntry</a></td><td><span class="qldoc-summary"><p>A C++ <code>using</code> directive or <code>using</code> declaration.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$UuidofOperator.html" class="ref-link ref-type" title="Class UuidofOperator">UuidofOperator</a></td><td><span class="qldoc-summary"><p>A Microsoft C/C++ <code>__uuidof</code> expression that returns the UUID of a type, as  specified by the <code>__declspec(uuid)</code> attribute.  <code>struct UUID { char a[16]; }; struct __declspec(uuid(&quot;{01234567-89ab-cdef-0123-456789ABCDEF}&quot;)) S {}; UUID uuid = __uuidof(S);</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$VacuousDestructorCall.html" class="ref-link ref-type" title="Class VacuousDestructorCall">VacuousDestructorCall</a></td><td><span class="qldoc-summary"><p>An expression that looks like a destructor call, but has no effect.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Access.qll/type.Access$ValueFieldAccess.html" class="ref-link ref-type" title="Class ValueFieldAccess">ValueFieldAccess</a></td><td><span class="qldoc-summary"><p>A field access of the form <code>obj.field</code>, where the type of <code>obj</code> is a  class/struct/union (and not a reference). For example the accesses to <code>x</code>  in <code>myMethod</code> in the following code:  ```  class MyClass {  public:    void myMethod(MyClass a, MyClass &amp;b) {      a.x = b.y;    }</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$VarArgsExpr.html" class="ref-link ref-type" title="Class VarArgsExpr">VarArgsExpr</a></td><td><span class="qldoc-summary"><p>A C/C++ built-in operation that is used to support functions with variable numbers of arguments.  This includes <code>va_start</code>, <code>va_end</code>, <code>va_copy</code>, and <code>va_arg</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Variable.qll/type.Variable$Variable.html" class="ref-link ref-type" title="Class Variable">Variable</a></td><td><span class="qldoc-summary"><p>A C/C++ variable. For example, in the following code there are four  variables, <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code>:  ```  extern int a;  int a;</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Access.qll/type.Access$VariableAccess.html" class="ref-link ref-type" title="Class VariableAccess">VariableAccess</a></td><td><span class="qldoc-summary"><p>A C/C++ variable access expression. For example the accesses to  <code>x</code> and <code>y</code> in <code>myFunction</code> in the following code:  ```  int x;</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Call.qll/type.Call$VariableCall.html" class="ref-link ref-type" title="Class VariableCall">VariableCall</a></td><td><span class="qldoc-summary"><p>A C/C++ call which is performed through a variable of function pointer type.  <code>int call_via_ptr(int (*pfn)(int)) { return pfn(5); }</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Variable.qll/type.Variable$VariableDeclarationEntry.html" class="ref-link ref-type" title="Class VariableDeclarationEntry">VariableDeclarationEntry</a></td><td><span class="qldoc-summary"><p>A particular declaration or definition of a C/C++ variable. For example, in  the following code there are six variable declaration entries - two each for  <code>a</code> and <code>d</code>, and one each for <code>b</code> and <code>c</code>:  ```  extern int a;  int a;</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Literal.qll/type.Literal$VectorAggregateLiteral.html" class="ref-link ref-type" title="Class VectorAggregateLiteral">VectorAggregateLiteral</a></td><td><span class="qldoc-summary"><p>A C/C++ aggregate literal that initializes a GNU vector type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$VectorFillOperation.html" class="ref-link ref-type" title="Class VectorFillOperation">VectorFillOperation</a></td><td><span class="qldoc-summary"><p>Fill operation on a vector. This is a GNU extension.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Class.qll/type.Class$VirtualBaseClass.html" class="ref-link ref-type" title="Class VirtualBaseClass">VirtualBaseClass</a></td><td><span class="qldoc-summary"><p>A class/struct that is the base of some virtual class derivation.  For  example <code>MyBaseClass</code> in the following code is a <code>VirtualBaseClass</code> of  <code>MyClass</code>:  ```  class MyBaseClass {   &hellip;  };</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Class.qll/type.Class$VirtualClassDerivation.html" class="ref-link ref-type" title="Class VirtualClassDerivation">VirtualClassDerivation</a></td><td><span class="qldoc-summary"><p>A class/struct derivation that is virtual.  For example the derivation in  the following code is a <code>VirtualClassDerivation</code>:  <code>class MyClass : public virtual MyBaseClass { ... };</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/MemberFunction.qll/type.MemberFunction$VirtualFunction.html" class="ref-link ref-type" title="Class VirtualFunction">VirtualFunction</a></td><td><span class="qldoc-summary"><p>A C++ virtual function. For example the two functions called  <code>myVirtualFunction</code> in the following code are each a  <code>VirtualFunction</code>:  ```  class A {  public:    virtual void myVirtualFunction() = 0;  };</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$VlaDeclStmt.html" class="ref-link ref-type" title="Class VlaDeclStmt">VlaDeclStmt</a></td><td><span class="qldoc-summary"><p>A C99 statement which declares a variable length array. For example  the variable length array declaration in the following code:  <code>int myArray[x];</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$VlaDimensionStmt.html" class="ref-link ref-type" title="Class VlaDimensionStmt">VlaDimensionStmt</a></td><td><span class="qldoc-summary"><p>A C99 statement which computes the size of a single dimension of a  variable length array. For example the variable length array dimension  (<code>x</code>) in the following code:  <code>int myArray[x];</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/type.Cast$VoidConversion.html" class="ref-link ref-type" title="Class VoidConversion">VoidConversion</a></td><td><span class="qldoc-summary"><p>A conversion to <code>void</code>.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/CommonType.qll/type.CommonType$VoidPointerType.html" class="ref-link ref-type" title="Class VoidPointerType">VoidPointerType</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>void*</code> type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$VoidType.html" class="ref-link ref-type" title="Class VoidType">VoidType</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>void</code> type. See 4.7.  <code>void foo();</code></p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/commons/CommonType.qll/type.CommonType$Wchar_t.html" class="ref-link ref-type" title="Class Wchar_t">Wchar_t</a></td><td><span class="qldoc-summary"><p>The C/C++ <code>wchar_t</code> type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$WhileStmt.html" class="ref-link ref-type" title="Class WhileStmt">WhileStmt</a></td><td><span class="qldoc-summary"><p>A C/C++ &lsquo;while&rsquo; statement.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/Type.qll/type.Type$WideCharType.html" class="ref-link ref-type" title="Class WideCharType">WideCharType</a></td><td><span class="qldoc-summary"><p>The C/C++ wide character type.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/XML.qll/type.XML$XMLAttribute.html" class="ref-link ref-type" title="Class XMLAttribute">XMLAttribute</a></td><td><span class="qldoc-summary"><p>An attribute that occurs inside an XML element.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/XML.qll/type.XML$XMLCharacters.html" class="ref-link ref-type" title="Class XMLCharacters">XMLCharacters</a></td><td><span class="qldoc-summary"><p>A sequence of characters that occurs between opening and  closing tags of an XML element, excluding other elements.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/XML.qll/type.XML$XMLComment.html" class="ref-link ref-type" title="Class XMLComment">XMLComment</a></td><td><span class="qldoc-summary"><p>A comment in an XML file.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/XML.qll/type.XML$XMLDTD.html" class="ref-link ref-type" title="Class XMLDTD">XMLDTD</a></td><td><span class="qldoc-summary"><p>An XML document type definition (DTD).</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/XML.qll/type.XML$XMLElement.html" class="ref-link ref-type" title="Class XMLElement">XMLElement</a></td><td><span class="qldoc-summary"><p>An XML element in an XML file.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/XML.qll/type.XML$XMLFile.html" class="ref-link ref-type" title="Class XMLFile">XMLFile</a></td><td><span class="qldoc-summary"><p>An XML file.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/XML.qll/type.XML$XMLLocatable.html" class="ref-link ref-type" title="Class XMLLocatable">XMLLocatable</a></td><td><span class="qldoc-summary"><p>An XML element that has a location.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/XML.qll/type.XML$XMLNamespace.html" class="ref-link ref-type" title="Class XMLNamespace">XMLNamespace</a></td><td><span class="qldoc-summary"><p>A namespace used in an XML file.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/XML.qll/type.XML$XMLParent.html" class="ref-link ref-type" title="Class XMLParent">XMLParent</a></td><td><span class="qldoc-summary"><p>An <code>XMLParent</code> is either an <code>XMLElement</code> or an <code>XMLFile</code>,  both of which can contain other elements.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/Nullness.qll/type.Nullness$Zero.html" class="ref-link ref-type" title="Class Zero">Zero</a></td><td><span class="qldoc-summary"><p>A C/C++ literal whose value is zero.</p>
</span></td></tr></tbody></table></div></div><div><h2 class="subsection-heading" id="Modules">Modules</h2><div class="doc-block"><table><tbody><tr><td><a href="../semmle/code/cpp/exprs/Cast.qll/module.Cast$CastConsistency.html" class="ref-link ref-module" title="Module CastConsistency">CastConsistency</a></td><td><span class="qldoc-summary"><p>INTERNAL: Do not use.  Query predicates used to check invariants that should hold for all <code>Cast</code>  nodes. To run all consistency queries for the ASTs, including the ones below,  run &ldquo;semmle/code/cpp/ASTConsistency.ql&rdquo;.</p>
</span></td></tr></tbody></table></div></div><div><h2 class="subsection-heading" id="Aliases">Aliases</h2><div class="doc-block"><table><tbody><tr><td><span class="deprecated"><a href="../semmle/code/cpp/stmts/Block.qll/type.Block$BlockStmt.html" class="ref-link ref-type" title="Class Block">Block</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: This is now called <code>BlockStmt</code> to avoid confusion with  <code>BasicBlock</code>.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationBuiltInTypesCompatibleP.html" class="ref-link ref-type" title="Class BuiltInOperationBuiltInTypes">BuiltInOperationBuiltInTypes</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Use <code>BuiltInOperationBuiltInTypesCompatibleP</code> instead.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="../semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInOperationBuiltInOffsetOf.html" class="ref-link ref-type" title="Class BuiltInOperationOffsetOf">BuiltInOperationOffsetOf</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: Use <code>BuiltInOperationBuiltInOffsetOf</code> instead.</p>
</span></td></tr><tr><td><a href="../semmle/code/cpp/controlflow/BasicBlocks.qll/predicate.BasicBlocks$Cached$bb_successor_cached.2.html" class="ref-link ref-predicate" title="Predicate Cached::bb_successor">bb_successor</a></td><td><span class="qldoc-summary"><p>Successor relation for basic blocks.</p>
</span></td></tr></tbody></table></div></div></div></div></div><footer id="content-footer">Copyright 2020 GitHub Software UK Ltd.<a title="Privacy statement and tracking preferences" target="_blank" href="https://docs.github.com/github/site-policy/github-privacy-statement">Privacy Statement</a></footer></body></html>