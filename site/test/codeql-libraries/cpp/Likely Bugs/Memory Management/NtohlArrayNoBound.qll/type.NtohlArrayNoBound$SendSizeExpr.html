<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="qldoc"><meta name="description" content="API documentation for CodeQL"><meta name="keywords" content="CodeQL,QL,SendSizeExpr"><meta name="addsearch-category" content="C/C++ CodeQL library"><title>SendSizeExpr</title><link rel="stylesheet" type="text/css" href="https://unpkg.com/@primer/css/dist/primer.css"><link rel="stylesheet" type="text/css" href="../../../qldoc.css"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-5Q9DBRM');</script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q9DBRM" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="Header text-white"><div class="Header-item"><svg class="octicon octicon-mark-github mr-2" height="32" viewbox="0 0 16 16" width="32"><path fill-rule="even-odd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg></div><div class="Header-item--full f2 text-bold">CodeQL library for C/C++</div><div class="Header-item"><span>Version 1.26.0</span></div><div class="Header-item .text-gray-light"><div class="nav-section"><a href="../../../index.html">Index</a></div></div><div class="Header-item"><a title="Search the CodeQL libraries" target="_blank" href="https://help.semmle.com/home/help/search-results-qldoc.html"><span class=".text-gray-light">Search</span></a></div></div><div id="main"><nav id="sidebar"><div id="sidebar-content" class="pt-2"><div class="nav-section"><p>For other CodeQL resources, including tutorials and examples, see <a href="https://help.semmle.com/QL/learn-ql/" class="learn-ql-link" target="_blank">Learning CodeQL</a><p>.</p></p><h2 class="section-heading"><a href="type.NtohlArrayNoBound$SendSizeExpr.html" class="ref-link ref-type">SendSizeExpr</a></h2><div class="doc-block"><ol class="section-links"><li></li><li></li><li><a href="type.NtohlArrayNoBound$SendSizeExpr.html#Import%20path">Import path</a></li><li><a href="type.NtohlArrayNoBound$SendSizeExpr.html#Direct%20supertypes">Direct supertypes</a></li><li><a href="type.NtohlArrayNoBound$SendSizeExpr.html#Indirect%20supertypes">Indirect supertypes</a></li><li><a href="type.NtohlArrayNoBound$SendSizeExpr.html#Predicates">Predicates</a></li><li><a href="type.NtohlArrayNoBound$SendSizeExpr.html#Inherited%20predicates">Inherited predicates</a></li><li><a href="type.NtohlArrayNoBound$SendSizeExpr.html#Charpred">Charpred</a></li></ol></div></div><div class="nav-section"><div><div><h2 class="section-heading"><span>Module <a href="module.NtohlArrayNoBound.html" class="ref-link ref-module" title="Module NtohlArrayNoBound">NtohlArrayNoBound</a></span></h2></div><div><h3 class="subsection-heading">Imports</h3><div class="doc-block"><table><tbody><tr><td><a href="../../../semmle/code/cpp/dataflow/DataFlow.qll/module.DataFlow.html" class="ref-link ref-module" title="Module DataFlow">DataFlow</a></td></tr><tr><td><a href="../../../semmle/code/cpp/valuenumbering/GlobalValueNumbering.qll/module.GlobalValueNumbering.html" class="ref-link ref-module" title="Module GlobalValueNumbering">GlobalValueNumbering</a></td></tr><tr><td><a href="../../../semmle/code/cpp/controlflow/Guards.qll/module.Guards.html" class="ref-link ref-module" title="Module Guards">Guards</a></td></tr><tr><td><a href="../../../cpp.qll/module.cpp.html" class="ref-link ref-module" title="Module cpp">cpp</a></td></tr></tbody></table></div></div><div><h3 class="subsection-heading">Classes</h3><div class="doc-block"><table><tbody><tr><td><a href="type.NtohlArrayNoBound$ArrayBufferAccess.html" class="ref-link ref-type" title="Class NtohlArrayNoBound::ArrayBufferAccess">ArrayBufferAccess</a></td></tr><tr><td><a href="type.NtohlArrayNoBound$BufferAccess.html" class="ref-link ref-type" title="Class NtohlArrayNoBound::BufferAccess">BufferAccess</a></td></tr><tr><td><a href="type.NtohlArrayNoBound$MallocSizeExpr.html" class="ref-link ref-type" title="Class NtohlArrayNoBound::MallocSizeExpr">MallocSizeExpr</a></td></tr><tr><td><a href="type.NtohlArrayNoBound$MemCpy.html" class="ref-link ref-type" title="Class NtohlArrayNoBound::MemCpy">MemCpy</a></td></tr><tr><td><a href="type.NtohlArrayNoBound$MemcmpSizeExpr.html" class="ref-link ref-type" title="Class NtohlArrayNoBound::MemcmpSizeExpr">MemcmpSizeExpr</a></td></tr><tr><td><a href="type.NtohlArrayNoBound$NetworkFunctionCall.html" class="ref-link ref-type" title="Class NtohlArrayNoBound::NetworkFunctionCall">NetworkFunctionCall</a></td></tr><tr><td><a href="type.NtohlArrayNoBound$NetworkToBufferSizeConfiguration.html" class="ref-link ref-type" title="Class NtohlArrayNoBound::NetworkToBufferSizeConfiguration">NetworkToBufferSizeConfiguration</a></td></tr><tr><td><a href="type.NtohlArrayNoBound$OverloadedArrayBufferAccess.html" class="ref-link ref-type" title="Class NtohlArrayNoBound::OverloadedArrayBufferAccess">OverloadedArrayBufferAccess</a></td></tr><tr><td><a href="type.NtohlArrayNoBound$PointerArithmeticAccess.html" class="ref-link ref-type" title="Class NtohlArrayNoBound::PointerArithmeticAccess">PointerArithmeticAccess</a></td></tr><tr><td><a href="type.NtohlArrayNoBound$RecvSizeExpr.html" class="ref-link ref-type" title="Class NtohlArrayNoBound::RecvSizeExpr">RecvSizeExpr</a></td></tr><tr><td><a href="type.NtohlArrayNoBound$SendSizeExpr.html" class="ref-link ref-type" title="Class NtohlArrayNoBound::SendSizeExpr">SendSizeExpr</a></td></tr><tr><td><a href="type.NtohlArrayNoBound$SnprintfSizeExpr.html" class="ref-link ref-type" title="Class NtohlArrayNoBound::SnprintfSizeExpr">SnprintfSizeExpr</a></td></tr><tr><td><a href="type.NtohlArrayNoBound$StrncpySizeExpr.html" class="ref-link ref-type" title="Class NtohlArrayNoBound::StrncpySizeExpr">StrncpySizeExpr</a></td></tr></tbody></table></div></div></div></div></div></nav><div class="overflow-y-auto width-full pt-2"><div id="content"><div><h1 class="section-heading" id="NtohlArrayNoBound::SendSizeExpr"><span><span>Class <span><a href="type.NtohlArrayNoBound$SendSizeExpr.html" class="ref-link ref-type" title="Class NtohlArrayNoBound::SendSizeExpr">SendSizeExpr</a></span></span></span></h1></div><div><div class="doc-block"></div></div><div><h2 class="subsection-heading" id="Import path">Import path</h2><div class="doc-block"><code>import Likely_Bugs.Memory_Management.NtohlArrayNoBound</code></div></div><div><h2 class="subsection-heading" id="Direct supertypes">Direct supertypes</h2><div><div class="doc-block"><ul class="inline-list comma-list"><li><a href="type.NtohlArrayNoBound$BufferAccess.html" class="ref-link ref-type" title="Class NtohlArrayNoBound::BufferAccess">BufferAccess</a></li><li><a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></li></ul></div></div></div><div><h2 class="subsection-heading" id="Indirect supertypes">Indirect supertypes</h2><div><div class="doc-block"><ul class="inline-list comma-list"><li><a href="../../../type.@cfgnode.html" class="ref-link ref-type" title="Union type @cfgnode">@cfgnode</a></li><li><a href="../../../type.@element.html" class="ref-link ref-type" title="Union type @element">@element</a></li><li><a href="../../../type.@expr.html" class="ref-link ref-type" title="Case type @expr">@expr</a></li><li><a href="../../../type.@exprparent.html" class="ref-link ref-type" title="Union type @exprparent">@exprparent</a></li><li><a href="../../../type.@funbindexpr.html" class="ref-link ref-type" title="Union type @funbindexpr">@funbindexpr</a></li><li><a href="../../../type.@namequalifiableelement.html" class="ref-link ref-type" title="Union type @namequalifiableelement">@namequalifiableelement</a></li><li><a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$Call.html" class="ref-link ref-type" title="Class Call">Call</a></li><li><a href="../../../semmle/code/cpp/controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNode.html" class="ref-link ref-type" title="Class ControlFlowNode">ControlFlowNode</a></li><li><a href="../../../semmle/code/cpp/controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNodeBase.html" class="ref-link ref-type" title="Class ControlFlowNodeBase">ControlFlowNodeBase</a></li><li><a href="../../../semmle/code/cpp/Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></li><li><a href="../../../semmle/code/cpp/Element.qll/type.Element$ElementBase.html" class="ref-link ref-type" title="Class ElementBase">ElementBase</a></li><li><a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></li><li><a href="../../../semmle/code/cpp/Location.qll/type.Location$Locatable.html" class="ref-link ref-type" title="Class Locatable">Locatable</a></li><li><a href="../../../semmle/code/cpp/NameQualifiers.qll/type.NameQualifiers$NameQualifiableElement.html" class="ref-link ref-type" title="Class NameQualifiableElement">NameQualifiableElement</a></li><li><a href="../../../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$StmtParent.html" class="ref-link ref-type" title="Class StmtParent">StmtParent</a></li><li><a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$TCall.html" class="ref-link ref-type" title="Type TCall">TCall</a></li><li><a href="../../../semmle/code/cpp/stmts/Stmt.qll/type.Stmt$TStmtParent.html" class="ref-link ref-type" title="Type TStmtParent">TStmtParent</a></li></ul></div></div></div><div><h2 class="subsection-heading" id="Predicates">Predicates</h2><div class="doc-block"><table><tbody><tr><td><a href="predicate.NtohlArrayNoBound$SendSizeExpr$getAccessedLength.0.html" class="ref-link ref-predicate" title="Member predicate NtohlArrayNoBound::SendSizeExpr::getAccessedLength">getAccessedLength</a></td><td><span class="qldoc-summary"><p>Gets the length of the data being read or written by this buffer access.</p>
</span></td></tr><tr><td><a href="predicate.NtohlArrayNoBound$SendSizeExpr$getPointer.0.html" class="ref-link ref-predicate" title="Member predicate NtohlArrayNoBound::SendSizeExpr::getPointer">getPointer</a></td><td><span class="qldoc-summary"><p>Gets the pointer to the buffer being accessed.</p>
</span></td></tr></tbody></table></div></div><div><h2 class="subsection-heading" id="Inherited predicates">Inherited predicates</h2><div class="doc-block"><table><tbody><tr><td><a href="../../../semmle/code/cpp/Element.qll/predicate.Element$Element$findRootCause.0.html" class="ref-link ref-predicate" title="Member predicate Element::findRootCause">findRootCause</a></td><td><span class="qldoc-summary"><p>Gets the source of this element: either itself or a macro that expanded  to this element.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><span class="deprecated"><a href="../../../semmle/code/cpp/Element.qll/predicate.Element$Element$fromLibrary.0.html" class="ref-link ref-predicate" title="Member predicate Element::fromLibrary">fromLibrary</a></span></td><td><span class="qldoc-summary"><p>Holds if this element may be from a library.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/Element.qll/predicate.Element$Element$fromSource.0.html" class="ref-link ref-predicate" title="Member predicate Element::fromSource">fromSource</a></td><td><span class="qldoc-summary"><p>Holds if this element may be from source.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getAChild.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getAChild">getAChild</a></td><td><span class="qldoc-summary"><p>Gets a child of this expression.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/controlflow/ControlFlowGraph.qll/predicate.ControlFlowGraph$ControlFlowNode$getAFalseSuccessor.0.html" class="ref-link ref-predicate" title="Member predicate ControlFlowNode::getAFalseSuccessor">getAFalseSuccessor</a></td><td><span class="qldoc-summary"><p>Gets a node such that the control-flow edge <code>(this, result)</code> may be  taken when this expression is false.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNode.html" class="ref-link ref-type" title="Class ControlFlowNode">ControlFlowNode</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/controlflow/ControlFlowGraph.qll/predicate.ControlFlowGraph$ControlFlowNode$getAPredecessor.0.html" class="ref-link ref-predicate" title="Member predicate ControlFlowNode::getAPredecessor">getAPredecessor</a></td><td><span class="qldoc-summary"><p>Gets a direct predecessor of this control-flow node, if any.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNode.html" class="ref-link ref-type" title="Class ControlFlowNode">ControlFlowNode</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$getAPrimaryQlClass.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::getAPrimaryQlClass">getAPrimaryQlClass</a></td><td><span class="qldoc-summary"><p>Gets the name of a primary CodeQL class to which this element belongs.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/controlflow/ControlFlowGraph.qll/predicate.ControlFlowGraph$ControlFlowNode$getASuccessor.0.html" class="ref-link ref-predicate" title="Member predicate ControlFlowNode::getASuccessor">getASuccessor</a></td><td><span class="qldoc-summary"><p>Gets a direct successor of this control-flow node, if any.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNode.html" class="ref-link ref-type" title="Class ControlFlowNode">ControlFlowNode</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$getATemplateArgument.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::getATemplateArgument">getATemplateArgument</a></td><td><span class="qldoc-summary"><p>Gets a template argument for this call.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$getATemplateArgumentKind.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::getATemplateArgumentKind">getATemplateArgumentKind</a></td><td><span class="qldoc-summary"><p>Gets a template argument value for this call.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/controlflow/ControlFlowGraph.qll/predicate.ControlFlowGraph$ControlFlowNode$getATrueSuccessor.0.html" class="ref-link ref-predicate" title="Member predicate ControlFlowNode::getATrueSuccessor">getATrueSuccessor</a></td><td><span class="qldoc-summary"><p>Gets a node such that the control-flow edge <code>(this, result)</code> may be  taken when this expression is true.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNode.html" class="ref-link ref-type" title="Class ControlFlowNode">ControlFlowNode</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getActualType.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getActualType">getActualType</a></td><td><span class="qldoc-summary"><p>Gets the type of this expression, after any implicit conversions and explicit casts, and after resolving typedefs.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$Call$getAnArgument.0.html" class="ref-link ref-predicate" title="Member predicate Call::getAnArgument">getAnArgument</a></td><td><span class="qldoc-summary"><p>Gets an argument for this call. To get the qualifier of this call, if  any, use <code>getQualifier()</code>.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$Call.html" class="ref-link ref-type" title="Class Call">Call</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$Call$getAnArgumentSubExpr.1.html" class="ref-link ref-predicate" title="Member predicate Call::getAnArgumentSubExpr">getAnArgumentSubExpr</a></td><td><span class="qldoc-summary"><p>Gets a subexpression of the argument at position <code>index</code>. If the  argument itself contains calls, such calls will be considered  leaves in the expression tree. The qualifier of the call, if any, is not  considered to be an argument.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$Call.html" class="ref-link ref-type" title="Class Call">Call</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$getAnExplicitTemplateArgument.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::getAnExplicitTemplateArgument">getAnExplicitTemplateArgument</a></td><td><span class="qldoc-summary"><p>Gets an explicit template argument for this call.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$getAnExplicitTemplateArgumentKind.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::getAnExplicitTemplateArgumentKind">getAnExplicitTemplateArgumentKind</a></td><td><span class="qldoc-summary"><p>Gets an explicit template argument value for this call.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$Call$getArgument.1.html" class="ref-link ref-predicate" title="Member predicate Call::getArgument">getArgument</a></td><td><span class="qldoc-summary"><p>Gets the nth argument for this call.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$Call.html" class="ref-link ref-type" title="Class Call">Call</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/controlflow/ControlFlowGraph.qll/predicate.ControlFlowGraph$ControlFlowNode$getBasicBlock.0.html" class="ref-link ref-predicate" title="Member predicate ControlFlowNode::getBasicBlock">getBasicBlock</a></td><td><span class="qldoc-summary"><p>Gets the <code>BasicBlock</code> containing this control-flow node.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNode.html" class="ref-link ref-type" title="Class ControlFlowNode">ControlFlowNode</a></span></td></tr><tr><td><span class="deprecated"><a href="../../../semmle/code/cpp/Element.qll/predicate.Element$ElementBase$getCanonicalQLClass.0.html" class="ref-link ref-predicate" title="Member predicate ElementBase::getCanonicalQLClass">getCanonicalQLClass</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: use <code>getAPrimaryQlClass</code> instead.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/Element.qll/type.Element$ElementBase.html" class="ref-link ref-type" title="Class ElementBase">ElementBase</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getChild.1.html" class="ref-link ref-predicate" title="Member predicate Expr::getChild">getChild</a></td><td><span class="qldoc-summary"><p>Gets the nth child of this expression.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getControlFlowScope.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getControlFlowScope">getControlFlowScope</a></td><td><span class="qldoc-summary"><p>Gets the function containing this control-flow node.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getConversion.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getConversion">getConversion</a></td><td><span class="qldoc-summary"><p>Gets the conversion associated with this expression, if any.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getConversionString.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getConversionString">getConversionString</a></td><td><span class="qldoc-summary"><p>Gets a string describing the conversion associated with this expression,  or &quot;&quot; if there is none.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getEnclosingBlock.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getEnclosingBlock">getEnclosingBlock</a></td><td><span class="qldoc-summary"><p>Gets the nearest enclosing set of curly braces around this expression in the source, if any.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/Element.qll/predicate.Element$Element$getEnclosingElement.0.html" class="ref-link ref-predicate" title="Member predicate Element::getEnclosingElement">getEnclosingElement</a></td><td><span class="qldoc-summary"><p>Gets the closest <code>Element</code> enclosing this one.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getEnclosingFunction.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getEnclosingFunction">getEnclosingFunction</a></td><td><span class="qldoc-summary"><p>Gets the enclosing function of this expression, if any.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getEnclosingStmt.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getEnclosingStmt">getEnclosingStmt</a></td><td><span class="qldoc-summary"><p>Gets the smallest statement containing this control-flow node.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getEnclosingVariable.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getEnclosingVariable">getEnclosingVariable</a></td><td><span class="qldoc-summary"><p>Gets the enclosing variable of this expression, if any.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$getExpectedParameterType.1.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::getExpectedParameterType">getExpectedParameterType</a></td><td><span class="qldoc-summary"><p>Gets the expected type of the nth parameter of the function called by this call.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$getExpectedReturnType.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::getExpectedReturnType">getExpectedReturnType</a></td><td><span class="qldoc-summary"><p>Gets the expected return type of the function called by this call.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$getExplicitTemplateArgument.1.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::getExplicitTemplateArgument">getExplicitTemplateArgument</a></td><td><span class="qldoc-summary"><p>Gets the nth explicit template argument for this call.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$getExplicitTemplateArgumentKind.1.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::getExplicitTemplateArgumentKind">getExplicitTemplateArgumentKind</a></td><td><span class="qldoc-summary"><p>Gets the nth explicit template argument value for this call.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getExplicitlyConverted.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getExplicitlyConverted">getExplicitlyConverted</a></td><td><span class="qldoc-summary"><p>Gets this expression with all of its explicit casts, but none of its  implicit casts. More precisely this takes conversions up to the last  explicit cast (there may be implicit conversions along the way), but does  not include conversions after the last explicit cast.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/Element.qll/predicate.Element$Element$getFile.0.html" class="ref-link ref-predicate" title="Member predicate Element::getFile">getFile</a></td><td><span class="qldoc-summary"><p>Gets the primary file where this element occurs.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getFullyConverted.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getFullyConverted">getFullyConverted</a></td><td><span class="qldoc-summary"><p>Gets the fully converted form of this expression, including all type casts and other conversions.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getImplicitlyConverted.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getImplicitlyConverted">getImplicitlyConverted</a></td><td><span class="qldoc-summary"><p>Gets this expression with all of its initial implicit casts, but none of  its explicit casts. More precisely, this takes all implicit conversions  up to (but not including) the first explicit cast (if any).</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><span class="deprecated"><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getKind.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getKind">getKind</a></span></td><td><span class="qldoc-summary"><p>Gets an integer indicating the type of expression that this represents.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getLocation.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getLocation">getLocation</a></td><td><span class="qldoc-summary"><p>Gets the location of this expression.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/NameQualifiers.qll/predicate.NameQualifiers$NameQualifiableElement$getNameQualifier.0.html" class="ref-link ref-predicate" title="Member predicate NameQualifiableElement::getNameQualifier">getNameQualifier</a></td><td><span class="qldoc-summary"><p>Gets the name qualifier associated with this element. For example, the  name qualifier of <code>N::f()</code> is <code>N</code>.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/NameQualifiers.qll/type.NameQualifiers$NameQualifiableElement.html" class="ref-link ref-type" title="Class NameQualifiableElement">NameQualifiableElement</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getNumChild.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getNumChild">getNumChild</a></td><td><span class="qldoc-summary"><p>Gets the number of direct children of this expression.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$Call$getNumberOfArguments.0.html" class="ref-link ref-predicate" title="Member predicate Call::getNumberOfArguments">getNumberOfArguments</a></td><td><span class="qldoc-summary"><p>Gets the number of arguments (actual parameters) of this call. The count  does <em>not</em> include the qualifier of the call, if any.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$Call.html" class="ref-link ref-type" title="Class Call">Call</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$getNumberOfExplicitTemplateArguments.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::getNumberOfExplicitTemplateArguments">getNumberOfExplicitTemplateArguments</a></td><td><span class="qldoc-summary"><p>Gets the number of explicit template arguments for this call.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$getNumberOfTemplateArguments.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::getNumberOfTemplateArguments">getNumberOfTemplateArguments</a></td><td><span class="qldoc-summary"><p>Gets the number of template arguments for this call.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getParent.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getParent">getParent</a></td><td><span class="qldoc-summary"><p>Gets the parent of this expression, if any.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/Element.qll/predicate.Element$Element$getParentScope.0.html" class="ref-link ref-predicate" title="Member predicate Element::getParentScope">getParentScope</a></td><td><span class="qldoc-summary"><p>Gets the parent scope of this <code>Element</code>, if any.  A scope is a <code>Type</code> (<code>Class</code> / <code>Enum</code>), a <code>Namespace</code>, a <code>BlockStmt</code>, a <code>Function</code>,  or certain kinds of <code>Statement</code>.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getParentWithConversions.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getParentWithConversions">getParentWithConversions</a></td><td><span class="qldoc-summary"><p>Gets the parent of this expression, if any, in an alternative syntax tree  that has <code>Conversion</code>s as part of the tree.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$Call$getPrecedence.0.html" class="ref-link ref-predicate" title="Member predicate Call::getPrecedence">getPrecedence</a></td><td><span class="qldoc-summary"><p>Gets the precedence of the main operator of this expression;  higher precedence binds tighter.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$Call.html" class="ref-link ref-type" title="Class Call">Call</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$Call$getQualifier.0.html" class="ref-link ref-predicate" title="Member predicate Call::getQualifier">getQualifier</a></td><td><span class="qldoc-summary"><p>Gets the expression to the left of the function name or function pointer variable name.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$Call.html" class="ref-link ref-type" title="Class Call">Call</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$getTarget.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::getTarget">getTarget</a></td><td><span class="qldoc-summary"><p>Gets the function called by this call.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$getTargetType.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::getTargetType">getTargetType</a></td><td><span class="qldoc-summary"><p>Gets the <code>RoutineType</code> of the call target as visible at the call site.  For  constructor calls, this predicate instead gets the <code>Class</code> of the constructor  being called.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$getTemplateArgument.1.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::getTemplateArgument">getTemplateArgument</a></td><td><span class="qldoc-summary"><p>Gets the nth template argument for this call (indexed from 0).</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$getTemplateArgumentKind.1.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::getTemplateArgumentKind">getTemplateArgumentKind</a></td><td><span class="qldoc-summary"><p>Gets the nth template argument value for this call (indexed from 0).</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$getType.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::getType">getType</a></td><td><span class="qldoc-summary"><p>Gets the type of this expression, that is, the return type of the function being called.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getUnconverted.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getUnconverted">getUnconverted</a></td><td><span class="qldoc-summary"><p>Gets the unique non-<code>Conversion</code> expression <code>e</code> for which  <code>this = e.getConversion*()</code>.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getUnderlyingType.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getUnderlyingType">getUnderlyingType</a></td><td><span class="qldoc-summary"><p>Gets the type of this expression after typedefs have been resolved.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getUnspecifiedType.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getUnspecifiedType">getUnspecifiedType</a></td><td><span class="qldoc-summary"><p>Gets the type of this expression after specifiers have been deeply  stripped and typedefs have been resolved.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getValue.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getValue">getValue</a></td><td><span class="qldoc-summary"><p>Gets the value of this expression, if it is a constant.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getValueCategoryString.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getValueCategoryString">getValueCategoryString</a></td><td><span class="qldoc-summary"><p>Gets a string representation of the value category of the expression.  This is intended only for debugging. The possible values are:</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$getValueText.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getValueText">getValueText</a></td><td><span class="qldoc-summary"><p>Gets the source text for the value of this expression, if it is a constant.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$hasChild.2.html" class="ref-link ref-predicate" title="Member predicate Expr::hasChild">hasChild</a></td><td><span class="qldoc-summary"><p>Holds if e is the nth child of this expression.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$hasConversion.0.html" class="ref-link ref-predicate" title="Member predicate Expr::hasConversion">hasConversion</a></td><td><span class="qldoc-summary"><p>Holds if this expression has a conversion.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$hasExplicitConversion.0.html" class="ref-link ref-predicate" title="Member predicate Expr::hasExplicitConversion">hasExplicitConversion</a></td><td><span class="qldoc-summary"><p>Holds if this expression has an explicit conversion.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/NameQualifiers.qll/predicate.NameQualifiers$NameQualifiableElement$hasGlobalQualifiedName.0.html" class="ref-link ref-predicate" title="Member predicate NameQualifiableElement::hasGlobalQualifiedName">hasGlobalQualifiedName</a></td><td><span class="qldoc-summary"><p>Holds if this element has a globally qualified name. For example,  <code>::x</code> is globally qualified. It is used to refer to <code>x</code> in the global  namespace.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/NameQualifiers.qll/type.NameQualifiers$NameQualifiableElement.html" class="ref-link ref-type" title="Class NameQualifiableElement">NameQualifiableElement</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$hasImplicitConversion.0.html" class="ref-link ref-predicate" title="Member predicate Expr::hasImplicitConversion">hasImplicitConversion</a></td><td><span class="qldoc-summary"><p>Holds if this expression has an implicit conversion.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$hasImplicitTemplateArguments.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::hasImplicitTemplateArguments">hasImplicitTemplateArguments</a></td><td><span class="qldoc-summary"><p>Holds if any template arguments for this call are implicit / deduced.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$hasLValueToRValueConversion.0.html" class="ref-link ref-predicate" title="Member predicate Expr::hasLValueToRValueConversion">hasLValueToRValueConversion</a></td><td><span class="qldoc-summary"><p>Holds if this expression has undergone an <em>lvalue</em>-to-<em>rvalue</em> conversion to  extract its value.  for example:  <code>y = x;</code>  The <code>VariableAccess</code> for <code>x</code> is a <em>prvalue</em>, and <code>hasLValueToRValueConversion()</code>  holds because the value of <code>x</code> was loaded from the location of <code>x</code>.  The <code>VariableAccess</code> for <code>y</code> is an <em>lvalue</em>, and <code>hasLValueToRValueConversion()</code>  does not hold because the value of <code>y</code> was not extracted.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$Call$hasQualifier.0.html" class="ref-link ref-predicate" title="Member predicate Call::hasQualifier">hasQualifier</a></td><td><span class="qldoc-summary"><p>Holds if this call has a qualifier.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$Call.html" class="ref-link ref-type" title="Class Call">Call</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/NameQualifiers.qll/predicate.NameQualifiers$NameQualifiableElement$hasSuperQualifiedName.0.html" class="ref-link ref-predicate" title="Member predicate NameQualifiableElement::hasSuperQualifiedName">hasSuperQualifiedName</a></td><td><span class="qldoc-summary"><p>Holds if this element has a <code>__super</code>-qualified name. For example:  <code>__super::get()</code>. Note: <code>__super</code> is non-standard C++ extension, only  supported by some C++ compilers.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/NameQualifiers.qll/type.NameQualifiers$NameQualifiableElement.html" class="ref-link ref-type" title="Class NameQualifiableElement">NameQualifiableElement</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$hasTemplateArgumentList.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::hasTemplateArgumentList">hasTemplateArgumentList</a></td><td><span class="qldoc-summary"><p>Holds if a template argument list was provided for this call.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/Element.qll/predicate.Element$Element$isAffectedByMacro.0.html" class="ref-link ref-predicate" title="Member predicate Element::isAffectedByMacro">isAffectedByMacro</a></td><td><span class="qldoc-summary"><p>Holds if this element is affected in any way by a macro. All elements  that are totally or partially generated by a macro are included, so  this is a super-set of <code>isInMacroExpansion</code>.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$isCompilerGenerated.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isCompilerGenerated">isCompilerGenerated</a></td><td><span class="qldoc-summary"><p>Holds if this is an auxiliary expression generated by the compiler.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/controlflow/ControlFlowGraph.qll/predicate.ControlFlowGraph$ControlFlowNode$isCondition.0.html" class="ref-link ref-predicate" title="Member predicate ControlFlowNode::isCondition">isCondition</a></td><td><span class="qldoc-summary"><p>Holds if this node is the top-level expression of a conditional statement,  meaning that <code>this.getATrueSuccessor()</code> or <code>this.getAFalseSuccessor()</code>  will have a result.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNode.html" class="ref-link ref-type" title="Class ControlFlowNode">ControlFlowNode</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$isConstant.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isConstant">isConstant</a></td><td><span class="qldoc-summary"><p>Holds if this expression has a value that can be determined at compile time.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/Element.qll/predicate.Element$Element$isFromTemplateInstantiation.1.html" class="ref-link ref-predicate" title="Member predicate Element::isFromTemplateInstantiation">isFromTemplateInstantiation</a></td><td><span class="qldoc-summary"><p>Holds if this <code>Element</code> is a part of a template instantiation (but not  the template itself).</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/Element.qll/predicate.Element$Element$isFromUninstantiatedTemplate.1.html" class="ref-link ref-predicate" title="Member predicate Element::isFromUninstantiatedTemplate">isFromUninstantiatedTemplate</a></td><td><span class="qldoc-summary"><p>Holds if this <code>Element</code> is part of a template <code>template</code> (not if it is  part of an instantiation of <code>template</code>). This means it is represented in  the database purely as syntax and without guarantees on the presence or  correctness of type-based operations such as implicit conversions.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$isGLValueCategory.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isGLValueCategory">isGLValueCategory</a></td><td><span class="qldoc-summary"><p>Holds if this expression is a <em>glvalue</em>. A <em>glvalue</em> is either an <em>lvalue</em> or an  <em>xvalue</em>.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/Element.qll/predicate.Element$Element$isInMacroExpansion.0.html" class="ref-link ref-predicate" title="Member predicate Element::isInMacroExpansion">isInMacroExpansion</a></td><td><span class="qldoc-summary"><p>Holds if this element comes from a macro expansion. Only elements that  are entirely generated by a macro are included - for elements that  partially come from a macro, see <code>isAffectedByMacro</code>.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$isLValue.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isLValue">isLValue</a></td><td><span class="qldoc-summary"><p>Holds if this expression is an <em>lvalue</em>, in the sense of having an address.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$isLValueCategory.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isLValueCategory">isLValueCategory</a></td><td><span class="qldoc-summary"><p>Holds if this expression is an <em>lvalue</em>. An <em>lvalue</em> is an expression that  represents a location, rather than a value.  See [basic.lval] for more about lvalues.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$isOnlyFoundByADL.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::isOnlyFoundByADL">isOnlyFoundByADL</a></td><td><span class="qldoc-summary"><p>Holds if the target of this function call was found by argument-dependent lookup and wouldn&rsquo;t have been  found by any other means.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$isPRValueCategory.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isPRValueCategory">isPRValueCategory</a></td><td><span class="qldoc-summary"><p>Holds if this expression is a <em>prvalue</em>. A <em>prvalue</em> is an expression that  represents a value, rather than a location.  See [basic.lval] for more about prvalues.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$isParenthesised.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isParenthesised">isParenthesised</a></td><td><span class="qldoc-summary"><p>Holds if this expression is parenthesised.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$isPure.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isPure">isPure</a></td><td><span class="qldoc-summary"><p>Holds if this expression is side-effect free (conservative  approximation). This predicate cannot be overridden;  override mayBeImpure() instead.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$isRValueCategory.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isRValueCategory">isRValueCategory</a></td><td><span class="qldoc-summary"><p>Holds if this expression is an <em>rvalue</em>. An <em>rvalue</em> is either a <em>prvalue</em> or an  <em>xvalue</em>.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$isUnevaluated.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isUnevaluated">isUnevaluated</a></td><td><span class="qldoc-summary"><p>Holds if this expression will not be evaluated because of its context,  such as an expression inside a sizeof.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$isVirtual.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::isVirtual">isVirtual</a></td><td><span class="qldoc-summary"><p>Holds if this is a call to a virtual function.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Expr.qll/predicate.Expr$Expr$isXValueCategory.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isXValueCategory">isXValueCategory</a></td><td><span class="qldoc-summary"><p>Holds if this expression is an <em>xvalue</em>. An <em>xvalue</em> is a location whose  lifetime is about to end (e.g. an <em>rvalue</em> reference returned from a function  call).  See [basic.lval] for more about xvalues.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$mayBeGloballyImpure.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::mayBeGloballyImpure">mayBeGloballyImpure</a></td><td><span class="qldoc-summary"><p>Holds if it is possible that the expression may be impure. If we are not  sure, then it holds. Unlike <code>mayBeImpure()</code>, this predicate does not  consider modifications to temporary local variables to be impure. If you  call a function in which nothing may be globally impure then the function  as a whole will have no side-effects, even if it mutates its own fresh  stack variables.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$mayBeImpure.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::mayBeImpure">mayBeImpure</a></td><td><span class="qldoc-summary"><p>Holds if it is possible that the expression may be impure. If we are not  sure, then it holds.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$Call$passesByReference.2.html" class="ref-link ref-predicate" title="Member predicate Call::passesByReference">passesByReference</a></td><td><span class="qldoc-summary"><p>Holds if this call passes the variable accessed by <code>va</code> by  reference as the <code>i</code>th argument. The qualifier of a call to a member  function is <code>i = -1</code>.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$Call.html" class="ref-link ref-type" title="Class Call">Call</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$Call$passesByReferenceNonConst.2.html" class="ref-link ref-predicate" title="Member predicate Call::passesByReferenceNonConst">passesByReferenceNonConst</a></td><td><span class="qldoc-summary"><p>Holds if this call passes the variable accessed by <code>va</code> by  reference to non-const data as the <code>i</code>th argument. The qualifier of a  call to a member function is <code>i = -1</code>.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$Call.html" class="ref-link ref-type" title="Class Call">Call</a></span></td></tr><tr><td><a href="../../../semmle/code/cpp/exprs/Call.qll/predicate.Call$FunctionCall$toString.0.html" class="ref-link ref-predicate" title="Member predicate FunctionCall::toString">toString</a></td><td><span class="qldoc-summary"><p>Gets a textual representation of this function call.</p>
</span></td><td><span>from <a href="../../../semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html" class="ref-link ref-type" title="Class FunctionCall">FunctionCall</a></span></td></tr></tbody></table></div></div><div><h2 class="subsection-heading" id="Charpred">Charpred</h2><div class="doc-block"><table><tbody><tr><td><a href="predicate.NtohlArrayNoBound$SendSizeExpr$SendSizeExpr.0.html" class="ref-link ref-predicate" title="Characteristic predicate NtohlArrayNoBound::SendSizeExpr::SendSizeExpr">SendSizeExpr</a></td><td></td></tr></tbody></table></div></div></div></div></div><footer id="content-footer">Copyright 2020 GitHub Software UK Ltd.<a title="Privacy statement and tracking preferences" target="_blank" href="https://docs.github.com/github/site-policy/github-privacy-statement">Privacy Statement</a></footer></body></html>