<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="qldoc"><meta name="description" content="API documentation for CodeQL"><meta name="keywords" content="CodeQL,QL,NarrowingCastInstruction"><meta name="addsearch-category" content="C# CodeQL library"><title>NarrowingCastInstruction</title><link rel="stylesheet" type="text/css" href="https://unpkg.com/@primer/css/dist/primer.css"><link rel="stylesheet" type="text/css" href="../../../../qldoc.css"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-5Q9DBRM');</script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q9DBRM" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="Header text-white"><div class="Header-item"><svg class="octicon octicon-mark-github mr-2" height="32" viewbox="0 0 16 16" width="32"><path fill-rule="even-odd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg></div><div class="Header-item--full f2 text-bold">CodeQL library for C#</div><div class="Header-item"><span>Version 1.26.0</span></div><div class="Header-item .text-gray-light"><div class="nav-section"><a href="../../../../index.html">Index</a></div></div><div class="Header-item"><a title="Search the CodeQL libraries" target="_blank" href="https://help.semmle.com/home/help/search-results-qldoc.html"><span class=".text-gray-light">Search</span></a></div></div><div id="main"><nav id="sidebar"><div id="sidebar-content" class="pt-2"><div class="nav-section"><p>For other CodeQL resources, including tutorials and examples, see <a href="https://help.semmle.com/QL/learn-ql/" class="learn-ql-link" target="_blank">Learning CodeQL</a><p>.</p></p><h2 class="section-heading"><a href="type.RangeAnalysis$NarrowingCastInstruction.html" class="ref-link ref-type">NarrowingCastInstruction</a></h2><div class="doc-block"><ol class="section-links"><li></li><li></li><li><a href="type.RangeAnalysis$NarrowingCastInstruction.html#Import%20path">Import path</a></li><li><a href="type.RangeAnalysis$NarrowingCastInstruction.html#Direct%20supertypes">Direct supertypes</a></li><li><a href="type.RangeAnalysis$NarrowingCastInstruction.html#Indirect%20supertypes">Indirect supertypes</a></li><li><a href="type.RangeAnalysis$NarrowingCastInstruction.html#Predicates">Predicates</a></li><li><a href="type.RangeAnalysis$NarrowingCastInstruction.html#Inherited%20predicates">Inherited predicates</a></li><li><a href="type.RangeAnalysis$NarrowingCastInstruction.html#Charpred">Charpred</a></li></ol></div></div><div class="nav-section"><div><div><h2 class="section-heading"><span>Module <a href="module.RangeAnalysis.html" class="ref-link ref-module" title="Module RangeAnalysis">RangeAnalysis</a></span></h2></div><div><h3 class="subsection-heading">Imports</h3><div class="doc-block"><table><tbody><tr><td><a href="../Bound.qll/module.Bound.html" class="ref-link ref-module" title="Module Bound">Bound</a></td></tr><tr><td><a href="module.RangeAnalysis$RangeAnalysisCache$RangeAnalysisPublic.html" class="ref-link ref-module" title="Module RangeAnalysis::RangeAnalysisCache::RangeAnalysisPublic">RangeAnalysisPublic</a></td></tr><tr><td><a href="../../../../csharp.qll/module.csharp.html" class="ref-link ref-module" title="Module csharp">csharp</a></td></tr></tbody></table></div></div><div><h3 class="subsection-heading">Classes</h3><div class="doc-block"><table><tbody><tr><td><a href="type.RangeAnalysis$CondReason.html" class="ref-link ref-type" title="Class RangeAnalysis::CondReason">CondReason</a></td></tr><tr><td><a href="type.RangeAnalysis$NoReason.html" class="ref-link ref-type" title="Class RangeAnalysis::NoReason">NoReason</a></td></tr><tr><td><a href="type.RangeAnalysis$Reason.html" class="ref-link ref-type" title="Class RangeAnalysis::Reason">Reason</a></td></tr></tbody></table></div></div></div></div></div></nav><div class="overflow-y-auto width-full pt-2"><div id="content"><div><h1 class="section-heading" id="RangeAnalysis::NarrowingCastInstruction"><span><span>Class <span><a href="type.RangeAnalysis$NarrowingCastInstruction.html" class="ref-link ref-type" title="Class RangeAnalysis::NarrowingCastInstruction">NarrowingCastInstruction</a></span></span></span></h1></div><div><div class="doc-block"><div class="qldoc"><p>A cast to a small integral type that may overflow or underflow.</p>
</div></div></div><div><h2 class="subsection-heading" id="Import path">Import path</h2><div class="doc-block"><code>import experimental.ir.rangeanalysis.RangeAnalysis</code></div></div><div><h2 class="subsection-heading" id="Direct supertypes">Direct supertypes</h2><div><div class="doc-block"><ul class="inline-list comma-list"><li><a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$ConvertInstruction.html" class="ref-link ref-type" title="Class Instruction::ConvertInstruction">ConvertInstruction</a></li></ul></div></div></div><div><h2 class="subsection-heading" id="Indirect supertypes">Indirect supertypes</h2><div><div class="doc-block"><ul class="inline-list comma-list"><li><a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></li><li><a href="../../implementation/unaliased_ssa/internal/SSAConstruction.qll/type.SSAConstruction$Cached$TStageInstruction.html" class="ref-link ref-type" title="Type SSAConstruction::Cached::TStageInstruction">TStageInstruction</a></li><li><a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$UnaryInstruction.html" class="ref-link ref-type" title="Class Instruction::UnaryInstruction">UnaryInstruction</a></li></ul></div></div></div><div><h2 class="subsection-heading" id="Predicates">Predicates</h2><div class="doc-block"><table><tbody><tr><td><a href="predicate.RangeAnalysis$NarrowingCastInstruction$getLowerBound.0.html" class="ref-link ref-predicate" title="Member predicate RangeAnalysis::NarrowingCastInstruction::getLowerBound">getLowerBound</a></td><td><span class="qldoc-summary"><p>Gets the lower bound of the resulting type.</p>
</span></td></tr><tr><td><a href="predicate.RangeAnalysis$NarrowingCastInstruction$getUpperBound.0.html" class="ref-link ref-predicate" title="Member predicate RangeAnalysis::NarrowingCastInstruction::getUpperBound">getUpperBound</a></td><td><span class="qldoc-summary"><p>Gets the upper bound of the resulting type.</p>
</span></td></tr></tbody></table></div></div><div><h2 class="subsection-heading" id="Inherited predicates">Inherited predicates</h2><div class="doc-block"><table><tbody><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getAPredecessor.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getAPredecessor">getAPredecessor</a></td><td><span class="qldoc-summary"><p>Gets all direct predecessors of this instruction.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getAST.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getAST">getAST</a></td><td><span class="qldoc-summary"><p>Gets the AST that caused this instruction to be generated.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getASuccessor.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getASuccessor">getASuccessor</a></td><td><span class="qldoc-summary"><p>Gets all direct successors of this instruction.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getAUse.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getAUse">getAUse</a></td><td><span class="qldoc-summary"><p>Gets all direct uses of the result of this instruction. The result can be  an <code>Operand</code> for which <code>isDefinitionInexact</code> holds.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getAnOperand.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getAnOperand">getAnOperand</a></td><td><span class="qldoc-summary"><p>Gets all of this instruction&rsquo;s operands.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getBackEdgeSuccessor.1.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getBackEdgeSuccessor">getBackEdgeSuccessor</a></td><td><span class="qldoc-summary"><p>Gets the a <em>back-edge successor</em> of this instruction along the control  flow edge specified by <code>kind</code>. A back edge in the control-flow graph is  intuitively the edge that goes back around a loop. If all back edges are  removed from the control-flow graph, it becomes acyclic.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getBlock.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getBlock">getBlock</a></td><td><span class="qldoc-summary"><p>Gets the basic block that contains this instruction.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getConvertedResultExpression.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getConvertedResultExpression">getConvertedResultExpression</a></td><td><span class="qldoc-summary"><p>Gets the  <code>Expr</code> whose result is computed by this instruction, if any. The <code>Expr</code> may be a  conversion.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getDisplayIndexInBlock.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getDisplayIndexInBlock">getDisplayIndexInBlock</a></td><td><span class="qldoc-summary"><p>Gets the zero-based index of this instruction within its block. This is  used by debugging and printing code only.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getDumpString.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getDumpString">getDumpString</a></td><td><span class="qldoc-summary"><p>Gets a string showing the result, opcode, and operands of the instruction, equivalent to what  would be printed by PrintIR.ql. For example:</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getEnclosingFunction.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getEnclosingFunction">getEnclosingFunction</a></td><td><span class="qldoc-summary"><p>Gets the function that contains this instruction.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getEnclosingIRFunction.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getEnclosingIRFunction">getEnclosingIRFunction</a></td><td><span class="qldoc-summary"><p>Gets the IRFunction object that contains the IR for this instruction.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getImmediateString.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getImmediateString">getImmediateString</a></td><td><span class="qldoc-summary"><p>Gets a string describing the immediate value of this instruction, if any.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getLocation.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getLocation">getLocation</a></td><td><span class="qldoc-summary"><p>Gets the location of the source code for this instruction.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getOpcode.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getOpcode">getOpcode</a></td><td><span class="qldoc-summary"><p>Gets the opcode that specifies the operation performed by this instruction.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getOperandsString.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getOperandsString">getOperandsString</a></td><td><span class="qldoc-summary"><p>Gets a string describing the operands of this instruction, suitable for  display in IR dumps.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getOperationString.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getOperationString">getOperationString</a></td><td><span class="qldoc-summary"><p>Gets a string describing the operation of this instruction. This includes  the opcode and the immediate value, if any. For example:</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getPredecessor.1.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getPredecessor">getPredecessor</a></td><td><span class="qldoc-summary"><p>Gets a predecessor of this instruction such that the predecessor reaches  this instruction along the control flow edge specified by <code>kind</code>.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getResultAddress.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getResultAddress">getResultAddress</a></td><td><span class="qldoc-summary"><p>Gets the instruction that holds the exact memory address to which this instruction stores its  result, if any. For example, in <code>m3 = Store r1, r2</code>, the result of <code>getResultAddressOperand()</code>  is the instruction that defines <code>r1</code>.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getResultAddressOperand.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getResultAddressOperand">getResultAddressOperand</a></td><td><span class="qldoc-summary"><p>Gets the operand that holds the memory address to which this instruction stores its  result, if any. For example, in <code>m3 = Store r1, r2</code>, the result of <code>getResultAddressOperand()</code>  is <code>r1</code>.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getResultIRType.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getResultIRType">getResultIRType</a></td><td><span class="qldoc-summary"><p>Gets the type of the result produced by this instruction. If the instruction does not produce  a result, its result type will be <code>IRVoidType</code>.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getResultId.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getResultId">getResultId</a></td><td><span class="qldoc-summary"><p>Gets a human-readable string that uniquely identifies this instruction  within the function. This string is used to refer to this instruction when  printing IR dumps.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getResultLanguageType.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getResultLanguageType">getResultLanguageType</a></td><td><span class="qldoc-summary"><p>Gets the language-specific type of the result produced by this instruction.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getResultMemoryAccess.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getResultMemoryAccess">getResultMemoryAccess</a></td><td><span class="qldoc-summary"><p>Gets the kind of memory access performed by this instruction&rsquo;s result.  Holds only for instructions with a memory result.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getResultSize.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getResultSize">getResultSize</a></td><td><span class="qldoc-summary"><p>Gets the size of the result produced by this instruction, in bytes. If the  result does not have a known constant size, this predicate does not hold.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getResultString.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getResultString">getResultString</a></td><td><span class="qldoc-summary"><p>Gets a string describing the result of this instruction, suitable for  display in IR dumps. This consists of the result ID plus the type of the  result.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getResultType.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getResultType">getResultType</a></td><td><span class="qldoc-summary"><p>Gets the type of the result produced by this instruction. If the  instruction does not produce a result, its result type will be <code>VoidType</code>.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getSuccessor.1.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getSuccessor">getSuccessor</a></td><td><span class="qldoc-summary"><p>Gets the successor of this instruction along the control flow edge  specified by <code>kind</code>.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$UnaryInstruction$getUnary.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::UnaryInstruction::getUnary">getUnary</a></td><td><span class="qldoc-summary"><p>Gets the instruction whose result provides the sole operand of this instruction.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$UnaryInstruction.html" class="ref-link ref-type" title="Class Instruction::UnaryInstruction">UnaryInstruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$UnaryInstruction$getUnaryOperand.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::UnaryInstruction::getUnaryOperand">getUnaryOperand</a></td><td><span class="qldoc-summary"><p>Gets the sole operand of this instruction.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$UnaryInstruction.html" class="ref-link ref-type" title="Class Instruction::UnaryInstruction">UnaryInstruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getUnconvertedResultExpression.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getUnconvertedResultExpression">getUnconvertedResultExpression</a></td><td><span class="qldoc-summary"><p>Gets the unconverted form of the <code>Expr</code> whose result is computed by this instruction, if any.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$getUniqueId.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::getUniqueId">getUniqueId</a></td><td><span class="qldoc-summary"><p>Gets a string identifier for this function that is unique among all  instructions in the same function.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$hasMemoryResult.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::hasMemoryResult">hasMemoryResult</a></td><td><span class="qldoc-summary"><p>Holds if this instruction produces a memory result.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$hasResultMayMemoryAccess.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::hasResultMayMemoryAccess">hasResultMayMemoryAccess</a></td><td><span class="qldoc-summary"><p>Holds if the memory access performed by this instruction&rsquo;s result will not always write to  every bit in the memory location. This is most commonly used for memory accesses that may or  may not actually occur depending on runtime state (for example, the write side effect of an  output parameter that is not written to on all paths), or for accesses where the memory  location is a conservative estimate of the memory that might actually be accessed at runtime  (for example, the global side effects of a function call).</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$isGLValue.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::isGLValue">isGLValue</a></td><td><span class="qldoc-summary"><p>Holds if the result produced by this instruction is a glvalue. If this  holds, the result of the instruction represents the address of a location,  and the type of the location is given by <code>getResultType()</code>. If this does  not hold, the result of the instruction represents a value whose type is  given by <code>getResultType()</code>.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$isResultConflated.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::isResultConflated">isResultConflated</a></td><td><span class="qldoc-summary"><p>Holds if this is an instruction with a memory result that represents a  conflation of more than one memory allocation.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$isResultModeled.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::isResultModeled">isResultModeled</a></td><td><span class="qldoc-summary"><p>Holds if the result of this instruction is precisely modeled in SSA. Always  holds for a register result. For a memory result, a modeled result is  connected to its actual uses. An unmodeled result has no uses.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr><tr><td><a href="../../implementation/unaliased_ssa/Instruction.qll/predicate.Instruction$Instruction$toString.0.html" class="ref-link ref-predicate" title="Member predicate Instruction::Instruction::toString">toString</a></td><td><span class="qldoc-summary"><p>Gets a textual representation of this element.</p>
</span></td><td><span>from <a href="../../implementation/unaliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction::Instruction">Instruction</a></span></td></tr></tbody></table></div></div><div><h2 class="subsection-heading" id="Charpred">Charpred</h2><div class="doc-block"><table><tbody><tr><td><a href="predicate.RangeAnalysis$NarrowingCastInstruction$NarrowingCastInstruction.0.html" class="ref-link ref-predicate" title="Characteristic predicate RangeAnalysis::NarrowingCastInstruction::NarrowingCastInstruction">NarrowingCastInstruction</a></td><td></td></tr></tbody></table></div></div></div></div></div><footer id="content-footer">Copyright 2020 GitHub Software UK Ltd.<a title="Privacy statement and tracking preferences" target="_blank" href="https://docs.github.com/github/site-policy/github-privacy-statement">Privacy Statement</a></footer></body></html>