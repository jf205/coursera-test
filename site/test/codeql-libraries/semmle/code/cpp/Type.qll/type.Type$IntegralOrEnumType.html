<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="qldoc"><meta name="description" content="API documentation for CodeQL"><meta name="keywords" content="CodeQL,QL,IntegralOrEnumType"><meta name="addsearch-category" content="C/C++ CodeQL library"><title>IntegralOrEnumType</title><link rel="stylesheet" type="text/css" href="https://unpkg.com/@primer/css/dist/primer.css"><link rel="stylesheet" type="text/css" href="../../../../qldoc.css"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-5Q9DBRM');</script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q9DBRM" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="Header text-white"><div class="Header-item"><svg class="octicon octicon-mark-github mr-2" height="32" viewbox="0 0 16 16" width="32"><path fill-rule="even-odd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg></div><div class="Header-item--full f2 text-bold">CodeQL library for C/C++</div><div class="Header-item"><span>Version 1.26.0</span></div><div class="Header-item .text-gray-light"><div class="nav-section"><a href="../../../../index.html">Index</a></div></div><div class="Header-item"><a title="Search the CodeQL libraries" target="_blank" href="https://help.semmle.com/home/help/search-results-qldoc.html"><span class=".text-gray-light">Search</span></a></div></div><div id="main"><nav id="sidebar"><div id="sidebar-content" class="pt-2"><div class="nav-section"><p>For other CodeQL resources, including tutorials and examples, see <a href="https://help.semmle.com/QL/learn-ql/" class="learn-ql-link" target="_blank">Learning CodeQL</a><p>.</p></p><h2 class="section-heading"><a href="type.Type$IntegralOrEnumType.html" class="ref-link ref-type">IntegralOrEnumType</a></h2><div class="doc-block"><ol class="section-links"><li></li><li></li><li><a href="type.Type$IntegralOrEnumType.html#Import%20path">Import path</a></li><li><a href="type.Type$IntegralOrEnumType.html#Direct%20supertypes">Direct supertypes</a></li><li><a href="type.Type$IntegralOrEnumType.html#Indirect%20supertypes">Indirect supertypes</a></li><li><a href="type.Type$IntegralOrEnumType.html#Known%20direct%20subtypes">Known direct subtypes</a></li><li><a href="type.Type$IntegralOrEnumType.html#Inherited%20predicates">Inherited predicates</a></li><li><a href="type.Type$IntegralOrEnumType.html#Charpred">Charpred</a></li></ol></div></div><div class="nav-section"><div><div><h2 class="section-heading"><span>Module <a href="module.Type.html" class="ref-link ref-module" title="Module Type">Type</a></span></h2></div><div><h3 class="subsection-heading">Imports</h3><div class="doc-block"><table><tbody><tr><td><a href="../Element.qll/module.Element.html" class="ref-link ref-module" title="Module Element">Element</a></td></tr><tr><td><a href="../Function.qll/module.Function.html" class="ref-link ref-module" title="Module Function">Function</a></td></tr></tbody></table></div></div><div><h3 class="subsection-heading">Classes</h3><div class="doc-block"><table><tbody><tr><td><a href="type.Type$ArithmeticType.html" class="ref-link ref-type" title="Class ArithmeticType">ArithmeticType</a></td></tr><tr><td><a href="type.Type$ArrayType.html" class="ref-link ref-type" title="Class ArrayType">ArrayType</a></td></tr><tr><td><a href="type.Type$AutoType.html" class="ref-link ref-type" title="Class AutoType">AutoType</a></td></tr><tr><td><a href="type.Type$BinaryFloatingPointType.html" class="ref-link ref-type" title="Class BinaryFloatingPointType">BinaryFloatingPointType</a></td></tr><tr><td><a href="type.Type$BlockType.html" class="ref-link ref-type" title="Class BlockType">BlockType</a></td></tr><tr><td><a href="type.Type$BoolType.html" class="ref-link ref-type" title="Class BoolType">BoolType</a></td></tr><tr><td><a href="type.Type$BuiltInType.html" class="ref-link ref-type" title="Class BuiltInType">BuiltInType</a></td></tr><tr><td><a href="type.Type$Char16Type.html" class="ref-link ref-type" title="Class Char16Type">Char16Type</a></td></tr><tr><td><a href="type.Type$Char32Type.html" class="ref-link ref-type" title="Class Char32Type">Char32Type</a></td></tr><tr><td><a href="type.Type$Char8Type.html" class="ref-link ref-type" title="Class Char8Type">Char8Type</a></td></tr><tr><td><a href="type.Type$CharType.html" class="ref-link ref-type" title="Class CharType">CharType</a></td></tr><tr><td><a href="type.Type$ComplexDomain.html" class="ref-link ref-type" title="Class ComplexDomain">ComplexDomain</a></td></tr><tr><td><a href="type.Type$ComplexNumberType.html" class="ref-link ref-type" title="Class ComplexNumberType">ComplexNumberType</a></td></tr><tr><td><a href="type.Type$Decimal128Type.html" class="ref-link ref-type" title="Class Decimal128Type">Decimal128Type</a></td></tr><tr><td><a href="type.Type$Decimal32Type.html" class="ref-link ref-type" title="Class Decimal32Type">Decimal32Type</a></td></tr><tr><td><a href="type.Type$Decimal64Type.html" class="ref-link ref-type" title="Class Decimal64Type">Decimal64Type</a></td></tr><tr><td><a href="type.Type$DecimalFloatingPointType.html" class="ref-link ref-type" title="Class DecimalFloatingPointType">DecimalFloatingPointType</a></td></tr><tr><td><a href="type.Type$Decltype.html" class="ref-link ref-type" title="Class Decltype">Decltype</a></td></tr><tr><td><a href="type.Type$DerivedType.html" class="ref-link ref-type" title="Class DerivedType">DerivedType</a></td></tr><tr><td><a href="type.Type$DoubleType.html" class="ref-link ref-type" title="Class DoubleType">DoubleType</a></td></tr><tr><td><a href="type.Type$ErroneousType.html" class="ref-link ref-type" title="Class ErroneousType">ErroneousType</a></td></tr><tr><td><a href="type.Type$Float128Type.html" class="ref-link ref-type" title="Class Float128Type">Float128Type</a></td></tr><tr><td><a href="type.Type$FloatType.html" class="ref-link ref-type" title="Class FloatType">FloatType</a></td></tr><tr><td><a href="type.Type$FloatingPointType.html" class="ref-link ref-type" title="Class FloatingPointType">FloatingPointType</a></td></tr><tr><td><a href="type.Type$FunctionPointerIshType.html" class="ref-link ref-type" title="Class FunctionPointerIshType">FunctionPointerIshType</a></td></tr><tr><td><a href="type.Type$FunctionPointerType.html" class="ref-link ref-type" title="Class FunctionPointerType">FunctionPointerType</a></td></tr><tr><td><a href="type.Type$FunctionReferenceType.html" class="ref-link ref-type" title="Class FunctionReferenceType">FunctionReferenceType</a></td></tr><tr><td><a href="type.Type$GNUVectorType.html" class="ref-link ref-type" title="Class GNUVectorType">GNUVectorType</a></td></tr><tr><td><a href="type.Type$ImaginaryDomain.html" class="ref-link ref-type" title="Class ImaginaryDomain">ImaginaryDomain</a></td></tr><tr><td><a href="type.Type$ImaginaryNumberType.html" class="ref-link ref-type" title="Class ImaginaryNumberType">ImaginaryNumberType</a></td></tr><tr><td><a href="type.Type$Int128Type.html" class="ref-link ref-type" title="Class Int128Type">Int128Type</a></td></tr><tr><td><a href="type.Type$IntType.html" class="ref-link ref-type" title="Class IntType">IntType</a></td></tr><tr><td><a href="type.Type$IntegralOrEnumType.html" class="ref-link ref-type" title="Class IntegralOrEnumType">IntegralOrEnumType</a></td></tr><tr><td><a href="type.Type$IntegralType.html" class="ref-link ref-type" title="Class IntegralType">IntegralType</a></td></tr><tr><td><a href="type.Type$LValueReferenceType.html" class="ref-link ref-type" title="Class LValueReferenceType">LValueReferenceType</a></td></tr><tr><td><a href="type.Type$LongDoubleType.html" class="ref-link ref-type" title="Class LongDoubleType">LongDoubleType</a></td></tr><tr><td><a href="type.Type$LongLongType.html" class="ref-link ref-type" title="Class LongLongType">LongLongType</a></td></tr><tr><td><a href="type.Type$LongType.html" class="ref-link ref-type" title="Class LongType">LongType</a></td></tr><tr><td><a href="type.Type$NullPointerType.html" class="ref-link ref-type" title="Class NullPointerType">NullPointerType</a></td></tr><tr><td><a href="type.Type$PlainCharType.html" class="ref-link ref-type" title="Class PlainCharType">PlainCharType</a></td></tr><tr><td><a href="type.Type$PointerToMemberType.html" class="ref-link ref-type" title="Class PointerToMemberType">PointerToMemberType</a></td></tr><tr><td><a href="type.Type$PointerType.html" class="ref-link ref-type" title="Class PointerType">PointerType</a></td></tr><tr><td><a href="type.Type$RValueReferenceType.html" class="ref-link ref-type" title="Class RValueReferenceType">RValueReferenceType</a></td></tr><tr><td><a href="type.Type$RealDomain.html" class="ref-link ref-type" title="Class RealDomain">RealDomain</a></td></tr><tr><td><a href="type.Type$RealNumberType.html" class="ref-link ref-type" title="Class RealNumberType">RealNumberType</a></td></tr><tr><td><a href="type.Type$ReferenceType.html" class="ref-link ref-type" title="Class ReferenceType">ReferenceType</a></td></tr><tr><td><a href="type.Type$RoutineType.html" class="ref-link ref-type" title="Class RoutineType">RoutineType</a></td></tr><tr><td><a href="type.Type$ShortType.html" class="ref-link ref-type" title="Class ShortType">ShortType</a></td></tr><tr><td><a href="type.Type$SignedCharType.html" class="ref-link ref-type" title="Class SignedCharType">SignedCharType</a></td></tr><tr><td><a href="type.Type$SpecifiedType.html" class="ref-link ref-type" title="Class SpecifiedType">SpecifiedType</a></td></tr><tr><td><a href="type.Type$TemplateParameter.html" class="ref-link ref-type" title="Class TemplateParameter">TemplateParameter</a></td></tr><tr><td><a href="type.Type$TemplateTemplateParameter.html" class="ref-link ref-type" title="Class TemplateTemplateParameter">TemplateTemplateParameter</a></td></tr><tr><td><a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></td></tr><tr><td><a href="type.Type$TypeDomain.html" class="ref-link ref-type" title="Class TypeDomain">TypeDomain</a></td></tr><tr><td><a href="type.Type$TypeMention.html" class="ref-link ref-type" title="Class TypeMention">TypeMention</a></td></tr><tr><td><a href="type.Type$UnknownType.html" class="ref-link ref-type" title="Class UnknownType">UnknownType</a></td></tr><tr><td><a href="type.Type$UnsignedCharType.html" class="ref-link ref-type" title="Class UnsignedCharType">UnsignedCharType</a></td></tr><tr><td><a href="type.Type$VoidType.html" class="ref-link ref-type" title="Class VoidType">VoidType</a></td></tr><tr><td><a href="type.Type$WideCharType.html" class="ref-link ref-type" title="Class WideCharType">WideCharType</a></td></tr></tbody></table></div></div></div></div></div></nav><div class="overflow-y-auto width-full pt-2"><div id="content"><div><h1 class="section-heading" id="Type::IntegralOrEnumType"><span><span>Class <span><a href="type.Type$IntegralOrEnumType.html" class="ref-link ref-type" title="Class IntegralOrEnumType">IntegralOrEnumType</a></span></span></span></h1></div><div><div class="doc-block"><div class="qldoc"><p>A C/C++ integral or <code>enum</code> type.</p>
<p>The definition of &ldquo;integral type&rdquo; in the C++ standard excludes <code>enum</code> types,
but because an <code>enum</code> type holds a value of its underlying integral type,
it is often useful to have a common category that includes both integral
and <code>enum</code> types.</p>
<p>In the following example, <code>a</code>, <code>b</code> and <code>c</code> are all declared with an
integral or <code>enum</code> type:</p>
<pre><code class="numbered-code"><span class="numbered-code-line">unsigned long a;
</span><span class="numbered-code-line">enum e1 { val1, val2 } b;
</span><span class="numbered-code-line">enum class e2: short { val3, val4 } c;
</span></code></pre>
</div></div></div><div><h2 class="subsection-heading" id="Import path">Import path</h2><div class="doc-block"><code>import cpp</code></div></div><div><h2 class="subsection-heading" id="Direct supertypes">Direct supertypes</h2><div><div class="doc-block"><ul class="inline-list comma-list"><li><a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></li></ul></div></div></div><div><h2 class="subsection-heading" id="Indirect supertypes">Indirect supertypes</h2><div><div class="doc-block"><ul class="inline-list comma-list"><li><a href="../../../../type.@element.html" class="ref-link ref-type" title="Union type @element">@element</a></li><li><a href="../../../../type.@exprparent.html" class="ref-link ref-type" title="Union type @exprparent">@exprparent</a></li><li><a href="../../../../type.@type.html" class="ref-link ref-type" title="Union type @type">@type</a></li><li><a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></li><li><a href="../Element.qll/type.Element$ElementBase.html" class="ref-link ref-type" title="Class ElementBase">ElementBase</a></li><li><a href="../Location.qll/type.Location$Locatable.html" class="ref-link ref-type" title="Class Locatable">Locatable</a></li></ul></div></div></div><div><h2 class="subsection-heading" id="Known direct subtypes">Known direct subtypes</h2><div><div class="doc-block"><ul class="inline-list comma-list"><li><a href="../Enum.qll/type.Enum$Enum.html" class="ref-link ref-type" title="Class Enum">Enum</a></li><li><a href="type.Type$IntegralType.html" class="ref-link ref-type" title="Class IntegralType">IntegralType</a></li></ul></div></div></div><div><h2 class="subsection-heading" id="Inherited predicates">Inherited predicates</h2><div class="doc-block"><table><tbody><tr><td><a href="predicate.Type$Type$explain.0.html" class="ref-link ref-predicate" title="Member predicate Type::explain">explain</a></td><td><span class="qldoc-summary"><p>Gets a detailed string representation explaining the AST of this type  (with all specifiers and nested constructs such as pointers). This is  intended to help debug queries and is a very expensive operation; not  to be used in production queries.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$findRootCause.0.html" class="ref-link ref-predicate" title="Member predicate Element::findRootCause">findRootCause</a></td><td><span class="qldoc-summary"><p>Gets the source of this element: either itself or a macro that expanded  to this element.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><span class="deprecated"><a href="../Element.qll/predicate.Element$Element$fromLibrary.0.html" class="ref-link ref-predicate" title="Member predicate Element::fromLibrary">fromLibrary</a></span></td><td><span class="qldoc-summary"><p>Holds if this element may be from a library.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$fromSource.0.html" class="ref-link ref-predicate" title="Member predicate Element::fromSource">fromSource</a></td><td><span class="qldoc-summary"><p>Holds if this element may be from source.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$ElementBase$getAPrimaryQlClass.0.html" class="ref-link ref-predicate" title="Member predicate ElementBase::getAPrimaryQlClass">getAPrimaryQlClass</a></td><td><span class="qldoc-summary"><p>Gets the name of a primary CodeQL class to which this element belongs.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$ElementBase.html" class="ref-link ref-type" title="Class ElementBase">ElementBase</a></span></td></tr><tr><td><a href="predicate.Type$Type$getASpecifier.0.html" class="ref-link ref-predicate" title="Member predicate Type::getASpecifier">getASpecifier</a></td><td><span class="qldoc-summary"><p>Gets a specifier of this type, recursively looking through <code>typedef</code> and  <code>decltype</code>. For example, in the context of <code>typedef const int *restrict t</code>, the type <code>volatile t</code> has specifiers <code>volatile</code> and <code>restrict</code> but not  <code>const</code> since the <code>const</code> is attached to the type being pointed to rather  than the pointer itself.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$getATypeNameUse.0.html" class="ref-link ref-predicate" title="Member predicate Type::getATypeNameUse">getATypeNameUse</a></td><td><span class="qldoc-summary"><p>Gets as many places as possible where this type is used by name in the source after macros have been replaced  (in particular, therefore, this will find type name uses caused by macros). Note that all type name uses within  instantiations are currently excluded - this is too draconian in the absence of indexing prototype instantiations  of functions, and is likely to improve in the future. At present, the method takes the conservative approach of  giving valid type name uses, but not necessarily <em>all</em> type name uses.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$getAlignment.0.html" class="ref-link ref-predicate" title="Member predicate Type::getAlignment">getAlignment</a></td><td><span class="qldoc-summary"><p>Gets the alignment of this type in bytes.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$getAnAttribute.0.html" class="ref-link ref-predicate" title="Member predicate Type::getAnAttribute">getAnAttribute</a></td><td><span class="qldoc-summary"><p>Gets an attribute of this type.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><span class="deprecated"><a href="../Element.qll/predicate.Element$ElementBase$getCanonicalQLClass.0.html" class="ref-link ref-predicate" title="Member predicate ElementBase::getCanonicalQLClass">getCanonicalQLClass</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: use <code>getAPrimaryQlClass</code> instead.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$ElementBase.html" class="ref-link ref-type" title="Class ElementBase">ElementBase</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$getEnclosingElement.0.html" class="ref-link ref-predicate" title="Member predicate Element::getEnclosingElement">getEnclosingElement</a></td><td><span class="qldoc-summary"><p>Gets the closest <code>Element</code> enclosing this one.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$getFile.0.html" class="ref-link ref-predicate" title="Member predicate Element::getFile">getFile</a></td><td><span class="qldoc-summary"><p>Gets the primary file where this element occurs.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="predicate.Type$Type$getLocation.0.html" class="ref-link ref-predicate" title="Member predicate Type::getLocation">getLocation</a></td><td><span class="qldoc-summary"><p>Gets the primary location of this element.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$getName.0.html" class="ref-link ref-predicate" title="Member predicate Type::getName">getName</a></td><td><span class="qldoc-summary"><p>Gets the name of this type.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$getParentScope.0.html" class="ref-link ref-predicate" title="Member predicate Element::getParentScope">getParentScope</a></td><td><span class="qldoc-summary"><p>Gets the parent scope of this <code>Element</code>, if any.  A scope is a <code>Type</code> (<code>Class</code> / <code>Enum</code>), a <code>Namespace</code>, a <code>BlockStmt</code>, a <code>Function</code>,  or certain kinds of <code>Statement</code>.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="predicate.Type$Type$getPointerIndirectionLevel.0.html" class="ref-link ref-predicate" title="Member predicate Type::getPointerIndirectionLevel">getPointerIndirectionLevel</a></td><td><span class="qldoc-summary"><p>Gets the pointer indirection level of this type.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$getSize.0.html" class="ref-link ref-predicate" title="Member predicate Type::getSize">getSize</a></td><td><span class="qldoc-summary"><p>Gets the size of this type in bytes.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$getUnderlyingType.0.html" class="ref-link ref-predicate" title="Member predicate Type::getUnderlyingType">getUnderlyingType</a></td><td><span class="qldoc-summary"><p>Gets this type after typedefs have been resolved.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$getUnspecifiedType.0.html" class="ref-link ref-predicate" title="Member predicate Type::getUnspecifiedType">getUnspecifiedType</a></td><td><span class="qldoc-summary"><p>Gets this type after specifiers have been deeply stripped and typedefs have been resolved.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$hasName.1.html" class="ref-link ref-predicate" title="Member predicate Type::hasName">hasName</a></td><td><span class="qldoc-summary"><p>Holds if this type is called <code>name</code>.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$hasSpecifier.1.html" class="ref-link ref-predicate" title="Member predicate Type::hasSpecifier">hasSpecifier</a></td><td><span class="qldoc-summary"><p>Holds if this declaration has a specifier called <code>name</code>, recursively looking  through <code>typedef</code> and <code>decltype</code>. For example, in the context of  <code>typedef const int *restrict t</code>, the type <code>volatile t</code> has specifiers  <code>volatile</code> and <code>restrict</code> but not <code>const</code> since the <code>const</code> is attached to  the type being pointed to rather than the pointer itself.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$internal_getAnAdditionalSpecifier.0.html" class="ref-link ref-predicate" title="Member predicate Type::internal_getAnAdditionalSpecifier">internal_getAnAdditionalSpecifier</a></td><td><span class="qldoc-summary"><p>Internal &ndash; should be <code>protected</code> when QL supports such a flag. Subtypes  override this to recursively get specifiers that are not attached directly  to this <code>@type</code> in the database but arise through type aliases such as  <code>typedef</code> and <code>decltype</code>.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$involvesReference.0.html" class="ref-link ref-predicate" title="Member predicate Type::involvesReference">involvesReference</a></td><td><span class="qldoc-summary"><p>Holds if this type involves a reference.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$involvesTemplateParameter.0.html" class="ref-link ref-predicate" title="Member predicate Type::involvesTemplateParameter">involvesTemplateParameter</a></td><td><span class="qldoc-summary"><p>Holds if this type involves a template parameter.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$isAffectedByMacro.0.html" class="ref-link ref-predicate" title="Member predicate Element::isAffectedByMacro">isAffectedByMacro</a></td><td><span class="qldoc-summary"><p>Holds if this element is affected in any way by a macro. All elements  that are totally or partially generated by a macro are included, so  this is a super-set of <code>isInMacroExpansion</code>.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="predicate.Type$Type$isConst.0.html" class="ref-link ref-predicate" title="Member predicate Type::isConst">isConst</a></td><td><span class="qldoc-summary"><p>Holds if this type is const.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$isDeeplyConst.0.html" class="ref-link ref-predicate" title="Member predicate Type::isDeeplyConst">isDeeplyConst</a></td><td><span class="qldoc-summary"><p>Holds if this type is constant and only contains constant types.  For instance, a <code>char *const</code> is a constant type, but not deeply constant,  because while the pointer can&rsquo;t be modified the character can. The type  <code>const char *const*</code> is a deeply constant type though - both the pointer  and what it points to are immutable.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$isDeeplyConstBelow.0.html" class="ref-link ref-predicate" title="Member predicate Type::isDeeplyConstBelow">isDeeplyConstBelow</a></td><td><span class="qldoc-summary"><p>Holds if this type is constant and only contains constant types, excluding  the type itself. It is implied by Type.isDeeplyConst() and is just used to  implement that predicate.  For example, <code>const char *const</code> is deeply constant and deeply constant below,  but <code>const char *</code> is only deeply constant below (the pointer can be changed,  but not the underlying char). <code>char *const</code> is neither (it is just <code>const</code>).</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$isFromTemplateInstantiation.1.html" class="ref-link ref-predicate" title="Member predicate Element::isFromTemplateInstantiation">isFromTemplateInstantiation</a></td><td><span class="qldoc-summary"><p>Holds if this <code>Element</code> is a part of a template instantiation (but not  the template itself).</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$isFromUninstantiatedTemplate.1.html" class="ref-link ref-predicate" title="Member predicate Element::isFromUninstantiatedTemplate">isFromUninstantiatedTemplate</a></td><td><span class="qldoc-summary"><p>Holds if this <code>Element</code> is part of a template <code>template</code> (not if it is  part of an instantiation of <code>template</code>). This means it is represented in  the database purely as syntax and without guarantees on the presence or  correctness of type-based operations such as implicit conversions.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$isInMacroExpansion.0.html" class="ref-link ref-predicate" title="Member predicate Element::isInMacroExpansion">isInMacroExpansion</a></td><td><span class="qldoc-summary"><p>Holds if this element comes from a macro expansion. Only elements that  are entirely generated by a macro are included - for elements that  partially come from a macro, see <code>isAffectedByMacro</code>.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="predicate.Type$Type$isVolatile.0.html" class="ref-link ref-predicate" title="Member predicate Type::isVolatile">isVolatile</a></td><td><span class="qldoc-summary"><p>Holds if this type is volatile.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$refersTo.1.html" class="ref-link ref-predicate" title="Member predicate Type::refersTo">refersTo</a></td><td><span class="qldoc-summary"><p>Holds if this type refers to type <code>t</code> (by default,  a type always refers to itself).</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$refersToDirectly.1.html" class="ref-link ref-predicate" title="Member predicate Type::refersToDirectly">refersToDirectly</a></td><td><span class="qldoc-summary"><p>Holds if this type refers to type <code>t</code> directly.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$resolveTypedefs.0.html" class="ref-link ref-predicate" title="Member predicate Type::resolveTypedefs">resolveTypedefs</a></td><td><span class="qldoc-summary"><p>Gets this type with any typedefs resolved. For example, given  <code>typedef C T</code>, this would resolve <code>const T&amp;amp;</code> to <code>const C&amp;amp;</code>.  Note that this will only work if the resolved type actually appears  on its own elsewhere in the program.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$stripTopLevelSpecifiers.0.html" class="ref-link ref-predicate" title="Member predicate Type::stripTopLevelSpecifiers">stripTopLevelSpecifiers</a></td><td><span class="qldoc-summary"><p>Gets this type after any top-level specifiers and typedefs have been stripped.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.Type$Type$stripType.0.html" class="ref-link ref-predicate" title="Member predicate Type::stripType">stripType</a></td><td><span class="qldoc-summary"><p>Gets the type stripped of pointers, references and cv-qualifiers, and resolving typedefs.  For example, given <code>typedef const C&amp;amp; T</code>, <code>stripType</code> returns <code>C</code>.</p>
</span></td><td><span>from <a href="type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$ElementBase$toString.0.html" class="ref-link ref-predicate" title="Member predicate ElementBase::toString">toString</a></td><td><span class="qldoc-summary"><p>Gets a textual representation of this element.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$ElementBase.html" class="ref-link ref-type" title="Class ElementBase">ElementBase</a></span></td></tr></tbody></table></div></div><div><h2 class="subsection-heading" id="Charpred">Charpred</h2><div class="doc-block"><table><tbody><tr><td><a href="predicate.Type$IntegralOrEnumType$IntegralOrEnumType.0.html" class="ref-link ref-predicate" title="Characteristic predicate IntegralOrEnumType::IntegralOrEnumType">IntegralOrEnumType</a></td><td></td></tr></tbody></table></div></div></div></div></div><footer id="content-footer">Copyright 2020 GitHub Software UK Ltd.<a title="Privacy statement and tracking preferences" target="_blank" href="https://docs.github.com/github/site-policy/github-privacy-statement">Privacy Statement</a></footer></body></html>