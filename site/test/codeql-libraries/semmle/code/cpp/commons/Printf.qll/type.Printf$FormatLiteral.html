<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="qldoc"><meta name="description" content="API documentation for CodeQL"><meta name="keywords" content="CodeQL,QL,FormatLiteral"><meta name="addsearch-category" content="C/C++ CodeQL library"><title>FormatLiteral</title><link rel="stylesheet" type="text/css" href="https://unpkg.com/@primer/css/dist/primer.css"><link rel="stylesheet" type="text/css" href="../../../../../qldoc.css"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-5Q9DBRM');</script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q9DBRM" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="Header text-white"><div class="Header-item"><svg class="octicon octicon-mark-github mr-2" height="32" viewbox="0 0 16 16" width="32"><path fill-rule="even-odd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg></div><div class="Header-item--full f2 text-bold">CodeQL library for C/C++</div><div class="Header-item"><span>Version 1.26.0</span></div><div class="Header-item .text-gray-light"><div class="nav-section"><a href="../../../../../index.html">Index</a></div></div><div class="Header-item"><a title="Search the CodeQL libraries" target="_blank" href="https://help.semmle.com/home/help/search-results-qldoc.html"><span class=".text-gray-light">Search</span></a></div></div><div id="main"><nav id="sidebar"><div id="sidebar-content" class="pt-2"><div class="nav-section"><p>For other CodeQL resources, including tutorials and examples, see <a href="https://help.semmle.com/QL/learn-ql/" class="learn-ql-link" target="_blank">Learning CodeQL</a><p>.</p></p><h2 class="section-heading"><a href="type.Printf$FormatLiteral.html" class="ref-link ref-type">FormatLiteral</a></h2><div class="doc-block"><ol class="section-links"><li></li><li></li><li><a href="type.Printf$FormatLiteral.html#Import%20path">Import path</a></li><li><a href="type.Printf$FormatLiteral.html#Direct%20supertypes">Direct supertypes</a></li><li><a href="type.Printf$FormatLiteral.html#Indirect%20supertypes">Indirect supertypes</a></li><li><a href="type.Printf$FormatLiteral.html#Predicates">Predicates</a></li><li><a href="type.Printf$FormatLiteral.html#Inherited%20predicates">Inherited predicates</a></li><li><a href="type.Printf$FormatLiteral.html#Charpred">Charpred</a></li></ol></div></div><div class="nav-section"><div><div><h2 class="section-heading"><span>Module <a href="module.Printf.html" class="ref-link ref-module" title="Module Printf">Printf</a></span></h2></div><div><h3 class="subsection-heading">Imports</h3><div class="doc-block"><table><tbody><tr><td><a href="../CommonType.qll/module.CommonType.html" class="ref-link ref-module" title="Module CommonType">CommonType</a></td></tr><tr><td><a href="../../models/interfaces/FormattingFunction.qll/module.FormattingFunction.html" class="ref-link ref-module" title="Module FormattingFunction">FormattingFunction</a></td></tr><tr><td><a href="../../models/implementations/Printf.qll/module.Printf.html" class="ref-link ref-module" title="Module Printf">Printf</a></td></tr><tr><td><a href="../StringAnalysis.qll/module.StringAnalysis.html" class="ref-link ref-module" title="Module StringAnalysis">StringAnalysis</a></td></tr><tr><td><a href="../../Type.qll/module.Type.html" class="ref-link ref-module" title="Module Type">Type</a></td></tr></tbody></table></div></div><div><h3 class="subsection-heading">Predicates</h3><div class="doc-block"><table><tbody><tr><td><a href="predicate.Printf$primitiveVariadicFormatter.2.html" class="ref-link ref-predicate" title="Predicate primitiveVariadicFormatter">primitiveVariadicFormatter</a></td></tr><tr><td><a href="predicate.Printf$variadicFormatter.2.html" class="ref-link ref-predicate" title="Predicate variadicFormatter">variadicFormatter</a></td></tr></tbody></table></div></div><div><h3 class="subsection-heading">Classes</h3><div class="doc-block"><table><tbody><tr><td><a href="type.Printf$AttributeFormattingFunction.html" class="ref-link ref-type" title="Class AttributeFormattingFunction">AttributeFormattingFunction</a></td></tr><tr><td><a href="type.Printf$FormatLiteral.html" class="ref-link ref-type" title="Class FormatLiteral">FormatLiteral</a></td></tr><tr><td><a href="type.Printf$FormattingFunctionCall.html" class="ref-link ref-type" title="Class FormattingFunctionCall">FormattingFunctionCall</a></td></tr><tr><td><a href="type.Printf$PrintfFormatAttribute.html" class="ref-link ref-type" title="Class PrintfFormatAttribute">PrintfFormatAttribute</a></td></tr><tr><td><a href="type.Printf$UserDefinedFormattingFunction.html" class="ref-link ref-type" title="Class UserDefinedFormattingFunction">UserDefinedFormattingFunction</a></td></tr></tbody></table></div></div></div></div></div></nav><div class="overflow-y-auto width-full pt-2"><div id="content"><div><h1 class="section-heading" id="Printf::FormatLiteral"><span><span>Class <span><a href="type.Printf$FormatLiteral.html" class="ref-link ref-type" title="Class FormatLiteral">FormatLiteral</a></span></span></span></h1></div><div><div class="doc-block"><div class="qldoc"><p>A class to represent format strings that occur as arguments to invocations of formatting functions.</p>
</div></div></div><div><h2 class="subsection-heading" id="Import path">Import path</h2><div class="doc-block"><code>import cpp</code></div></div><div><h2 class="subsection-heading" id="Direct supertypes">Direct supertypes</h2><div><div class="doc-block"><ul class="inline-list comma-list"><li><a href="../../exprs/Literal.qll/type.Literal$Literal.html" class="ref-link ref-type" title="Class Literal">Literal</a></li></ul></div></div></div><div><h2 class="subsection-heading" id="Indirect supertypes">Indirect supertypes</h2><div><div class="doc-block"><ul class="inline-list comma-list"><li><a href="../../../../../type.@cfgnode.html" class="ref-link ref-type" title="Union type @cfgnode">@cfgnode</a></li><li><a href="../../../../../type.@element.html" class="ref-link ref-type" title="Union type @element">@element</a></li><li><a href="../../../../../type.@expr.html" class="ref-link ref-type" title="Case type @expr">@expr</a></li><li><a href="../../../../../type.@exprparent.html" class="ref-link ref-type" title="Union type @exprparent">@exprparent</a></li><li><a href="../../../../../type.@jumporlabel.html" class="ref-link ref-type" title="Union type @jumporlabel">@jumporlabel</a></li><li><a href="../../../../../type.@literal.html" class="ref-link ref-type" title="Branch type @literal">@literal</a></li><li><a href="../../../../../type.@namequalifiableelement.html" class="ref-link ref-type" title="Union type @namequalifiableelement">@namequalifiableelement</a></li><li><a href="../../controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNode.html" class="ref-link ref-type" title="Class ControlFlowNode">ControlFlowNode</a></li><li><a href="../../controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNodeBase.html" class="ref-link ref-type" title="Class ControlFlowNodeBase">ControlFlowNodeBase</a></li><li><a href="../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></li><li><a href="../../Element.qll/type.Element$ElementBase.html" class="ref-link ref-type" title="Class ElementBase">ElementBase</a></li><li><a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></li><li><a href="../../Location.qll/type.Location$Locatable.html" class="ref-link ref-type" title="Class Locatable">Locatable</a></li><li><a href="../../stmts/Stmt.qll/type.Stmt$StmtParent.html" class="ref-link ref-type" title="Class StmtParent">StmtParent</a></li><li><a href="../../stmts/Stmt.qll/type.Stmt$TStmtParent.html" class="ref-link ref-type" title="Type TStmtParent">TStmtParent</a></li></ul></div></div></div><div><h2 class="subsection-heading" id="Predicates">Predicates</h2><div class="doc-block"><table><tbody><tr><td><a href="predicate.Printf$FormatLiteral$getConstantPart.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getConstantPart">getConstantPart</a></td><td><span class="qldoc-summary"><p>Gets the constant part of the format string just before the nth  conversion specifier.  If <code>n</code> is zero, this will be the constant prefix  before the 0th specifier, otherwise it is the string between the end  of the n-1th specifier and the nth specifier.  Has no result if <code>n</code>  is negative or not strictly less than the number of conversion  specifiers.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getConstantSuffix.0.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getConstantSuffix">getConstantSuffix</a></td><td><span class="qldoc-summary"><p>Gets the constant part of the format string after the last conversion  specifier.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getConvSpec.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getConvSpec">getConvSpec</a></td><td><span class="qldoc-summary"><p>Gets the nth conversion specifier (including the initial <code>%</code>).</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getConvSpecOffset.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getConvSpecOffset">getConvSpecOffset</a></td><td><span class="qldoc-summary"><p>Gets the position in the string at which the nth conversion specifier  starts.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getConvSpecRegexp.0.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getConvSpecRegexp">getConvSpecRegexp</a></td><td><span class="qldoc-summary"><p>Gets a regular expression used for matching a whole conversion specifier.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getConversionChar.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getConversionChar">getConversionChar</a></td><td><span class="qldoc-summary"><p>Gets the conversion character of the nth conversion specifier.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getConversionType.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getConversionType">getConversionType</a></td><td><span class="qldoc-summary"><p>Gets the argument type required by the nth conversion specifier.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getDefaultCharType.0.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getDefaultCharType">getDefaultCharType</a></td><td><span class="qldoc-summary"><p>Gets the default character type expected for <code>%s</code> by this format literal.  Typically  <code>char</code> or <code>wchar_t</code>.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getFlags.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getFlags">getFlags</a></td><td><span class="qldoc-summary"><p>Gets the flags of the nth conversion specifier.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getFloatingPointConversion.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getFloatingPointConversion">getFloatingPointConversion</a></td><td><span class="qldoc-summary"><p>Gets the family of floating point types required by the nth conversion  specifier&rsquo;s length flag.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getFormat.0.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getFormat">getFormat</a></td><td><span class="qldoc-summary"><p>Gets the format string, with &lsquo;%%&rsquo; and &lsquo;%@&rsquo; replaced by &lsquo;_&rsquo; (to avoid processing  them as format specifiers).</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getFormatArgumentIndexFor.2.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getFormatArgumentIndexFor">getFormatArgumentIndexFor</a></td><td><span class="qldoc-summary"><p>Gets the computed format argument index for the nth conversion specifier of this  format string (if <code>mode = 2</code>), it&rsquo;s minimum field width (if <code>mode = 0</code>) or it&rsquo;s  precision (if <code>mode = 1</code>).  Has no result if that element is not present.  Does  not account for positional arguments (<code>$</code>).</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getIntegralConversion.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getIntegralConversion">getIntegralConversion</a></td><td><span class="qldoc-summary"><p>Gets the family of integral types required by the nth conversion  specifier&rsquo;s length flag.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getIntegralDisplayType.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getIntegralDisplayType">getIntegralDisplayType</a></td><td><span class="qldoc-summary"><p>Gets the family of integral types output / displayed by the nth  conversion specifier&rsquo;s length flag.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getLength.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getLength">getLength</a></td><td><span class="qldoc-summary"><p>Gets the length flag of the nth conversion specifier.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getMaxConvertedLength.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getMaxConvertedLength">getMaxConvertedLength</a></td><td><span class="qldoc-summary"><p>Gets the maximum length of the string that can be produced by the nth  conversion specifier of this format string; has no result if this cannot  be determined.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getMaxConvertedLength.0.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getMaxConvertedLength">getMaxConvertedLength</a></td><td><span class="qldoc-summary"><p>Gets the maximum length of the string that can be produced by this format  string.  Has no result if this cannot be determined.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getMaxConvertedLengthLimited.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getMaxConvertedLengthLimited">getMaxConvertedLengthLimited</a></td><td><span class="qldoc-summary"><p>Gets the maximum length of the string that can be produced by the nth  conversion specifier of this format string, except that float to string  conversions are assumed to be 8 characters.  This is helpful for  determining whether a buffer overflow is caused by long float to string  conversions.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getMaxConvertedLengthLimited.0.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getMaxConvertedLengthLimited">getMaxConvertedLengthLimited</a></td><td><span class="qldoc-summary"><p>Gets the maximum length of the string that can be produced by this format  string, except that float to string conversions are assumed to be 8  characters.  This is helpful for determining whether a buffer overflow  is caused by long float to string conversions.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getMinFieldWidth.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getMinFieldWidth">getMinFieldWidth</a></td><td><span class="qldoc-summary"><p>Gets the minimum field width of the nth conversion specifier.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getMinFieldWidthOpt.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getMinFieldWidthOpt">getMinFieldWidthOpt</a></td><td><span class="qldoc-summary"><p>Gets the minimum field width of the nth conversion specifier  (empty string if none is given).</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getMinFieldWidthParameterFieldValue.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getMinFieldWidthParameterFieldValue">getMinFieldWidthParameterFieldValue</a></td><td><span class="qldoc-summary"><p>Gets the zero-based parameter number of the minimum field width of the nth  conversion specifier, if it is implicit and uses a parameter field (such as <code>*1$</code>).</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getNonDefaultCharType.0.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getNonDefaultCharType">getNonDefaultCharType</a></td><td><span class="qldoc-summary"><p>Gets the non-default character type expected for <code>%S</code> by this format literal.  Typically  <code>wchar_t</code> or <code>char</code>.  On some snapshots there may be multiple results where we can&rsquo;t tell  which is correct for a particular function.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getNumArgNeeded.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getNumArgNeeded">getNumArgNeeded</a></td><td><span class="qldoc-summary"><p>Gets the number of arguments required by the nth conversion specifier  of this format string.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getNumArgNeeded.0.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getNumArgNeeded">getNumArgNeeded</a></td><td><span class="qldoc-summary"><p>Gets the number of arguments needed by this format string.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getNumConvSpec.0.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getNumConvSpec">getNumConvSpec</a></td><td><span class="qldoc-summary"><p>Gets the number of conversion specifiers (not counting <code>%%</code>)</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getParameterField.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getParameterField">getParameterField</a></td><td><span class="qldoc-summary"><p>Gets the parameter field of the nth conversion specifier (for example, <code>1$</code>).</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getParameterFieldValue.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getParameterFieldValue">getParameterFieldValue</a></td><td><span class="qldoc-summary"><p>Gets the parameter field of the nth conversion specifier (if it has one) as a  zero-based number.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getPrecision.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getPrecision">getPrecision</a></td><td><span class="qldoc-summary"><p>Gets the precision of the nth conversion specifier.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getPrecisionOpt.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getPrecisionOpt">getPrecisionOpt</a></td><td><span class="qldoc-summary"><p>Gets the precision of the nth conversion specifier (empty string if none is given).</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getPrecisionParameterFieldValue.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getPrecisionParameterFieldValue">getPrecisionParameterFieldValue</a></td><td><span class="qldoc-summary"><p>Gets the zero-based parameter number of the precision of the nth conversion  specifier, if it is implicit and uses a parameter field (such as <code>*1$</code>).</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getStorePointerConversion.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getStorePointerConversion">getStorePointerConversion</a></td><td><span class="qldoc-summary"><p>Gets the family of pointer types required by the nth conversion  specifier&rsquo;s length flag.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getUse.0.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getUse">getUse</a></td><td><span class="qldoc-summary"><p>Gets the function call where this format string is used.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$getWideCharType.0.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::getWideCharType">getWideCharType</a></td><td><span class="qldoc-summary"><p>Gets the wide character type for this format literal.  This is usually <code>wchar_t</code>.  On some  snapshots there may be multiple results where we can&rsquo;t tell which is correct for a  particular function.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$hasAlternateFlag.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::hasAlternateFlag">hasAlternateFlag</a></td><td><span class="qldoc-summary"><p>Holds if the nth conversion specifier has alternate flag (&ldquo;#&rdquo;).</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$hasAlternativeDigits.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::hasAlternativeDigits">hasAlternativeDigits</a></td><td><span class="qldoc-summary"><p>Holds if the nth conversion specifier has the alternative digits flag (&ldquo;I&rdquo;).</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$hasBlank.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::hasBlank">hasBlank</a></td><td><span class="qldoc-summary"><p>Holds if the nth conversion specifier has the blank flag (&quot; &quot;).</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$hasExplicitMinFieldWidth.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::hasExplicitMinFieldWidth">hasExplicitMinFieldWidth</a></td><td><span class="qldoc-summary"><p>Holds if the nth conversion specifier has an explicitly given minimum  field width.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$hasExplicitPrecision.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::hasExplicitPrecision">hasExplicitPrecision</a></td><td><span class="qldoc-summary"><p>Holds if the nth conversion specifier has an explicitly given precision.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$hasImplicitMinFieldWidth.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::hasImplicitMinFieldWidth">hasImplicitMinFieldWidth</a></td><td><span class="qldoc-summary"><p>Holds if the nth conversion specifier has an implicitly given minimum  field width (either &ldquo;*&rdquo; or &ldquo;*i$&rdquo; for some number i).</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$hasImplicitPrecision.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::hasImplicitPrecision">hasImplicitPrecision</a></td><td><span class="qldoc-summary"><p>Holds if the nth conversion specifier has an implicitly given precision  (either &ldquo;*&rdquo; or &ldquo;*i$&rdquo; for some number i).</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$hasMinFieldWidth.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::hasMinFieldWidth">hasMinFieldWidth</a></td><td><span class="qldoc-summary"><p>Holds if the nth conversion specifier has a minimum field width.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$hasPrecision.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::hasPrecision">hasPrecision</a></td><td><span class="qldoc-summary"><p>Holds if the nth conversion specifier has a precision.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$hasSign.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::hasSign">hasSign</a></td><td><span class="qldoc-summary"><p>Holds if the nth conversion specifier has the explicit sign flag (&ldquo;+&rdquo;).</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$hasThousandsGrouping.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::hasThousandsGrouping">hasThousandsGrouping</a></td><td><span class="qldoc-summary"><p>Holds if the nth conversion specifier has the thousands grouping flag (&ldquo;&rsquo;&rdquo;).</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$isLeftAdjusted.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::isLeftAdjusted">isLeftAdjusted</a></td><td><span class="qldoc-summary"><p>Holds if the nth conversion specifier has flag left adjustment flag  (&ldquo;-&rdquo;).  Note that this overrides the zero padding flag.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$isMicrosoft.0.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::isMicrosoft">isMicrosoft</a></td><td><span class="qldoc-summary"><p>Holds if this <code>FormatLiteral</code> is in a context that supports  Microsoft rules and extensions.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="predicate.Printf$FormatLiteral$isWideCharDefault.0.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::isWideCharDefault">isWideCharDefault</a></span></td><td><span class="qldoc-summary"><p>Holds if the default meaning of <code>%s</code> is a <code>wchar_t *</code>, rather than  a <code>char *</code> (either way, <code>%S</code> will have the opposite meaning).  DEPRECATED: Use getDefaultCharType() instead.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$isZeroPadded.1.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::isZeroPadded">isZeroPadded</a></td><td><span class="qldoc-summary"><p>Holds if the nth conversion specifier has zero padding flag (&ldquo;0&rdquo;).</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$parseConvSpec.8.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::parseConvSpec">parseConvSpec</a></td><td><span class="qldoc-summary"><p>Holds if the arguments are a parsing of a conversion specifier to this  format string, where <code>n</code> is which conversion specifier to parse, <code>spec</code> is  the whole conversion specifier, <code>params</code> is the argument to be converted  in case it&rsquo;s not positional, <code>flags</code> contains additional format flags,  <code>width</code> is the maximum width option of this input, <code>len</code> is the length  flag of this input, and <code>conv</code> is the conversion character of this input.</p>
</span></td></tr><tr><td><a href="predicate.Printf$FormatLiteral$specsAreKnown.0.html" class="ref-link ref-predicate" title="Member predicate FormatLiteral::specsAreKnown">specsAreKnown</a></td><td><span class="qldoc-summary"><p>Holds if all conversion specifiers of this format string have been  parsed by the library (this does not hold if one or more unrecognized  format specifiers are present in the format string).</p>
</span></td></tr></tbody></table></div></div><div><h2 class="subsection-heading" id="Inherited predicates">Inherited predicates</h2><div class="doc-block"><table><tbody><tr><td><a href="../../Element.qll/predicate.Element$Element$findRootCause.0.html" class="ref-link ref-predicate" title="Member predicate Element::findRootCause">findRootCause</a></td><td><span class="qldoc-summary"><p>Gets the source of this element: either itself or a macro that expanded  to this element.</p>
</span></td><td><span>from <a href="../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><span class="deprecated"><a href="../../Element.qll/predicate.Element$Element$fromLibrary.0.html" class="ref-link ref-predicate" title="Member predicate Element::fromLibrary">fromLibrary</a></span></td><td><span class="qldoc-summary"><p>Holds if this element may be from a library.</p>
</span></td><td><span>from <a href="../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../Element.qll/predicate.Element$Element$fromSource.0.html" class="ref-link ref-predicate" title="Member predicate Element::fromSource">fromSource</a></td><td><span class="qldoc-summary"><p>Holds if this element may be from source.</p>
</span></td><td><span>from <a href="../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getAChild.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getAChild">getAChild</a></td><td><span class="qldoc-summary"><p>Gets a child of this expression.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../controlflow/ControlFlowGraph.qll/predicate.ControlFlowGraph$ControlFlowNode$getAFalseSuccessor.0.html" class="ref-link ref-predicate" title="Member predicate ControlFlowNode::getAFalseSuccessor">getAFalseSuccessor</a></td><td><span class="qldoc-summary"><p>Gets a node such that the control-flow edge <code>(this, result)</code> may be  taken when this expression is false.</p>
</span></td><td><span>from <a href="../../controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNode.html" class="ref-link ref-type" title="Class ControlFlowNode">ControlFlowNode</a></span></td></tr><tr><td><a href="../../controlflow/ControlFlowGraph.qll/predicate.ControlFlowGraph$ControlFlowNode$getAPredecessor.0.html" class="ref-link ref-predicate" title="Member predicate ControlFlowNode::getAPredecessor">getAPredecessor</a></td><td><span class="qldoc-summary"><p>Gets a direct predecessor of this control-flow node, if any.</p>
</span></td><td><span>from <a href="../../controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNode.html" class="ref-link ref-type" title="Class ControlFlowNode">ControlFlowNode</a></span></td></tr><tr><td><a href="../../exprs/Literal.qll/predicate.Literal$Literal$getAPrimaryQlClass.0.html" class="ref-link ref-predicate" title="Member predicate Literal::getAPrimaryQlClass">getAPrimaryQlClass</a></td><td><span class="qldoc-summary"><p>Gets the name of a primary CodeQL class to which this element belongs.</p>
</span></td><td><span>from <a href="../../exprs/Literal.qll/type.Literal$Literal.html" class="ref-link ref-type" title="Class Literal">Literal</a></span></td></tr><tr><td><a href="../../controlflow/ControlFlowGraph.qll/predicate.ControlFlowGraph$ControlFlowNode$getASuccessor.0.html" class="ref-link ref-predicate" title="Member predicate ControlFlowNode::getASuccessor">getASuccessor</a></td><td><span class="qldoc-summary"><p>Gets a direct successor of this control-flow node, if any.</p>
</span></td><td><span>from <a href="../../controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNode.html" class="ref-link ref-type" title="Class ControlFlowNode">ControlFlowNode</a></span></td></tr><tr><td><a href="../../controlflow/ControlFlowGraph.qll/predicate.ControlFlowGraph$ControlFlowNode$getATrueSuccessor.0.html" class="ref-link ref-predicate" title="Member predicate ControlFlowNode::getATrueSuccessor">getATrueSuccessor</a></td><td><span class="qldoc-summary"><p>Gets a node such that the control-flow edge <code>(this, result)</code> may be  taken when this expression is true.</p>
</span></td><td><span>from <a href="../../controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNode.html" class="ref-link ref-type" title="Class ControlFlowNode">ControlFlowNode</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getActualType.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getActualType">getActualType</a></td><td><span class="qldoc-summary"><p>Gets the type of this expression, after any implicit conversions and explicit casts, and after resolving typedefs.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../controlflow/ControlFlowGraph.qll/predicate.ControlFlowGraph$ControlFlowNode$getBasicBlock.0.html" class="ref-link ref-predicate" title="Member predicate ControlFlowNode::getBasicBlock">getBasicBlock</a></td><td><span class="qldoc-summary"><p>Gets the <code>BasicBlock</code> containing this control-flow node.</p>
</span></td><td><span>from <a href="../../controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNode.html" class="ref-link ref-type" title="Class ControlFlowNode">ControlFlowNode</a></span></td></tr><tr><td><span class="deprecated"><a href="../../Element.qll/predicate.Element$ElementBase$getCanonicalQLClass.0.html" class="ref-link ref-predicate" title="Member predicate ElementBase::getCanonicalQLClass">getCanonicalQLClass</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: use <code>getAPrimaryQlClass</code> instead.</p>
</span></td><td><span>from <a href="../../Element.qll/type.Element$ElementBase.html" class="ref-link ref-type" title="Class ElementBase">ElementBase</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getChild.1.html" class="ref-link ref-predicate" title="Member predicate Expr::getChild">getChild</a></td><td><span class="qldoc-summary"><p>Gets the nth child of this expression.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getControlFlowScope.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getControlFlowScope">getControlFlowScope</a></td><td><span class="qldoc-summary"><p>Gets the function containing this control-flow node.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getConversion.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getConversion">getConversion</a></td><td><span class="qldoc-summary"><p>Gets the conversion associated with this expression, if any.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getConversionString.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getConversionString">getConversionString</a></td><td><span class="qldoc-summary"><p>Gets a string describing the conversion associated with this expression,  or &quot;&quot; if there is none.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getEnclosingBlock.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getEnclosingBlock">getEnclosingBlock</a></td><td><span class="qldoc-summary"><p>Gets the nearest enclosing set of curly braces around this expression in the source, if any.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../Element.qll/predicate.Element$Element$getEnclosingElement.0.html" class="ref-link ref-predicate" title="Member predicate Element::getEnclosingElement">getEnclosingElement</a></td><td><span class="qldoc-summary"><p>Gets the closest <code>Element</code> enclosing this one.</p>
</span></td><td><span>from <a href="../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getEnclosingFunction.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getEnclosingFunction">getEnclosingFunction</a></td><td><span class="qldoc-summary"><p>Gets the enclosing function of this expression, if any.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getEnclosingStmt.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getEnclosingStmt">getEnclosingStmt</a></td><td><span class="qldoc-summary"><p>Gets the smallest statement containing this control-flow node.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getEnclosingVariable.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getEnclosingVariable">getEnclosingVariable</a></td><td><span class="qldoc-summary"><p>Gets the enclosing variable of this expression, if any.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getExplicitlyConverted.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getExplicitlyConverted">getExplicitlyConverted</a></td><td><span class="qldoc-summary"><p>Gets this expression with all of its explicit casts, but none of its  implicit casts. More precisely this takes conversions up to the last  explicit cast (there may be implicit conversions along the way), but does  not include conversions after the last explicit cast.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../Element.qll/predicate.Element$Element$getFile.0.html" class="ref-link ref-predicate" title="Member predicate Element::getFile">getFile</a></td><td><span class="qldoc-summary"><p>Gets the primary file where this element occurs.</p>
</span></td><td><span>from <a href="../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getFullyConverted.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getFullyConverted">getFullyConverted</a></td><td><span class="qldoc-summary"><p>Gets the fully converted form of this expression, including all type casts and other conversions.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getImplicitlyConverted.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getImplicitlyConverted">getImplicitlyConverted</a></td><td><span class="qldoc-summary"><p>Gets this expression with all of its initial implicit casts, but none of  its explicit casts. More precisely, this takes all implicit conversions  up to (but not including) the first explicit cast (if any).</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><span class="deprecated"><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getKind.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getKind">getKind</a></span></td><td><span class="qldoc-summary"><p>Gets an integer indicating the type of expression that this represents.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getLocation.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getLocation">getLocation</a></td><td><span class="qldoc-summary"><p>Gets the location of this expression.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getNumChild.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getNumChild">getNumChild</a></td><td><span class="qldoc-summary"><p>Gets the number of direct children of this expression.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getParent.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getParent">getParent</a></td><td><span class="qldoc-summary"><p>Gets the parent of this expression, if any.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../Element.qll/predicate.Element$Element$getParentScope.0.html" class="ref-link ref-predicate" title="Member predicate Element::getParentScope">getParentScope</a></td><td><span class="qldoc-summary"><p>Gets the parent scope of this <code>Element</code>, if any.  A scope is a <code>Type</code> (<code>Class</code> / <code>Enum</code>), a <code>Namespace</code>, a <code>BlockStmt</code>, a <code>Function</code>,  or certain kinds of <code>Statement</code>.</p>
</span></td><td><span>from <a href="../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getParentWithConversions.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getParentWithConversions">getParentWithConversions</a></td><td><span class="qldoc-summary"><p>Gets the parent of this expression, if any, in an alternative syntax tree  that has <code>Conversion</code>s as part of the tree.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getPrecedence.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getPrecedence">getPrecedence</a></td><td><span class="qldoc-summary"><p>Gets the precedence of the main operator of this expression;  higher precedence binds tighter.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getType.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getType">getType</a></td><td><span class="qldoc-summary"><p>Gets the type of this expression.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getUnconverted.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getUnconverted">getUnconverted</a></td><td><span class="qldoc-summary"><p>Gets the unique non-<code>Conversion</code> expression <code>e</code> for which  <code>this = e.getConversion*()</code>.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getUnderlyingType.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getUnderlyingType">getUnderlyingType</a></td><td><span class="qldoc-summary"><p>Gets the type of this expression after typedefs have been resolved.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getUnspecifiedType.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getUnspecifiedType">getUnspecifiedType</a></td><td><span class="qldoc-summary"><p>Gets the type of this expression after specifiers have been deeply  stripped and typedefs have been resolved.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getValue.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getValue">getValue</a></td><td><span class="qldoc-summary"><p>Gets the value of this expression, if it is a constant.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getValueCategoryString.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getValueCategoryString">getValueCategoryString</a></td><td><span class="qldoc-summary"><p>Gets a string representation of the value category of the expression.  This is intended only for debugging. The possible values are:</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$getValueText.0.html" class="ref-link ref-predicate" title="Member predicate Expr::getValueText">getValueText</a></td><td><span class="qldoc-summary"><p>Gets the source text for the value of this expression, if it is a constant.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$hasChild.2.html" class="ref-link ref-predicate" title="Member predicate Expr::hasChild">hasChild</a></td><td><span class="qldoc-summary"><p>Holds if e is the nth child of this expression.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$hasConversion.0.html" class="ref-link ref-predicate" title="Member predicate Expr::hasConversion">hasConversion</a></td><td><span class="qldoc-summary"><p>Holds if this expression has a conversion.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$hasExplicitConversion.0.html" class="ref-link ref-predicate" title="Member predicate Expr::hasExplicitConversion">hasExplicitConversion</a></td><td><span class="qldoc-summary"><p>Holds if this expression has an explicit conversion.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$hasImplicitConversion.0.html" class="ref-link ref-predicate" title="Member predicate Expr::hasImplicitConversion">hasImplicitConversion</a></td><td><span class="qldoc-summary"><p>Holds if this expression has an implicit conversion.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$hasLValueToRValueConversion.0.html" class="ref-link ref-predicate" title="Member predicate Expr::hasLValueToRValueConversion">hasLValueToRValueConversion</a></td><td><span class="qldoc-summary"><p>Holds if this expression has undergone an <em>lvalue</em>-to-<em>rvalue</em> conversion to  extract its value.  for example:  <code>y = x;</code>  The <code>VariableAccess</code> for <code>x</code> is a <em>prvalue</em>, and <code>hasLValueToRValueConversion()</code>  holds because the value of <code>x</code> was loaded from the location of <code>x</code>.  The <code>VariableAccess</code> for <code>y</code> is an <em>lvalue</em>, and <code>hasLValueToRValueConversion()</code>  does not hold because the value of <code>y</code> was not extracted.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../Element.qll/predicate.Element$Element$isAffectedByMacro.0.html" class="ref-link ref-predicate" title="Member predicate Element::isAffectedByMacro">isAffectedByMacro</a></td><td><span class="qldoc-summary"><p>Holds if this element is affected in any way by a macro. All elements  that are totally or partially generated by a macro are included, so  this is a super-set of <code>isInMacroExpansion</code>.</p>
</span></td><td><span>from <a href="../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$isCompilerGenerated.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isCompilerGenerated">isCompilerGenerated</a></td><td><span class="qldoc-summary"><p>Holds if this is an auxiliary expression generated by the compiler.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../controlflow/ControlFlowGraph.qll/predicate.ControlFlowGraph$ControlFlowNode$isCondition.0.html" class="ref-link ref-predicate" title="Member predicate ControlFlowNode::isCondition">isCondition</a></td><td><span class="qldoc-summary"><p>Holds if this node is the top-level expression of a conditional statement,  meaning that <code>this.getATrueSuccessor()</code> or <code>this.getAFalseSuccessor()</code>  will have a result.</p>
</span></td><td><span>from <a href="../../controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNode.html" class="ref-link ref-type" title="Class ControlFlowNode">ControlFlowNode</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$isConstant.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isConstant">isConstant</a></td><td><span class="qldoc-summary"><p>Holds if this expression has a value that can be determined at compile time.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../Element.qll/predicate.Element$Element$isFromTemplateInstantiation.1.html" class="ref-link ref-predicate" title="Member predicate Element::isFromTemplateInstantiation">isFromTemplateInstantiation</a></td><td><span class="qldoc-summary"><p>Holds if this <code>Element</code> is a part of a template instantiation (but not  the template itself).</p>
</span></td><td><span>from <a href="../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../Element.qll/predicate.Element$Element$isFromUninstantiatedTemplate.1.html" class="ref-link ref-predicate" title="Member predicate Element::isFromUninstantiatedTemplate">isFromUninstantiatedTemplate</a></td><td><span class="qldoc-summary"><p>Holds if this <code>Element</code> is part of a template <code>template</code> (not if it is  part of an instantiation of <code>template</code>). This means it is represented in  the database purely as syntax and without guarantees on the presence or  correctness of type-based operations such as implicit conversions.</p>
</span></td><td><span>from <a href="../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$isGLValueCategory.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isGLValueCategory">isGLValueCategory</a></td><td><span class="qldoc-summary"><p>Holds if this expression is a <em>glvalue</em>. A <em>glvalue</em> is either an <em>lvalue</em> or an  <em>xvalue</em>.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../Element.qll/predicate.Element$Element$isInMacroExpansion.0.html" class="ref-link ref-predicate" title="Member predicate Element::isInMacroExpansion">isInMacroExpansion</a></td><td><span class="qldoc-summary"><p>Holds if this element comes from a macro expansion. Only elements that  are entirely generated by a macro are included - for elements that  partially come from a macro, see <code>isAffectedByMacro</code>.</p>
</span></td><td><span>from <a href="../../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$isLValue.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isLValue">isLValue</a></td><td><span class="qldoc-summary"><p>Holds if this expression is an <em>lvalue</em>, in the sense of having an address.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$isLValueCategory.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isLValueCategory">isLValueCategory</a></td><td><span class="qldoc-summary"><p>Holds if this expression is an <em>lvalue</em>. An <em>lvalue</em> is an expression that  represents a location, rather than a value.  See [basic.lval] for more about lvalues.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$isPRValueCategory.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isPRValueCategory">isPRValueCategory</a></td><td><span class="qldoc-summary"><p>Holds if this expression is a <em>prvalue</em>. A <em>prvalue</em> is an expression that  represents a value, rather than a location.  See [basic.lval] for more about prvalues.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$isParenthesised.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isParenthesised">isParenthesised</a></td><td><span class="qldoc-summary"><p>Holds if this expression is parenthesised.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$isPure.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isPure">isPure</a></td><td><span class="qldoc-summary"><p>Holds if this expression is side-effect free (conservative  approximation). This predicate cannot be overridden;  override mayBeImpure() instead.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$isRValueCategory.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isRValueCategory">isRValueCategory</a></td><td><span class="qldoc-summary"><p>Holds if this expression is an <em>rvalue</em>. An <em>rvalue</em> is either a <em>prvalue</em> or an  <em>xvalue</em>.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$isUnevaluated.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isUnevaluated">isUnevaluated</a></td><td><span class="qldoc-summary"><p>Holds if this expression will not be evaluated because of its context,  such as an expression inside a sizeof.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Expr.qll/predicate.Expr$Expr$isXValueCategory.0.html" class="ref-link ref-predicate" title="Member predicate Expr::isXValueCategory">isXValueCategory</a></td><td><span class="qldoc-summary"><p>Holds if this expression is an <em>xvalue</em>. An <em>xvalue</em> is a location whose  lifetime is about to end (e.g. an <em>rvalue</em> reference returned from a function  call).  See [basic.lval] for more about xvalues.</p>
</span></td><td><span>from <a href="../../exprs/Expr.qll/type.Expr$Expr.html" class="ref-link ref-type" title="Class Expr">Expr</a></span></td></tr><tr><td><a href="../../exprs/Literal.qll/predicate.Literal$Literal$mayBeGloballyImpure.0.html" class="ref-link ref-predicate" title="Member predicate Literal::mayBeGloballyImpure">mayBeGloballyImpure</a></td><td><span class="qldoc-summary"><p>Holds if it is possible that the expression may be impure. If we are not  sure, then it holds. Unlike <code>mayBeImpure()</code>, this predicate does not  consider modifications to temporary local variables to be impure. If you  call a function in which nothing may be globally impure then the function  as a whole will have no side-effects, even if it mutates its own fresh  stack variables.</p>
</span></td><td><span>from <a href="../../exprs/Literal.qll/type.Literal$Literal.html" class="ref-link ref-type" title="Class Literal">Literal</a></span></td></tr><tr><td><a href="../../exprs/Literal.qll/predicate.Literal$Literal$mayBeImpure.0.html" class="ref-link ref-predicate" title="Member predicate Literal::mayBeImpure">mayBeImpure</a></td><td><span class="qldoc-summary"><p>Holds if it is possible that the expression may be impure. If we are not  sure, then it holds.</p>
</span></td><td><span>from <a href="../../exprs/Literal.qll/type.Literal$Literal.html" class="ref-link ref-type" title="Class Literal">Literal</a></span></td></tr><tr><td><a href="../../exprs/Literal.qll/predicate.Literal$Literal$toString.0.html" class="ref-link ref-predicate" title="Member predicate Literal::toString">toString</a></td><td><span class="qldoc-summary"><p>Gets a textual representation of this literal.</p>
</span></td><td><span>from <a href="../../exprs/Literal.qll/type.Literal$Literal.html" class="ref-link ref-type" title="Class Literal">Literal</a></span></td></tr></tbody></table></div></div><div><h2 class="subsection-heading" id="Charpred">Charpred</h2><div class="doc-block"><table><tbody><tr><td><a href="predicate.Printf$FormatLiteral$FormatLiteral.0.html" class="ref-link ref-predicate" title="Characteristic predicate FormatLiteral::FormatLiteral">FormatLiteral</a></td><td></td></tr></tbody></table></div></div></div></div></div><footer id="content-footer">Copyright 2020 GitHub Software UK Ltd.<a title="Privacy statement and tracking preferences" target="_blank" href="https://docs.github.com/github/site-policy/github-privacy-statement">Privacy Statement</a></footer></body></html>