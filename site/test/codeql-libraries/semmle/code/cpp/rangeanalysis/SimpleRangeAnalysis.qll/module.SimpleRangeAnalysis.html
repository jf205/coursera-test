<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="qldoc"><meta name="description" content="API documentation for CodeQL"><meta name="keywords" content="CodeQL,QL,SimpleRangeAnalysis"><meta name="addsearch-category" content="C/C++ CodeQL library"><title>SimpleRangeAnalysis</title><link rel="stylesheet" type="text/css" href="https://unpkg.com/@primer/css/dist/primer.css"><link rel="stylesheet" type="text/css" href="../../../../../qldoc.css"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-5Q9DBRM');</script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q9DBRM" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="Header text-white"><div class="Header-item"><svg class="octicon octicon-mark-github mr-2" height="32" viewbox="0 0 16 16" width="32"><path fill-rule="even-odd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg></div><div class="Header-item--full f2 text-bold">CodeQL library for C/C++</div><div class="Header-item"><span>Version 1.26.0</span></div><div class="Header-item .text-gray-light"><div class="nav-section"><a href="../../../../../index.html">Index</a></div></div><div class="Header-item"><a title="Search the CodeQL libraries" target="_blank" href="https://help.semmle.com/home/help/search-results-qldoc.html"><span class=".text-gray-light">Search</span></a></div></div><div id="main"><nav id="sidebar"><div id="sidebar-content" class="pt-2"><div class="nav-section"><p>For other CodeQL resources, including tutorials and examples, see <a href="https://help.semmle.com/QL/learn-ql/" class="learn-ql-link" target="_blank">Learning CodeQL</a><p>.</p></p><h2 class="section-heading"><a href="module.SimpleRangeAnalysis.html" class="ref-link ref-module">SimpleRangeAnalysis</a></h2><div class="doc-block"><ol class="section-links"><li></li><li></li><li><a href="module.SimpleRangeAnalysis.html#Import%20path">Import path</a></li><li><a href="module.SimpleRangeAnalysis.html#Imports">Imports</a></li><li><a href="module.SimpleRangeAnalysis.html#Predicates">Predicates</a></li><li><a href="module.SimpleRangeAnalysis.html#Modules">Modules</a></li></ol></div></div></div></nav><div class="overflow-y-auto width-full pt-2"><div id="content"><div><h1 class="section-heading" id="SimpleRangeAnalysis"><span><span>Module <span><a href="module.SimpleRangeAnalysis.html" class="ref-link ref-module" title="Module SimpleRangeAnalysis">SimpleRangeAnalysis</a></span></span></span></h1></div><div><div class="doc-block"><div class="qldoc"><p>Simple range analysis library. Range analysis is usually done as an
abstract interpretation over the lattice of range values. (A range is a
pair, containing a lower and upper bound for the value.) The problem
with this approach is that the lattice is very tall, which means it can
take an extremely large number of iterations to find the least fixed
point. This example illustrates the problem:</p>
<pre><code>int count = 0;
for (; p; p = p-&gt;next) {
  count = count+1;
}
</code></pre>
<p>The range of &lsquo;count&rsquo; is initially (0,0), then (0,1) on the second
iteration, (0,2) on the third iteration, and so on until we eventually
reach maxInt.</p>
<p>This library uses a crude solution to the problem described above: if
the upper (or lower) bound of an expression might depend recursively on
itself then we round it up (down for lower bounds) to one of a fixed set
of values, such as 0, 1, 2, 256, and +Inf. This limits the height of the
lattice which ensures that the analysis will terminate in a reasonable
amount of time. This solution is similar to the abstract interpretation
technique known as &lsquo;widening&rsquo;, but it is less precise because we are
unable to inspect the bounds from the previous iteration of the fixed
point computation. For example, widening might be able to deduce that
the lower bound is -11 but we would approximate it to -16.</p>
<p>QL does not allow us to compute an aggregate over a recursive
sub-expression, so we cannot compute the minimum lower bound and maximum
upper bound during the recursive phase of the query. Instead, the
recursive phase computes a set of lower bounds and a set of upper bounds
for each expression. We compute the minimum lower bound and maximum
upper bound after the recursion is finished. This is another reason why
we need to limit the number of bounds per expression, because they will
all be stored until the recursive phase is finished.</p>
<p>The ranges are represented using a pair of floating point numbers. This
is simpler than using integers because floating point numbers cannot
overflow and wrap. It is also convenient because we can detect overflow
and negative overflow by looking for bounds that are outside the range
of the type.</p>
</div></div></div><div><h2 class="subsection-heading" id="Import path">Import path</h2><div class="doc-block"><code>import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis</code></div></div><div><h2 class="subsection-heading" id="Imports">Imports</h2><div class="doc-block"><table><tbody><tr><td><a href="../RangeSSA.qll/module.RangeSSA.html" class="ref-link ref-module" title="Module RangeSSA">RangeSSA</a></td><td><span class="qldoc-summary"><p>This library is a clone of semmle.code.cpp.controlflow.SSA, with  only one difference: extra phi definitions are added after  guards. For example:  <code>x = f(); if (x &lt; 10) { // Block 1 ... } else { // Block 2 ... }</code>  In standard SSA, basic blocks 1 and 2 do not need phi definitions  for <code>x</code>, because they are dominated by the definition of <code>x</code> on the  first line.  In RangeSSA, however, we add phi definitions for <code>x</code> at  the beginning of blocks 1 and 2. This is useful for range analysis  because it enables us to deduce a more accurate range for <code>x</code> in the  two branches of the if-statement.</p>
</span></td></tr><tr><td><a href="module.SimpleRangeAnalysis$SimpleRangeAnalysisCached.html" class="ref-link ref-module" title="Module SimpleRangeAnalysis::SimpleRangeAnalysisCached">SimpleRangeAnalysisCached</a></td><td></td></tr><tr><td><a href="../../../../../cpp.qll/module.cpp.html" class="ref-link ref-module" title="Module cpp">cpp</a></td><td><span class="qldoc-summary"><p>Provides classes and predicates for working with C/C++ code.</p>
</span></td></tr></tbody></table></div></div><div><h2 class="subsection-heading" id="Predicates">Predicates</h2><div class="doc-block"><table><tbody><tr><td><span class="deprecated"><a href="predicate.SimpleRangeAnalysis$negative_overflow.1.html" class="ref-link ref-predicate" title="Predicate SimpleRangeAnalysis::negative_overflow">negative_overflow</a></span></td><td><span class="qldoc-summary"><p>Holds if the expression might overflow negatively. This predicate  does not consider the possibility that the expression might overflow  due to a conversion.</p>
</span></td></tr><tr><td><a href="predicate.SimpleRangeAnalysis$nonNanGuardedVariable.3.html" class="ref-link ref-predicate" title="Predicate SimpleRangeAnalysis::nonNanGuardedVariable">nonNanGuardedVariable</a></td><td><span class="qldoc-summary"><p>Holds if in the <code>branch</code> branch of a guard <code>guard</code> involving <code>v</code>,  we know that <code>v</code> is not NaN, and therefore it is safe to make range  inferences about <code>v</code>.</p>
</span></td></tr><tr><td><span class="deprecated"><a href="predicate.SimpleRangeAnalysis$positive_overflow.1.html" class="ref-link ref-predicate" title="Predicate SimpleRangeAnalysis::positive_overflow">positive_overflow</a></span></td><td><span class="qldoc-summary"><p>Holds if the expression might overflow positively. This predicate  does not consider the possibility that the expression might overflow  due to a conversion.</p>
</span></td></tr><tr><td><a href="predicate.SimpleRangeAnalysis$safeFloor.1.html" class="ref-link ref-predicate" title="Predicate SimpleRangeAnalysis::safeFloor">safeFloor</a></td><td><span class="qldoc-summary"><p>Gets the floor of <code>v</code>, with additional logic to work around issues with  large numbers.</p>
</span></td></tr></tbody></table></div></div><div><h2 class="subsection-heading" id="Modules">Modules</h2><div class="doc-block"><table><tbody><tr><td><a href="module.SimpleRangeAnalysis$SimpleRangeAnalysisInternal.html" class="ref-link ref-module" title="Module SimpleRangeAnalysis::SimpleRangeAnalysisInternal">SimpleRangeAnalysisInternal</a></td><td><span class="qldoc-summary"><p>INTERNAL: do not use. This module contains utilities for use in the  experimental <code>SimpleRangeAnalysisExpr</code> module.</p>
</span></td></tr></tbody></table></div></div></div></div></div><footer id="content-footer">Copyright 2020 GitHub Software UK Ltd.<a title="Privacy statement and tracking preferences" target="_blank" href="https://docs.github.com/github/site-policy/github-privacy-statement">Privacy Statement</a></footer></body></html>