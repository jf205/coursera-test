<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="qldoc"><meta name="description" content="API documentation for CodeQL"><meta name="keywords" content="CodeQL,QL,IR"><meta name="addsearch-category" content="C/C++ CodeQL library"><title>IR</title><link rel="stylesheet" type="text/css" href="https://unpkg.com/@primer/css/dist/primer.css"><link rel="stylesheet" type="text/css" href="../../../../../qldoc.css"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-5Q9DBRM');</script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q9DBRM" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="Header text-white"><div class="Header-item"><svg class="octicon octicon-mark-github mr-2" height="32" viewbox="0 0 16 16" width="32"><path fill-rule="even-odd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg></div><div class="Header-item--full f2 text-bold">CodeQL library for C/C++</div><div class="Header-item"><span>Version 1.26.0</span></div><div class="Header-item .text-gray-light"><div class="nav-section"><a href="../../../../../index.html">Index</a></div></div><div class="Header-item"><a title="Search the CodeQL libraries" target="_blank" href="https://help.semmle.com/home/help/search-results-qldoc.html"><span class=".text-gray-light">Search</span></a></div></div><div id="main"><nav id="sidebar"><div id="sidebar-content" class="pt-2"><div class="nav-section"><p>For other CodeQL resources, including tutorials and examples, see <a href="https://help.semmle.com/QL/learn-ql/" class="learn-ql-link" target="_blank">Learning CodeQL</a><p>.</p></p><h2 class="section-heading"><a href="module.IR.html" class="ref-link ref-module">IR</a></h2><div class="doc-block"><ol class="section-links"><li></li><li></li><li><a href="module.IR.html#Import%20path">Import path</a></li><li><a href="module.IR.html#Classes">Classes</a></li><li><a href="module.IR.html#Modules">Modules</a></li></ol></div></div></div></nav><div class="overflow-y-auto width-full pt-2"><div id="content"><div><h1 class="section-heading" id="IR"><span><span>Module <span><a href="module.IR.html" class="ref-link ref-module" title="Module IR">IR</a></span></span></span></h1></div><div><div class="doc-block"><div class="qldoc"><p>Provides classes that describe the Intermediate Representation (IR) of the program.</p>
<p>The IR is a representation of the semantics of the program, with very little dependence on the
syntax that was used to write the program. For example, in C++, the statements <code>i += 1;</code>, <code>i++</code>,
and <code>++i</code> all have the same semantic effect, but appear in the AST as three different types of
<code>Expr</code> node. In the IR, all three statements are broken down into a sequence of fundamental
operations similar to:</p>
<pre><code class="numbered-code"><span class="numbered-code-line">r1(int*) = VariableAddress[i]  // Compute the address of variable `i`
</span><span class="numbered-code-line">r2(int) = Load &amp;:r1, m0  // Load the value of `i`
</span><span class="numbered-code-line">r3(int) = Constant[1]  // An integer constant with the value `1`
</span><span class="numbered-code-line">r4(int) = Add r2, r3  // Add `1` to the value of `i`
</span><span class="numbered-code-line">r5(int) = Store &amp;r1, r4  // Store the new value back into the variable `i`
</span></code></pre>
<p>This allows IR-based analysis to focus on the fundamental operations, rather than having to be
concerned with the various ways of expressing those operations in source code.</p>
<p>The key classes in the IR are:</p>
<ul>
<li><code>IRFunction</code> - Contains the IR for an entire function definition, including all of that
function&rsquo;s <code>Instruction</code>s, <code>IRBlock</code>s, and <code>IRVariables</code>.</li>
<li><code>Instruction</code> - A single operation in the IR. An instruction specifies the operation to be
performed, the operands that produce the inputs to that operation, and the type of the result
of the operation. Control flows from an <code>Instruction</code> to one of a set of successor
<code>Instruction</code>s.</li>
<li><code>Operand</code> - An input value of an <code>Instruction</code>. All inputs of an <code>Instruction</code> are explicitly
represented as <code>Operand</code>s, even if the input was implicit in the source code. An <code>Operand</code> has
a link to the <code>Instruction</code> that consumes its value (its &ldquo;use&rdquo;) and a link to the <code>Instruction</code>
that produces its value (its &ldquo;definition&rdquo;).</li>
<li><code>IRVariable</code> - A variable accessed by the IR for a particular function. An <code>IRVariable</code> is
created for each variable directly accessed by the function. In addition, <code>IRVariable</code>s are
created to represent certain temporary storage locations that do not have explicitly declared
variables in the source code, such as the return value of the function.</li>
<li><code>IRBlock</code> - A &ldquo;basic block&rdquo; in the control flow graph of a function. An <code>IRBlock</code> contains a
sequence of instructions such that control flow can only enter the block at the first
instruction, and can only leave the block from the last instruction.</li>
<li><code>IRType</code> - The type of a value accessed in the IR. Unlike the <code>Type</code> class in the AST, <code>IRType</code>
is language-neutral. For example, in C++, <code>unsigned int</code>, <code>char32_t</code>, and <code>wchar_t</code> might all
be represented as the <code>IRType</code> <code>uint4</code>, a four-byte unsigned integer.</li>
</ul>
</div></div></div><div><h2 class="subsection-heading" id="Import path">Import path</h2><div class="doc-block"><code>import semmle.code.cpp.ir.IR</code></div></div><div><h2 class="subsection-heading" id="Classes">Classes</h2><div class="doc-block"><table><tbody><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$AddInstruction.html" class="ref-link ref-type" title="Class AddInstruction">AddInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that computes the sum of two numeric operands.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$AddressOperand.html" class="ref-link ref-type" title="Class AddressOperand">AddressOperand</a></td><td><span class="qldoc-summary"><p>The address operand of an instruction that loads or stores a value from  memory (e.g. <code>Load</code>, <code>Store</code>).</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$AliasedDefinitionInstruction.html" class="ref-link ref-type" title="Class AliasedDefinitionInstruction">AliasedDefinitionInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that initializes all escaped memory.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$AliasedUseInstruction.html" class="ref-link ref-type" title="Class AliasedUseInstruction">AliasedUseInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that consumes all escaped memory on exit from the function.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$ArgumentOperand.html" class="ref-link ref-type" title="Class ArgumentOperand">ArgumentOperand</a></td><td><span class="qldoc-summary"><p>An operand representing an argument to a function call. This includes both  positional arguments (represented by <code>PositionalArgumentOperand</code>) and the  implicit <code>this</code> argument, if any (represented by <code>ThisArgumentOperand</code>).</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ArithmeticInstruction.html" class="ref-link ref-type" title="Class ArithmeticInstruction">ArithmeticInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that computes the result of an arithmetic operation.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$ArithmeticOpcode.html" class="ref-link ref-type" title="Class ArithmeticOpcode">ArithmeticOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for an <code>ArithmeticInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$BinaryArithmeticInstruction.html" class="ref-link ref-type" title="Class BinaryArithmeticInstruction">BinaryArithmeticInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that performs an arithmetic operation on two numeric operands.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$BinaryArithmeticOpcode.html" class="ref-link ref-type" title="Class BinaryArithmeticOpcode">BinaryArithmeticOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>BinaryArithmeticInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$BinaryBitwiseInstruction.html" class="ref-link ref-type" title="Class BinaryBitwiseInstruction">BinaryBitwiseInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that performs a bitwise operation on two integer operands.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$BinaryBitwiseOpcode.html" class="ref-link ref-type" title="Class BinaryBitwiseOpcode">BinaryBitwiseOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>BinaryBitwiseInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$BinaryInstruction.html" class="ref-link ref-type" title="Class BinaryInstruction">BinaryInstruction</a></td><td><span class="qldoc-summary"><p>An instruction whose result is computed from two operands.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$BinaryOpcode.html" class="ref-link ref-type" title="Class BinaryOpcode">BinaryOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>BinaryInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$BitAndInstruction.html" class="ref-link ref-type" title="Class BitAndInstruction">BitAndInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that computes the bitwise &ldquo;and&rdquo; of two integer operands.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$BitComplementInstruction.html" class="ref-link ref-type" title="Class BitComplementInstruction">BitComplementInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that computes the bitwise complement of its operand.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$BitOrInstruction.html" class="ref-link ref-type" title="Class BitOrInstruction">BitOrInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that computes the bitwise &ldquo;or&rdquo; of two integer operands.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$BitXorInstruction.html" class="ref-link ref-type" title="Class BitXorInstruction">BitXorInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that computes the bitwise &ldquo;xor&rdquo; of two integer operands.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$BitwiseInstruction.html" class="ref-link ref-type" title="Class BitwiseInstruction">BitwiseInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that computes the result of a bitwise operation.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$BitwiseOpcode.html" class="ref-link ref-type" title="Class BitwiseOpcode">BitwiseOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>BitwiseInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$BufferAccessOpcode.html" class="ref-link ref-type" title="Class BufferAccessOpcode">BufferAccessOpcode</a></td><td><span class="qldoc-summary"><p>An opcode that accesses a memory buffer.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$BufferMayWriteSideEffectInstruction.html" class="ref-link ref-type" title="Class BufferMayWriteSideEffectInstruction">BufferMayWriteSideEffectInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing the write of an indirect buffer parameter within a function call.</p>
</span></td></tr><tr><td><a href="../implementation/MemoryAccessKind.qll/type.MemoryAccessKind$BufferMemoryAccess.html" class="ref-link ref-type" title="Class BufferMemoryAccess">BufferMemoryAccess</a></td><td><span class="qldoc-summary"><p>The operand or result accesses memory starting at the address specified by the <code>AddressOperand</code>  on the same instruction, accessing a number of consecutive elements given by the  <code>BufferSizeOperand</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$BufferMustWriteSideEffectInstruction.html" class="ref-link ref-type" title="Class BufferMustWriteSideEffectInstruction">BufferMustWriteSideEffectInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing the write of an indirect buffer parameter within a function call. The  entire buffer is overwritten.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$BufferReadSideEffectInstruction.html" class="ref-link ref-type" title="Class BufferReadSideEffectInstruction">BufferReadSideEffectInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing the read of an indirect buffer parameter within a function call.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$BufferSizeOperand.html" class="ref-link ref-type" title="Class BufferSizeOperand">BufferSizeOperand</a></td><td><span class="qldoc-summary"><p>The buffer size operand of an instruction that represents a read or write of  a buffer.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$BuiltInInstruction.html" class="ref-link ref-type" title="Class BuiltInInstruction">BuiltInInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing a built-in operation that does not have a specific opcode. The  actual operation is specified by the <code>getBuiltInOperation()</code> predicate.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$BuiltInOperationInstruction.html" class="ref-link ref-type" title="Class BuiltInOperationInstruction">BuiltInOperationInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing a built-in operation.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$BuiltInOperationOpcode.html" class="ref-link ref-type" title="Class BuiltInOperationOpcode">BuiltInOperationOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>BuiltInOperationInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CallInstruction.html" class="ref-link ref-type" title="Class CallInstruction">CallInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that calls a function.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CallReadSideEffectInstruction.html" class="ref-link ref-type" title="Class CallReadSideEffectInstruction">CallReadSideEffectInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing the side effect of a function call on any memory  that might be read by that call.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CallSideEffectInstruction.html" class="ref-link ref-type" title="Class CallSideEffectInstruction">CallSideEffectInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing the side effect of a function call on any memory that might be  accessed by that call.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$CallTargetOperand.html" class="ref-link ref-type" title="Class CallTargetOperand">CallTargetOperand</a></td><td><span class="qldoc-summary"><p>The operand representing the target function of an <code>Call</code> instruction.</p>
</span></td></tr><tr><td><a href="../implementation/EdgeKind.qll/type.EdgeKind$CaseEdge.html" class="ref-link ref-type" title="Class CaseEdge">CaseEdge</a></td><td><span class="qldoc-summary"><p>A &ldquo;case&rdquo; edge, representing the successor of a <code>Switch</code> instruction when the  the condition value matches a correponding <code>case</code> label.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CatchAnyInstruction.html" class="ref-link ref-type" title="Class CatchAnyInstruction">CatchAnyInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that catches any exception.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CatchByTypeInstruction.html" class="ref-link ref-type" title="Class CatchByTypeInstruction">CatchByTypeInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that catches an exception of a specific type.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CatchInstruction.html" class="ref-link ref-type" title="Class CatchInstruction">CatchInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that starts a <code>catch</code> handler.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$CatchOpcode.html" class="ref-link ref-type" title="Class CatchOpcode">CatchOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>CatchInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CheckedConvertOrNullInstruction.html" class="ref-link ref-type" title="Class CheckedConvertOrNullInstruction">CheckedConvertOrNullInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that converts the address of a polymorphic object to the address of a different  subobject of the same polymorphic object, returning a null address if the dynamic type of the  object is not compatible with the result type.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CheckedConvertOrThrowInstruction.html" class="ref-link ref-type" title="Class CheckedConvertOrThrowInstruction">CheckedConvertOrThrowInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that converts the address of a polymorphic object to the address of a different  subobject of the same polymorphic object, throwing an exception if the dynamic type of the object  is not compatible with the result type.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ChiInstruction.html" class="ref-link ref-type" title="Class ChiInstruction">ChiInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing the effect that a write to a memory may have on potential aliases of  that memory.</p>
</span></td></tr><tr><td><a href="../implementation/MemoryAccessKind.qll/type.MemoryAccessKind$ChiPartialMemoryAccess.html" class="ref-link ref-type" title="Class ChiPartialMemoryAccess">ChiPartialMemoryAccess</a></td><td><span class="qldoc-summary"><p>The operand is a ChiPartial operand, which accesses the same memory as its  definition.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$ChiPartialOperand.html" class="ref-link ref-type" title="Class ChiPartialOperand">ChiPartialOperand</a></td><td><span class="qldoc-summary"><p>The partial operand of a Chi node, representing the value being written to part of the memory.</p>
</span></td></tr><tr><td><a href="../implementation/MemoryAccessKind.qll/type.MemoryAccessKind$ChiTotalMemoryAccess.html" class="ref-link ref-type" title="Class ChiTotalMemoryAccess">ChiTotalMemoryAccess</a></td><td><span class="qldoc-summary"><p>The operand is a ChiTotal operand, which accesses the same memory as its  definition.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$ChiTotalOperand.html" class="ref-link ref-type" title="Class ChiTotalOperand">ChiTotalOperand</a></td><td><span class="qldoc-summary"><p>The total operand of a Chi node, representing the previous value of the memory.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CompareEQInstruction.html" class="ref-link ref-type" title="Class CompareEQInstruction">CompareEQInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns a <code>true</code> result if its operands are equal.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CompareGEInstruction.html" class="ref-link ref-type" title="Class CompareGEInstruction">CompareGEInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns a <code>true</code> result if its left operand is greater than or equal to its  right operand.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CompareGTInstruction.html" class="ref-link ref-type" title="Class CompareGTInstruction">CompareGTInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns a <code>true</code> result if its left operand is greater than its right operand.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CompareInstruction.html" class="ref-link ref-type" title="Class CompareInstruction">CompareInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that compares two numeric operands.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CompareLEInstruction.html" class="ref-link ref-type" title="Class CompareLEInstruction">CompareLEInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns a <code>true</code> result if its left operand is less than or equal to its  right operand.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CompareLTInstruction.html" class="ref-link ref-type" title="Class CompareLTInstruction">CompareLTInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns a <code>true</code> result if its left operand is less than its right operand.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CompareNEInstruction.html" class="ref-link ref-type" title="Class CompareNEInstruction">CompareNEInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns a <code>true</code> result if its operands are not equal.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$CompareOpcode.html" class="ref-link ref-type" title="Class CompareOpcode">CompareOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>CompareInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CompleteObjectAddressInstruction.html" class="ref-link ref-type" title="Class CompleteObjectAddressInstruction">CompleteObjectAddressInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns the address of the complete object that contains the subobject  pointed to by its operand.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$ConditionOperand.html" class="ref-link ref-type" title="Class ConditionOperand">ConditionOperand</a></td><td><span class="qldoc-summary"><p>The condition operand of a <code>ConditionalBranch</code> or <code>Switch</code> instruction.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ConditionalBranchInstruction.html" class="ref-link ref-type" title="Class ConditionalBranchInstruction">ConditionalBranchInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that branches to one of two successor instructions based on the value of a Boolean  operand.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ConstantInstruction.html" class="ref-link ref-type" title="Class ConstantInstruction">ConstantInstruction</a></td><td><span class="qldoc-summary"><p>An instruction whose result is a constant value.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ConstantValueInstruction.html" class="ref-link ref-type" title="Class ConstantValueInstruction">ConstantValueInstruction</a></td><td><span class="qldoc-summary"><p>An instruction whose result is a compile-time constant value.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ConvertInstruction.html" class="ref-link ref-type" title="Class ConvertInstruction">ConvertInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that converts the value of its operand to a value of a different type.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ConvertToBaseInstruction.html" class="ref-link ref-type" title="Class ConvertToBaseInstruction">ConvertToBaseInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that converts from the address of a derived class to the address of a base class.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$ConvertToBaseOpcode.html" class="ref-link ref-type" title="Class ConvertToBaseOpcode">ConvertToBaseOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>ConvertToBaseInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ConvertToDerivedInstruction.html" class="ref-link ref-type" title="Class ConvertToDerivedInstruction">ConvertToDerivedInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that converts from the address of a base class to the address of a direct  non-virtual derived class.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ConvertToNonVirtualBaseInstruction.html" class="ref-link ref-type" title="Class ConvertToNonVirtualBaseInstruction">ConvertToNonVirtualBaseInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that converts from the address of a derived class to the address of a direct  non-virtual base class.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ConvertToVirtualBaseInstruction.html" class="ref-link ref-type" title="Class ConvertToVirtualBaseInstruction">ConvertToVirtualBaseInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that converts from the address of a derived class to the address of a virtual base  class.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CopyInstruction.html" class="ref-link ref-type" title="Class CopyInstruction">CopyInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns a copy of its operand.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$CopyOpcode.html" class="ref-link ref-type" title="Class CopyOpcode">CopyOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>CopyInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$CopyValueInstruction.html" class="ref-link ref-type" title="Class CopyValueInstruction">CopyValueInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns a register result containing a copy of its register operand.</p>
</span></td></tr><tr><td><a href="../implementation/EdgeKind.qll/type.EdgeKind$DefaultEdge.html" class="ref-link ref-type" title="Class DefaultEdge">DefaultEdge</a></td><td><span class="qldoc-summary"><p>A &ldquo;default&rdquo; edge, representing the successor of a <code>Switch</code> instruction when  none of the case values matches the condition value.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$DivInstruction.html" class="ref-link ref-type" title="Class DivInstruction">DivInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that computes the quotient of two numeric operands.</p>
</span></td></tr><tr><td><a href="../implementation/EdgeKind.qll/type.EdgeKind$EdgeKind.html" class="ref-link ref-type" title="Class EdgeKind">EdgeKind</a></td><td><span class="qldoc-summary"><p>Represents the kind of an edge in the IR control flow graph. Each  <code>Instruction</code> or <code>IRBlock</code> has at most one successor of any single  <code>EdgeKind</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ElementsAddressInstruction.html" class="ref-link ref-type" title="Class ElementsAddressInstruction">ElementsAddressInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that computes the address of the first element of a managed array.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$EnterFunctionInstruction.html" class="ref-link ref-type" title="Class EnterFunctionInstruction">EnterFunctionInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing the entry point to a function.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$EntireAllocationAccessOpcode.html" class="ref-link ref-type" title="Class EntireAllocationAccessOpcode">EntireAllocationAccessOpcode</a></td><td><span class="qldoc-summary"><p>An opcode that access an entire memory allocation.</p>
</span></td></tr><tr><td><a href="../implementation/MemoryAccessKind.qll/type.MemoryAccessKind$EntireAllocationMemoryAccess.html" class="ref-link ref-type" title="Class EntireAllocationMemoryAccess">EntireAllocationMemoryAccess</a></td><td><span class="qldoc-summary"><p>The operand or results accesses all memory in the contiguous allocation that contains the address  specified by the <code>AddressOperand</code> on the same instruction.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$EntireAllocationReadOpcode.html" class="ref-link ref-type" title="Class EntireAllocationReadOpcode">EntireAllocationReadOpcode</a></td><td><span class="qldoc-summary"><p>An opcode that reads from an entire memory allocation.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$EntireAllocationWriteOpcode.html" class="ref-link ref-type" title="Class EntireAllocationWriteOpcode">EntireAllocationWriteOpcode</a></td><td><span class="qldoc-summary"><p>An opcode that write to an entire memory allocation.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ErrorInstruction.html" class="ref-link ref-type" title="Class ErrorInstruction">ErrorInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that produces a well-defined but unknown result and has  unknown side effects, including side effects that are not conservatively  modeled in the SSA graph.</p>
</span></td></tr><tr><td><a href="../implementation/MemoryAccessKind.qll/type.MemoryAccessKind$EscapedMemoryAccess.html" class="ref-link ref-type" title="Class EscapedMemoryAccess">EscapedMemoryAccess</a></td><td><span class="qldoc-summary"><p>The operand or result accesses all memory whose address has escaped.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$EscapedReadOpcode.html" class="ref-link ref-type" title="Class EscapedReadOpcode">EscapedReadOpcode</a></td><td><span class="qldoc-summary"><p>An opcode that might read from any escaped memory location.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$EscapedWriteOpcode.html" class="ref-link ref-type" title="Class EscapedWriteOpcode">EscapedWriteOpcode</a></td><td><span class="qldoc-summary"><p>An opcode that might write to any escaped memory location.</p>
</span></td></tr><tr><td><a href="../implementation/EdgeKind.qll/type.EdgeKind$ExceptionEdge.html" class="ref-link ref-type" title="Class ExceptionEdge">ExceptionEdge</a></td><td><span class="qldoc-summary"><p>An &ldquo;exception&rdquo; edge, representing the successor of an instruction when that  instruction&rsquo;s evaluation throws an exception.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ExitFunctionInstruction.html" class="ref-link ref-type" title="Class ExitFunctionInstruction">ExitFunctionInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing the exit point of a function.</p>
</span></td></tr><tr><td><a href="../implementation/EdgeKind.qll/type.EdgeKind$FalseEdge.html" class="ref-link ref-type" title="Class FalseEdge">FalseEdge</a></td><td><span class="qldoc-summary"><p>A &ldquo;false&rdquo; edge, representing the successor of a conditional branch when the  condition is zero.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$FieldAddressInstruction.html" class="ref-link ref-type" title="Class FieldAddressInstruction">FieldAddressInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that computes the address of a non-static field of an object.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$FieldInstruction.html" class="ref-link ref-type" title="Class FieldInstruction">FieldInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that refers to a field of a class, struct, or union.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$FloatConstantInstruction.html" class="ref-link ref-type" title="Class FloatConstantInstruction">FloatConstantInstruction</a></td><td><span class="qldoc-summary"><p>An instruction whose result is a constant value of floating-point type.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$FunctionAddressInstruction.html" class="ref-link ref-type" title="Class FunctionAddressInstruction">FunctionAddressInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns the address of a function.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$FunctionInstruction.html" class="ref-link ref-type" title="Class FunctionInstruction">FunctionInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that refers to a function.</p>
</span></td></tr><tr><td><a href="../implementation/EdgeKind.qll/type.EdgeKind$GotoEdge.html" class="ref-link ref-type" title="Class GotoEdge">GotoEdge</a></td><td><span class="qldoc-summary"><p>A &ldquo;goto&rdquo; edge, representing the unconditional successor of an <code>Instruction</code>  or <code>IRBlock</code>.</p>
</span></td></tr><tr><td><a href="../implementation/IRType.qll/type.IRType$IRAddressType.html" class="ref-link ref-type" title="Class IRAddressType">IRAddressType</a></td><td><span class="qldoc-summary"><p>An address type, representing the memory address of data. Used to represent pointers, references,  and lvalues, include those that are garbage collected.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRVariable.qll/type.IRVariable$IRAutomaticUserVariable.html" class="ref-link ref-type" title="Class IRAutomaticUserVariable">IRAutomaticUserVariable</a></td><td><span class="qldoc-summary"><p>A user-declared variable that is allocated on the stack. This includes all parameters and  non-static local variables.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRVariable.qll/type.IRVariable$IRAutomaticVariable.html" class="ref-link ref-type" title="Class IRAutomaticVariable">IRAutomaticVariable</a></td><td><span class="qldoc-summary"><p>A variable (user-declared or temporary) that is allocated on the stack. This includes all  parameters, non-static local variables, and temporary variables.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRBlock.qll/type.IRBlock$IRBlock.html" class="ref-link ref-type" title="Class IRBlock">IRBlock</a></td><td><span class="qldoc-summary"><p>A basic block with additional information about its predecessor and successor edges. Each edge  corresponds to the control flow between the last instruction of one block and the first  instruction of another block.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRBlock.qll/type.IRBlock$IRBlockBase.html" class="ref-link ref-type" title="Class IRBlockBase">IRBlockBase</a></td><td><span class="qldoc-summary"><p>A basic block in the IR. A basic block consists of a sequence of <code>Instructions</code> with the only  incoming edges at the beginning of the sequence and the only outgoing edges at the end of the  sequence.</p>
</span></td></tr><tr><td><a href="../implementation/IRType.qll/type.IRType$IRBooleanType.html" class="ref-link ref-type" title="Class IRBooleanType">IRBooleanType</a></td><td><span class="qldoc-summary"><p>A Boolean type, which can hold the values <code>true</code> (non-zero) or <code>false</code> (zero).</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRVariable.qll/type.IRVariable$IRDynamicInitializationFlag.html" class="ref-link ref-type" title="Class IRDynamicInitializationFlag">IRDynamicInitializationFlag</a></td><td><span class="qldoc-summary"><p>A variable generated to track whether a specific non-stack variable has been initialized. This is  used to model the runtime initialization of static local variables in C++, as well as static  fields in C#.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRVariable.qll/type.IRVariable$IREllipsisVariable.html" class="ref-link ref-type" title="Class IREllipsisVariable">IREllipsisVariable</a></td><td><span class="qldoc-summary"><p>A temporary variable generated to hold the contents of all arguments passed to the <code>...</code> of a  function that accepts a variable number of arguments.</p>
</span></td></tr><tr><td><a href="../implementation/IRType.qll/type.IRType$IRErrorType.html" class="ref-link ref-type" title="Class IRErrorType">IRErrorType</a></td><td><span class="qldoc-summary"><p>An error type. Used when an error in the source code prevents the extractor from determining the  proper type.</p>
</span></td></tr><tr><td><a href="../implementation/IRType.qll/type.IRType$IRFloatingPointType.html" class="ref-link ref-type" title="Class IRFloatingPointType">IRFloatingPointType</a></td><td><span class="qldoc-summary"><p>A floating-point type.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRFunction.qll/type.IRFunction$IRFunction.html" class="ref-link ref-type" title="Class IRFunction">IRFunction</a></td><td><span class="qldoc-summary"><p>The IR for a function.</p>
</span></td></tr><tr><td><a href="../implementation/IRType.qll/type.IRType$IRFunctionAddressType.html" class="ref-link ref-type" title="Class IRFunctionAddressType">IRFunctionAddressType</a></td><td><span class="qldoc-summary"><p>An address type, representing the memory address of code. Used to represent function pointers,  function references, and the target of a direct function call.</p>
</span></td></tr><tr><td><a href="../implementation/internal/IRFunctionBase.qll/type.IRFunctionBase$IRFunctionBase.html" class="ref-link ref-type" title="Class IRFunctionBase">IRFunctionBase</a></td><td><span class="qldoc-summary"><p>The IR for a function. This base class contains only the predicates that are the same between all  phases of the IR. Each instantiation of <code>IRFunction</code> extends this class.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRVariable.qll/type.IRVariable$IRGeneratedVariable.html" class="ref-link ref-type" title="Class IRGeneratedVariable">IRGeneratedVariable</a></td><td><span class="qldoc-summary"><p>A variable that is not user-declared. This includes temporary variables generated as part of IR  construction, as well as string literals.</p>
</span></td></tr><tr><td><a href="../implementation/IRType.qll/type.IRType$IRIntegerType.html" class="ref-link ref-type" title="Class IRIntegerType">IRIntegerType</a></td><td><span class="qldoc-summary"><p>An integer type. This includes <code>IRSignedIntegerType</code> and <code>IRUnsignedIntegerType</code>.</p>
</span></td></tr><tr><td><a href="../implementation/IRType.qll/type.IRType$IRNumericType.html" class="ref-link ref-type" title="Class IRNumericType">IRNumericType</a></td><td><span class="qldoc-summary"><p>A numeric type. This includes <code>IRSignedIntegerType</code>, <code>IRUnsignedIntegerType</code>, and  <code>IRFloatingPointType</code>.</p>
</span></td></tr><tr><td><a href="../implementation/IRType.qll/type.IRType$IROpaqueType.html" class="ref-link ref-type" title="Class IROpaqueType">IROpaqueType</a></td><td><span class="qldoc-summary"><p>A type with known size that does not fit any of the other kinds of type. Used to represent  classes, structs, unions, fixed-size arrays, pointers-to-member, and more.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRVariable.qll/type.IRVariable$IRParameter.html" class="ref-link ref-type" title="Class IRParameter">IRParameter</a></td><td><span class="qldoc-summary"><p>An IR variable which acts like a function parameter, including positional parameters and the  temporary variables generated for <code>this</code> and ellipsis parameters.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRVariable.qll/type.IRVariable$IRPositionalParameter.html" class="ref-link ref-type" title="Class IRPositionalParameter">IRPositionalParameter</a></td><td><span class="qldoc-summary"><p>An IR variable representing a positional parameter.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IR.qll/type.IR$IRPropertyProvider.html" class="ref-link ref-type" title="Class IRPropertyProvider">IRPropertyProvider</a></td><td><span class="qldoc-summary"><p>A class that provides additional properties to be dumped for IR instructions and blocks when using  the PrintIR module. Libraries that compute additional facts about IR elements can extend the  single instance of this class to specify the additional properties computed by the library.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRVariable.qll/type.IRVariable$IRReturnVariable.html" class="ref-link ref-type" title="Class IRReturnVariable">IRReturnVariable</a></td><td><span class="qldoc-summary"><p>A temporary variable generated to hold the return value of a function.</p>
</span></td></tr><tr><td><a href="../implementation/IRType.qll/type.IRType$IRSignedIntegerType.html" class="ref-link ref-type" title="Class IRSignedIntegerType">IRSignedIntegerType</a></td><td><span class="qldoc-summary"><p>A signed two&rsquo;s-complement integer. Also used to represent enums whose underlying type is a signed  integer, as well as character types whose representation is signed.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRVariable.qll/type.IRVariable$IRStaticUserVariable.html" class="ref-link ref-type" title="Class IRStaticUserVariable">IRStaticUserVariable</a></td><td><span class="qldoc-summary"><p>A user-declared variable that is not allocated on the stack. This includes all global variables,  namespace-scope variables, static fields, and static local variables.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRVariable.qll/type.IRVariable$IRStringLiteral.html" class="ref-link ref-type" title="Class IRStringLiteral">IRStringLiteral</a></td><td><span class="qldoc-summary"><p>A variable generated to represent the contents of a string literal. This variable acts much like  a read-only global variable.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRVariable.qll/type.IRVariable$IRTempVariable.html" class="ref-link ref-type" title="Class IRTempVariable">IRTempVariable</a></td><td><span class="qldoc-summary"><p>A temporary variable introduced by IR construction. The most common examples are the variable  generated to hold the return value of a function, or the variable generated to hold the result of  a condition operator (<code>a ? b : c</code>).</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRVariable.qll/type.IRVariable$IRThisVariable.html" class="ref-link ref-type" title="Class IRThisVariable">IRThisVariable</a></td><td><span class="qldoc-summary"><p>A temporary variable generated to hold the <code>this</code> pointer.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRVariable.qll/type.IRVariable$IRThrowVariable.html" class="ref-link ref-type" title="Class IRThrowVariable">IRThrowVariable</a></td><td><span class="qldoc-summary"><p>A temporary variable generated to hold the exception thrown by a <code>ThrowValue</code> instruction.</p>
</span></td></tr><tr><td><a href="../implementation/IRType.qll/type.IRType$IRType.html" class="ref-link ref-type" title="Class IRType">IRType</a></td><td><span class="qldoc-summary"><p>The language-neutral type of an IR <code>Instruction</code>, <code>Operand</code>, or <code>IRVariable</code>.  The interface to <code>IRType</code> and its subclasses is the same across all languages for which the IR  is supported, so analyses that expect to be used for multiple languages should generally use  <code>IRType</code> rather than a language-specific type.</p>
</span></td></tr><tr><td><a href="../implementation/IRType.qll/type.IRType$IRUnknownType.html" class="ref-link ref-type" title="Class IRUnknownType">IRUnknownType</a></td><td><span class="qldoc-summary"><p>An unknown type. Generally used to represent results and operands that access an unknown set of  memory locations, such as the side effects of a function call.</p>
</span></td></tr><tr><td><a href="../implementation/IRType.qll/type.IRType$IRUnsignedIntegerType.html" class="ref-link ref-type" title="Class IRUnsignedIntegerType">IRUnsignedIntegerType</a></td><td><span class="qldoc-summary"><p>An unsigned two&rsquo;s-complement integer. Also used to represent enums whose underlying type is an  unsigned integer, as well as character types whose representation is unsigned.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRVariable.qll/type.IRVariable$IRUserVariable.html" class="ref-link ref-type" title="Class IRUserVariable">IRUserVariable</a></td><td><span class="qldoc-summary"><p>A user-declared variable referenced by the IR for a function.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/IRVariable.qll/type.IRVariable$IRVariable.html" class="ref-link ref-type" title="Class IRVariable">IRVariable</a></td><td><span class="qldoc-summary"><p>A variable referenced by the IR for a function.</p>
</span></td></tr><tr><td><a href="../implementation/IRType.qll/type.IRType$IRVoidType.html" class="ref-link ref-type" title="Class IRVoidType">IRVoidType</a></td><td><span class="qldoc-summary"><p>A void type, which has no values. Used to represent the result type of an instruction that does  not produce a result.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$IndexedInstruction.html" class="ref-link ref-type" title="Class IndexedInstruction">IndexedInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that refers to an argument of a <code>Call</code> instruction.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$IndirectMayWriteSideEffectInstruction.html" class="ref-link ref-type" title="Class IndirectMayWriteSideEffectInstruction">IndirectMayWriteSideEffectInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing the potential write of an indirect parameter within a function call.</p>
</span></td></tr><tr><td><a href="../implementation/MemoryAccessKind.qll/type.MemoryAccessKind$IndirectMemoryAccess.html" class="ref-link ref-type" title="Class IndirectMemoryAccess">IndirectMemoryAccess</a></td><td><span class="qldoc-summary"><p>The operand or result accesses memory at the address specified by the <code>AddressOperand</code> on the  same instruction.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$IndirectMemoryAccessOpcode.html" class="ref-link ref-type" title="Class IndirectMemoryAccessOpcode">IndirectMemoryAccessOpcode</a></td><td><span class="qldoc-summary"><p>An opcode that accesses a single memory location via an <code>AddressOperand</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$IndirectMustWriteSideEffectInstruction.html" class="ref-link ref-type" title="Class IndirectMustWriteSideEffectInstruction">IndirectMustWriteSideEffectInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing the write of an indirect parameter within a function call.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$IndirectReadOpcode.html" class="ref-link ref-type" title="Class IndirectReadOpcode">IndirectReadOpcode</a></td><td><span class="qldoc-summary"><p>An opcode that reads from a single memory location via an <code>AddressOperand</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$IndirectReadSideEffectInstruction.html" class="ref-link ref-type" title="Class IndirectReadSideEffectInstruction">IndirectReadSideEffectInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing the read of an indirect parameter within a function call.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$IndirectWriteOpcode.html" class="ref-link ref-type" title="Class IndirectWriteOpcode">IndirectWriteOpcode</a></td><td><span class="qldoc-summary"><p>An opcode that writes to a single memory location via an <code>AddressOperand</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$InheritanceConversionInstruction.html" class="ref-link ref-type" title="Class InheritanceConversionInstruction">InheritanceConversionInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that converts the address of an object to the address of a different subobject of  the same object, without any type checking at runtime.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$InitializeDynamicAllocationInstruction.html" class="ref-link ref-type" title="Class InitializeDynamicAllocationInstruction">InitializeDynamicAllocationInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing the initial value of newly allocated memory, such as the result of a  call to <code>malloc</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$InitializeIndirectionInstruction.html" class="ref-link ref-type" title="Class InitializeIndirectionInstruction">InitializeIndirectionInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that initializes the memory pointed to by a parameter of the enclosing function  with the value of that memory on entry to the function.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$InitializeNonLocalInstruction.html" class="ref-link ref-type" title="Class InitializeNonLocalInstruction">InitializeNonLocalInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that initializes all memory that existed before this function was called.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$InitializeParameterInstruction.html" class="ref-link ref-type" title="Class InitializeParameterInstruction">InitializeParameterInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that initializes a parameter of the enclosing function with the value of the  corresponding argument passed by the caller.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$InitializeThisInstruction.html" class="ref-link ref-type" title="Class InitializeThisInstruction">InitializeThisInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that initializes the <code>this</code> pointer parameter of the enclosing function.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$InlineAsmInstruction.html" class="ref-link ref-type" title="Class InlineAsmInstruction">InlineAsmInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing a GNU or MSVC inline assembly statement.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$Instruction.html" class="ref-link ref-type" title="Class Instruction">Instruction</a></td><td><span class="qldoc-summary"><p>A single instruction in the IR.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$IntegerConstantInstruction.html" class="ref-link ref-type" title="Class IntegerConstantInstruction">IntegerConstantInstruction</a></td><td><span class="qldoc-summary"><p>An instruction whose result is a constant value of integer or Boolean type.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$LeftOperand.html" class="ref-link ref-type" title="Class LeftOperand">LeftOperand</a></td><td><span class="qldoc-summary"><p>The left operand of a binary instruction (e.g. <code>Add</code>, <code>CompareEQ</code>).</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$LoadInstruction.html" class="ref-link ref-type" title="Class LoadInstruction">LoadInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns a register result containing a copy of its memory operand.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$LoadOperand.html" class="ref-link ref-type" title="Class LoadOperand">LoadOperand</a></td><td><span class="qldoc-summary"><p>The source value operand of an instruction that loads a value from memory (e.g. <code>Load</code>,  <code>ReturnValue</code>, <code>ThrowValue</code>).</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$LogicalNotInstruction.html" class="ref-link ref-type" title="Class LogicalNotInstruction">LogicalNotInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that computes the logical complement of its operand.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$MayReadOpcode.html" class="ref-link ref-type" title="Class MayReadOpcode">MayReadOpcode</a></td><td><span class="qldoc-summary"><p>An opcode whose read memory access is a <code>may</code> read, as opposed to a <code>must</code> read.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$MayWriteOpcode.html" class="ref-link ref-type" title="Class MayWriteOpcode">MayWriteOpcode</a></td><td><span class="qldoc-summary"><p>An opcode whose write memory access is a <code>may</code> write, as opposed to a <code>must</code> write.</p>
</span></td></tr><tr><td><a href="../implementation/MemoryAccessKind.qll/type.MemoryAccessKind$MemoryAccessKind.html" class="ref-link ref-type" title="Class MemoryAccessKind">MemoryAccessKind</a></td><td><span class="qldoc-summary"><p>Describes the set of memory locations memory accessed by a memory operand or  memory result.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$MemoryOperand.html" class="ref-link ref-type" title="Class MemoryOperand">MemoryOperand</a></td><td><span class="qldoc-summary"><p>An operand that consumes a memory result (e.g. the <code>LoadOperand</code> on a <code>Load</code> instruction).</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$MulInstruction.html" class="ref-link ref-type" title="Class MulInstruction">MulInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that computes the product of two numeric operands.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$NegateInstruction.html" class="ref-link ref-type" title="Class NegateInstruction">NegateInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that negates a single numeric operand.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$NewObjInstruction.html" class="ref-link ref-type" title="Class NewObjInstruction">NewObjInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that allocates a new object on the managed heap.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$NextVarArgInstruction.html" class="ref-link ref-type" title="Class NextVarArgInstruction">NextVarArgInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that modifies a <code>va_list</code> to point to the next argument that was passed to the  <code>...</code> parameter.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$NoOpInstruction.html" class="ref-link ref-type" title="Class NoOpInstruction">NoOpInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that has no effect.</p>
</span></td></tr><tr><td><a href="../implementation/MemoryAccessKind.qll/type.MemoryAccessKind$NonLocalMemoryAccess.html" class="ref-link ref-type" title="Class NonLocalMemoryAccess">NonLocalMemoryAccess</a></td><td><span class="qldoc-summary"><p>The operand or result access all memory whose address has escaped, other than data on the stack  frame of the current function.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$NonPhiMemoryOperand.html" class="ref-link ref-type" title="Class NonPhiMemoryOperand">NonPhiMemoryOperand</a></td><td><span class="qldoc-summary"><p>A memory operand other than the operand of a <code>Phi</code> instruction.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$NonPhiOperand.html" class="ref-link ref-type" title="Class NonPhiOperand">NonPhiOperand</a></td><td><span class="qldoc-summary"><p>An operand that is not an operand of a <code>PhiInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$Opcode.html" class="ref-link ref-type" title="Class Opcode">Opcode</a></td><td><span class="qldoc-summary"><p>An opcode that specifies the operation performed by an <code>Instruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$OpcodeWithLoad.html" class="ref-link ref-type" title="Class OpcodeWithLoad">OpcodeWithLoad</a></td><td><span class="qldoc-summary"><p>An opcode that reads a value from memory.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$Operand.html" class="ref-link ref-type" title="Class Operand">Operand</a></td><td><span class="qldoc-summary"><p>An operand of an <code>Instruction</code>. The operand represents a use of the result of one instruction  (the defining instruction) in another instruction (the use instruction)</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$PhiInputOperand.html" class="ref-link ref-type" title="Class PhiInputOperand">PhiInputOperand</a></td><td><span class="qldoc-summary"><p>An operand of a <code>PhiInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$PhiInstruction.html" class="ref-link ref-type" title="Class PhiInstruction">PhiInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing the choice of one of multiple input values based on control flow.</p>
</span></td></tr><tr><td><a href="../implementation/MemoryAccessKind.qll/type.MemoryAccessKind$PhiMemoryAccess.html" class="ref-link ref-type" title="Class PhiMemoryAccess">PhiMemoryAccess</a></td><td><span class="qldoc-summary"><p>The operand is a Phi operand, which accesses the same memory as its  definition.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$PointerAddInstruction.html" class="ref-link ref-type" title="Class PointerAddInstruction">PointerAddInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that adds an integer offset to a pointer.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$PointerArithmeticInstruction.html" class="ref-link ref-type" title="Class PointerArithmeticInstruction">PointerArithmeticInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that performs a binary arithmetic operation involving at least one pointer  operand.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$PointerArithmeticOpcode.html" class="ref-link ref-type" title="Class PointerArithmeticOpcode">PointerArithmeticOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>PointerArithmeticInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$PointerDiffInstruction.html" class="ref-link ref-type" title="Class PointerDiffInstruction">PointerDiffInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that computes the difference between two pointers.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$PointerOffsetInstruction.html" class="ref-link ref-type" title="Class PointerOffsetInstruction">PointerOffsetInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that adds or subtracts an integer offset from a pointer.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$PointerOffsetOpcode.html" class="ref-link ref-type" title="Class PointerOffsetOpcode">PointerOffsetOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>PointerOffsetInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$PointerSubInstruction.html" class="ref-link ref-type" title="Class PointerSubInstruction">PointerSubInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that subtracts an integer offset from a pointer.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$PositionalArgumentOperand.html" class="ref-link ref-type" title="Class PositionalArgumentOperand">PositionalArgumentOperand</a></td><td><span class="qldoc-summary"><p>An operand representing an argument to a function call.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ReThrowInstruction.html" class="ref-link ref-type" title="Class ReThrowInstruction">ReThrowInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that re-throws the current exception.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ReadSideEffectInstruction.html" class="ref-link ref-type" title="Class ReadSideEffectInstruction">ReadSideEffectInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing a read side effect of a function call on a  specific parameter.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$ReadSideEffectOpcode.html" class="ref-link ref-type" title="Class ReadSideEffectOpcode">ReadSideEffectOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>ReadSideEffectInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$RegisterOperand.html" class="ref-link ref-type" title="Class RegisterOperand">RegisterOperand</a></td><td><span class="qldoc-summary"><p>An operand that consumes a register (non-memory) result.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$RelationalInstruction.html" class="ref-link ref-type" title="Class RelationalInstruction">RelationalInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that does a relative comparison of two values, such as <code>&lt;</code> or <code>&gt;=</code>.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$RelationalOpcode.html" class="ref-link ref-type" title="Class RelationalOpcode">RelationalOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>RelationalInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$RemInstruction.html" class="ref-link ref-type" title="Class RemInstruction">RemInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that computes the remainder of two integer operands.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ReturnIndirectionInstruction.html" class="ref-link ref-type" title="Class ReturnIndirectionInstruction">ReturnIndirectionInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that represents the use of the value pointed to by a parameter of the function  after the function returns control to its caller.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ReturnInstruction.html" class="ref-link ref-type" title="Class ReturnInstruction">ReturnInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns control to the caller of the function.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$ReturnOpcode.html" class="ref-link ref-type" title="Class ReturnOpcode">ReturnOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>ReturnInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ReturnValueInstruction.html" class="ref-link ref-type" title="Class ReturnValueInstruction">ReturnValueInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns control to the caller of the function, including a return value.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ReturnVoidInstruction.html" class="ref-link ref-type" title="Class ReturnVoidInstruction">ReturnVoidInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns control to the caller of the function, without returning a value.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$RightOperand.html" class="ref-link ref-type" title="Class RightOperand">RightOperand</a></td><td><span class="qldoc-summary"><p>The right operand of a binary instruction (e.g. <code>Add</code>, <code>CompareEQ</code>).</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ShiftLeftInstruction.html" class="ref-link ref-type" title="Class ShiftLeftInstruction">ShiftLeftInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that shifts its left operand to the left by the number of bits specified by its  right operand.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ShiftRightInstruction.html" class="ref-link ref-type" title="Class ShiftRightInstruction">ShiftRightInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that shifts its left operand to the right by the number of bits specified by its  right operand.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$SideEffectInstruction.html" class="ref-link ref-type" title="Class SideEffectInstruction">SideEffectInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing a side effect of a function call.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$SideEffectOpcode.html" class="ref-link ref-type" title="Class SideEffectOpcode">SideEffectOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>SideEffectInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$SideEffectOperand.html" class="ref-link ref-type" title="Class SideEffectOperand">SideEffectOperand</a></td><td><span class="qldoc-summary"><p>An operand representing memory read as a side effect of evaluating another instruction.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$SizedBufferAccessOpcode.html" class="ref-link ref-type" title="Class SizedBufferAccessOpcode">SizedBufferAccessOpcode</a></td><td><span class="qldoc-summary"><p>An opcode that accesses a memory buffer whose size is determined by a <code>BufferSizeOperand</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$SizedBufferMayWriteSideEffectInstruction.html" class="ref-link ref-type" title="Class SizedBufferMayWriteSideEffectInstruction">SizedBufferMayWriteSideEffectInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing the write of an indirect buffer parameter within a function call.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$SizedBufferMustWriteSideEffectInstruction.html" class="ref-link ref-type" title="Class SizedBufferMustWriteSideEffectInstruction">SizedBufferMustWriteSideEffectInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing the write of an indirect buffer parameter within a function call. The  entire buffer is overwritten.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$SizedBufferReadOpcode.html" class="ref-link ref-type" title="Class SizedBufferReadOpcode">SizedBufferReadOpcode</a></td><td><span class="qldoc-summary"><p>An opcode that reads from a memory buffer whose size is determined by a <code>BufferSizeOperand</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$SizedBufferReadSideEffectInstruction.html" class="ref-link ref-type" title="Class SizedBufferReadSideEffectInstruction">SizedBufferReadSideEffectInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing the read of an indirect buffer parameter within a function call.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$SizedBufferWriteOpcode.html" class="ref-link ref-type" title="Class SizedBufferWriteOpcode">SizedBufferWriteOpcode</a></td><td><span class="qldoc-summary"><p>An opcode that writes to a memory buffer whose size is determined by a <code>BufferSizeOperand</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$StoreInstruction.html" class="ref-link ref-type" title="Class StoreInstruction">StoreInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns a memory result containing a copy of its register operand.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$StoreValueOperand.html" class="ref-link ref-type" title="Class StoreValueOperand">StoreValueOperand</a></td><td><span class="qldoc-summary"><p>The source value operand of a <code>Store</code> instruction.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$StringConstantInstruction.html" class="ref-link ref-type" title="Class StringConstantInstruction">StringConstantInstruction</a></td><td><span class="qldoc-summary"><p>An instruction whose result is the address of a string literal.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$SubInstruction.html" class="ref-link ref-type" title="Class SubInstruction">SubInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that computes the difference of two numeric operands.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$SwitchInstruction.html" class="ref-link ref-type" title="Class SwitchInstruction">SwitchInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that branches to one of multiple successor instructions based on the value of an  integer operand.</p>
</span></td></tr><tr><td><a href="../implementation/TempVariableTag.qll/type.TempVariableTag$TempVariableTag.html" class="ref-link ref-type" title="Class TempVariableTag">TempVariableTag</a></td><td><span class="qldoc-summary"><p>A reason that a particular IR temporary variable was generated. For example, it could be  generated to hold the return value of a function, or to hold the result of a <code>?:</code> operator  computed on each branch. The set of possible <code>TempVariableTag</code>s is language-dependent.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$ThisArgumentOperand.html" class="ref-link ref-type" title="Class ThisArgumentOperand">ThisArgumentOperand</a></td><td><span class="qldoc-summary"><p>An operand representing the implicit &lsquo;this&rsquo; argument to a member function  call.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ThrowInstruction.html" class="ref-link ref-type" title="Class ThrowInstruction">ThrowInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that throws an exception.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$ThrowOpcode.html" class="ref-link ref-type" title="Class ThrowOpcode">ThrowOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>ThrowInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$ThrowValueInstruction.html" class="ref-link ref-type" title="Class ThrowValueInstruction">ThrowValueInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that throws a new exception.</p>
</span></td></tr><tr><td><a href="../implementation/EdgeKind.qll/type.EdgeKind$TrueEdge.html" class="ref-link ref-type" title="Class TrueEdge">TrueEdge</a></td><td><span class="qldoc-summary"><p>A &ldquo;true&rdquo; edge, representing the successor of a conditional branch when the  condition is non-zero.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$TypedOperand.html" class="ref-link ref-type" title="Class TypedOperand">TypedOperand</a></td><td><span class="qldoc-summary"><p>A memory operand whose type may be different from the type of the result of its definition.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$UnaryArithmeticInstruction.html" class="ref-link ref-type" title="Class UnaryArithmeticInstruction">UnaryArithmeticInstruction</a></td><td><span class="qldoc-summary"><p>An instruction whose result is computed by performing an arithmetic operation on a single  numeric operand.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$UnaryArithmeticOpcode.html" class="ref-link ref-type" title="Class UnaryArithmeticOpcode">UnaryArithmeticOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>UnaryArithmeticInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$UnaryBitwiseInstruction.html" class="ref-link ref-type" title="Class UnaryBitwiseInstruction">UnaryBitwiseInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that performs a bitwise operation on a single integer operand.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$UnaryBitwiseOpcode.html" class="ref-link ref-type" title="Class UnaryBitwiseOpcode">UnaryBitwiseOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>UnaryBitwiseInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$UnaryInstruction.html" class="ref-link ref-type" title="Class UnaryInstruction">UnaryInstruction</a></td><td><span class="qldoc-summary"><p>An instruction whose result is computed from a single operand.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$UnaryOpcode.html" class="ref-link ref-type" title="Class UnaryOpcode">UnaryOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>UnaryInstruction</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Operand.qll/type.Operand$UnaryOperand.html" class="ref-link ref-type" title="Class UnaryOperand">UnaryOperand</a></td><td><span class="qldoc-summary"><p>The sole operand of a unary instruction (e.g. <code>Convert</code>, <code>Negate</code>, <code>Copy</code>).</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$UninitializedInstruction.html" class="ref-link ref-type" title="Class UninitializedInstruction">UninitializedInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns an uninitialized value.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$UnreachedInstruction.html" class="ref-link ref-type" title="Class UnreachedInstruction">UnreachedInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing unreachable code.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$UnsizedBufferAccessOpcode.html" class="ref-link ref-type" title="Class UnsizedBufferAccessOpcode">UnsizedBufferAccessOpcode</a></td><td><span class="qldoc-summary"><p>An opcode that accesses a memory buffer of unknown size.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$UnsizedBufferReadOpcode.html" class="ref-link ref-type" title="Class UnsizedBufferReadOpcode">UnsizedBufferReadOpcode</a></td><td><span class="qldoc-summary"><p>An opcode that reads from a memory buffer of unknown size.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$UnsizedBufferWriteOpcode.html" class="ref-link ref-type" title="Class UnsizedBufferWriteOpcode">UnsizedBufferWriteOpcode</a></td><td><span class="qldoc-summary"><p>An opcode that writes to a memory buffer of unknown size.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$UnwindInstruction.html" class="ref-link ref-type" title="Class UnwindInstruction">UnwindInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that exits the current function by propagating an exception.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$VarArgInstruction.html" class="ref-link ref-type" title="Class VarArgInstruction">VarArgInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns the address of the argument currently pointed to by a <code>va_list</code>.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$VarArgsEndInstruction.html" class="ref-link ref-type" title="Class VarArgsEndInstruction">VarArgsEndInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that cleans up a <code>va_list</code> after it is no longer in use.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$VarArgsStartInstruction.html" class="ref-link ref-type" title="Class VarArgsStartInstruction">VarArgsStartInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns a <code>va_list</code> to access the arguments passed to the <code>...</code> parameter.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$VariableAddressInstruction.html" class="ref-link ref-type" title="Class VariableAddressInstruction">VariableAddressInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that returns the address of a variable.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$VariableInstruction.html" class="ref-link ref-type" title="Class VariableInstruction">VariableInstruction</a></td><td><span class="qldoc-summary"><p>An instruction that refers to a variable.</p>
</span></td></tr><tr><td><a href="../implementation/aliased_ssa/Instruction.qll/type.Instruction$WriteSideEffectInstruction.html" class="ref-link ref-type" title="Class WriteSideEffectInstruction">WriteSideEffectInstruction</a></td><td><span class="qldoc-summary"><p>An instruction representing a write side effect of a function call on a  specific parameter.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/type.Opcode$WriteSideEffectOpcode.html" class="ref-link ref-type" title="Class WriteSideEffectOpcode">WriteSideEffectOpcode</a></td><td><span class="qldoc-summary"><p>The <code>Opcode</code> for a <code>WriteSideEffectInstruction</code>.</p>
</span></td></tr></tbody></table></div></div><div><h2 class="subsection-heading" id="Modules">Modules</h2><div class="doc-block"><table><tbody><tr><td><a href="../implementation/EdgeKind.qll/module.EdgeKind$EdgeKind.html" class="ref-link ref-module" title="Module EdgeKind">EdgeKind</a></td><td><span class="qldoc-summary"><p>Predicates to access the single instance of each <code>EdgeKind</code> class.</p>
</span></td></tr><tr><td><a href="../implementation/IRType.qll/module.IRType$IRTypeConsistency.html" class="ref-link ref-module" title="Module IRTypeConsistency">IRTypeConsistency</a></td><td><span class="qldoc-summary"><p>INTERNAL: Do not use.  Query predicates used to check invariants that should hold for all <code>IRType</code> objects. To run all  consistency queries for the IR, including the ones below, run  &ldquo;semmle/code/cpp/IR/IRConsistency.ql&rdquo;.</p>
</span></td></tr><tr><td><a href="../implementation/Opcode.qll/module.Opcode$Opcode.html" class="ref-link ref-module" title="Module Opcode">Opcode</a></td><td><span class="qldoc-summary"><p>Provides <code>Opcode</code>s that specify the operation performed by an <code>Instruction</code>.</p>
</span></td></tr></tbody></table></div></div></div></div></div><footer id="content-footer">Copyright 2020 GitHub Software UK Ltd.<a title="Privacy statement and tracking preferences" target="_blank" href="https://docs.github.com/github/site-policy/github-privacy-statement">Privacy Statement</a></footer></body></html>