<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="qldoc"><meta name="description" content="API documentation for CodeQL"><meta name="keywords" content="CodeQL,QL,LocalTypedefType"><meta name="addsearch-category" content="C/C++ CodeQL library"><title>LocalTypedefType</title><link rel="stylesheet" type="text/css" href="https://unpkg.com/@primer/css/dist/primer.css"><link rel="stylesheet" type="text/css" href="../../../../qldoc.css"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-5Q9DBRM');</script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5Q9DBRM" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="Header text-white"><div class="Header-item"><svg class="octicon octicon-mark-github mr-2" height="32" viewbox="0 0 16 16" width="32"><path fill-rule="even-odd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg></div><div class="Header-item--full f2 text-bold">CodeQL library for C/C++</div><div class="Header-item"><span>Version 1.26.0</span></div><div class="Header-item .text-gray-light"><div class="nav-section"><a href="../../../../index.html">Index</a></div></div><div class="Header-item"><a title="Search the CodeQL libraries" target="_blank" href="https://help.semmle.com/home/help/search-results-qldoc.html"><span class=".text-gray-light">Search</span></a></div></div><div id="main"><nav id="sidebar"><div id="sidebar-content" class="pt-2"><div class="nav-section"><p>For other CodeQL resources, including tutorials and examples, see <a href="https://help.semmle.com/QL/learn-ql/" class="learn-ql-link" target="_blank">Learning CodeQL</a><p>.</p></p><h2 class="section-heading"><a href="type.TypedefType$LocalTypedefType.html" class="ref-link ref-type">LocalTypedefType</a></h2><div class="doc-block"><ol class="section-links"><li></li><li></li><li><a href="type.TypedefType$LocalTypedefType.html#Import%20path">Import path</a></li><li><a href="type.TypedefType$LocalTypedefType.html#Direct%20supertypes">Direct supertypes</a></li><li><a href="type.TypedefType$LocalTypedefType.html#Indirect%20supertypes">Indirect supertypes</a></li><li><a href="type.TypedefType$LocalTypedefType.html#Predicates">Predicates</a></li><li><a href="type.TypedefType$LocalTypedefType.html#Inherited%20predicates">Inherited predicates</a></li><li><a href="type.TypedefType$LocalTypedefType.html#Charpred">Charpred</a></li></ol></div></div><div class="nav-section"><div><div><h2 class="section-heading"><span>Module <a href="module.TypedefType.html" class="ref-link ref-module" title="Module TypedefType">TypedefType</a></span></h2></div><div><h3 class="subsection-heading">Imports</h3><div class="doc-block"><table><tbody><tr><td><a href="../Type.qll/module.Type.html" class="ref-link ref-module" title="Module Type">Type</a></td></tr></tbody></table></div></div><div><h3 class="subsection-heading">Classes</h3><div class="doc-block"><table><tbody><tr><td><a href="type.TypedefType$CTypedefType.html" class="ref-link ref-type" title="Class CTypedefType">CTypedefType</a></td></tr><tr><td><a href="type.TypedefType$LocalTypedefType.html" class="ref-link ref-type" title="Class LocalTypedefType">LocalTypedefType</a></td></tr><tr><td><a href="type.TypedefType$NestedTypedefType.html" class="ref-link ref-type" title="Class NestedTypedefType">NestedTypedefType</a></td></tr><tr><td><a href="type.TypedefType$TypedefType.html" class="ref-link ref-type" title="Class TypedefType">TypedefType</a></td></tr><tr><td><a href="type.TypedefType$UsingAliasTypedefType.html" class="ref-link ref-type" title="Class UsingAliasTypedefType">UsingAliasTypedefType</a></td></tr></tbody></table></div></div></div></div></div></nav><div class="overflow-y-auto width-full pt-2"><div id="content"><div><h1 class="section-heading" id="TypedefType::LocalTypedefType"><span><span>Class <span><a href="type.TypedefType$LocalTypedefType.html" class="ref-link ref-type" title="Class LocalTypedefType">LocalTypedefType</a></span></span></span></h1></div><div><div class="doc-block"><div class="qldoc"><p>A C++ <code>typedef</code> type that is directly enclosed by a function.  For example the type declared inside the function <code>foo</code> in
the following code:</p>
<pre><code class="numbered-code"><span class="numbered-code-line">int foo(void) { typedef int local; }
</span></code></pre>
</div></div></div><div><h2 class="subsection-heading" id="Import path">Import path</h2><div class="doc-block"><code>import cpp</code></div></div><div><h2 class="subsection-heading" id="Direct supertypes">Direct supertypes</h2><div><div class="doc-block"><ul class="inline-list comma-list"><li><a href="type.TypedefType$TypedefType.html" class="ref-link ref-type" title="Class TypedefType">TypedefType</a></li></ul></div></div></div><div><h2 class="subsection-heading" id="Indirect supertypes">Indirect supertypes</h2><div><div class="doc-block"><ul class="inline-list comma-list"><li><a href="../../../../type.@declaration.html" class="ref-link ref-type" title="Union type @declaration">@declaration</a></li><li><a href="../../../../type.@declaredtype.html" class="ref-link ref-type" title="Union type @declaredtype">@declaredtype</a></li><li><a href="../../../../type.@element.html" class="ref-link ref-type" title="Union type @element">@element</a></li><li><a href="../../../../type.@enclosingfunction_child.html" class="ref-link ref-type" title="Union type @enclosingfunction_child">@enclosingfunction_child</a></li><li><a href="../../../../type.@exprparent.html" class="ref-link ref-type" title="Union type @exprparent">@exprparent</a></li><li><a href="../../../../type.@locatable.html" class="ref-link ref-type" title="Union type @locatable">@locatable</a></li><li><a href="../../../../type.@member.html" class="ref-link ref-type" title="Union type @member">@member</a></li><li><a href="../../../../type.@namedscope.html" class="ref-link ref-type" title="Union type @namedscope">@namedscope</a></li><li><a href="../../../../type.@namequalifyingelement.html" class="ref-link ref-type" title="Union type @namequalifyingelement">@namequalifyingelement</a></li><li><a href="../../../../type.@namespacembr.html" class="ref-link ref-type" title="Union type @namespacembr">@namespacembr</a></li><li><a href="../../../../type.@type.html" class="ref-link ref-type" title="Union type @type">@type</a></li><li><a href="../../../../type.@usertype.html" class="ref-link ref-type" title="Type @usertype">@usertype</a></li><li><a href="../Declaration.qll/type.Declaration$AccessHolder.html" class="ref-link ref-type" title="Class AccessHolder">AccessHolder</a></li><li><a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></li><li><a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></li><li><a href="../Element.qll/type.Element$ElementBase.html" class="ref-link ref-type" title="Class ElementBase">ElementBase</a></li><li><a href="../Location.qll/type.Location$Locatable.html" class="ref-link ref-type" title="Class Locatable">Locatable</a></li><li><a href="../NameQualifiers.qll/type.NameQualifiers$NameQualifyingElement.html" class="ref-link ref-type" title="Class NameQualifyingElement">NameQualifyingElement</a></li><li><a href="../Declaration.qll/type.Declaration$TAccessHolder.html" class="ref-link ref-type" title="Type TAccessHolder">TAccessHolder</a></li><li><a href="../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></li><li><a href="../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></li></ul></div></div></div><div><h2 class="subsection-heading" id="Predicates">Predicates</h2><div class="doc-block"><table><tbody><tr><td><a href="predicate.TypedefType$LocalTypedefType$getAPrimaryQlClass.0.html" class="ref-link ref-predicate" title="Member predicate LocalTypedefType::getAPrimaryQlClass">getAPrimaryQlClass</a></td><td><span class="qldoc-summary"><p>Gets the name of a primary CodeQL class to which this element belongs.</p>
</span></td></tr></tbody></table></div></div><div><h2 class="subsection-heading" id="Inherited predicates">Inherited predicates</h2><div class="doc-block"><table><tbody><tr><td><a href="../Declaration.qll/predicate.Declaration$AccessHolder$canAccessClass.2.html" class="ref-link ref-predicate" title="Member predicate AccessHolder::canAccessClass">canAccessClass</a></td><td><span class="qldoc-summary"><p>Holds if a base class <code>base</code> of <code>derived</code> <em>is accessible at</em> <code>this</code> (N4140  11.2/4). When this holds, and <code>derived</code> has only one base subobject of  type <code>base</code>, code in <code>this</code> can implicitly convert a pointer to <code>derived</code>  into a pointer to <code>base</code>. Conversely, if such a conversion is possible  then this predicate holds.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$AccessHolder.html" class="ref-link ref-type" title="Class AccessHolder">AccessHolder</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$AccessHolder$canAccessMember.2.html" class="ref-link ref-predicate" title="Member predicate AccessHolder::canAccessMember">canAccessMember</a></td><td><span class="qldoc-summary"><p>Holds if a non-static member <code>member</code> <em>is accessible at</em> <code>this</code> when named  in a class <code>derived</code> that is derived from or equal to the declaring class  of <code>member</code> (N4140 11.2/5 and 11.4).</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$AccessHolder.html" class="ref-link ref-type" title="Class AccessHolder">AccessHolder</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$AccessHolder$couldAccessMember.3.html" class="ref-link ref-predicate" title="Member predicate AccessHolder::couldAccessMember">couldAccessMember</a></td><td><span class="qldoc-summary"><p>Holds if a hypothetical non-static member of <code>memberClass</code> with access  specifier <code>memberAccess</code> <em>is accessible at</em> <code>this</code> when named in a class  <code>derived</code> that is derived from or equal to <code>memberClass</code> (N4140 11.2/5 and  11.4).</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$AccessHolder.html" class="ref-link ref-type" title="Class AccessHolder">AccessHolder</a></span></td></tr><tr><td><a href="../UserType.qll/predicate.UserType$UserType$explain.0.html" class="ref-link ref-predicate" title="Member predicate UserType::explain">explain</a></td><td><span class="qldoc-summary"><p>Gets a detailed string representation explaining the AST of this type  (with all specifiers and nested constructs such as pointers). This is  intended to help debug queries and is a very expensive operation; not  to be used in production queries.</p>
</span></td><td><span>from <a href="../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$findRootCause.0.html" class="ref-link ref-predicate" title="Member predicate Element::findRootCause">findRootCause</a></td><td><span class="qldoc-summary"><p>Gets the source of this element: either itself or a macro that expanded  to this element.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><span class="deprecated"><a href="../Element.qll/predicate.Element$Element$fromLibrary.0.html" class="ref-link ref-predicate" title="Member predicate Element::fromLibrary">fromLibrary</a></span></td><td><span class="qldoc-summary"><p>Holds if this element may be from a library.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$fromSource.0.html" class="ref-link ref-predicate" title="Member predicate Element::fromSource">fromSource</a></td><td><span class="qldoc-summary"><p>Holds if this element may be from source.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../UserType.qll/predicate.UserType$UserType$getADeclaration.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getADeclaration">getADeclaration</a></td><td><span class="qldoc-summary"><p>Gets a child declaration within this user-defined type.</p>
</span></td><td><span>from <a href="../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../UserType.qll/predicate.UserType$UserType$getADeclarationEntry.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getADeclarationEntry">getADeclarationEntry</a></td><td><span class="qldoc-summary"><p>Gets a declaration entry corresponding to this declaration. See the  comment above this class for an explanation of the relationship  between <code>Declaration</code> and <code>DeclarationEntry</code>.</p>
</span></td><td><span>from <a href="../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../UserType.qll/predicate.UserType$UserType$getADeclarationLocation.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getADeclarationLocation">getADeclarationLocation</a></td><td><span class="qldoc-summary"><p>Gets the location of a declaration entry corresponding to this  declaration.</p>
</span></td><td><span>from <a href="../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$getAFile.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::getAFile">getAFile</a></td><td><span class="qldoc-summary"><p>Gets a file where this element occurs.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../NameQualifiers.qll/predicate.NameQualifiers$NameQualifyingElement$getANameQualifier.0.html" class="ref-link ref-predicate" title="Member predicate NameQualifyingElement::getANameQualifier">getANameQualifier</a></td><td><span class="qldoc-summary"><p>Gets a name qualifier for which this is the qualifying namespace or  user-defined type. For example: class <code>X</code> is the  <code>NameQualifyingElement</code> and <code>X::</code> is the <code>NameQualifier</code>.</p>
</span></td><td><span>from <a href="../NameQualifiers.qll/type.NameQualifiers$NameQualifyingElement.html" class="ref-link ref-type" title="Class NameQualifyingElement">NameQualifyingElement</a></span></td></tr><tr><td><a href="../UserType.qll/predicate.UserType$UserType$getASpecifier.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getASpecifier">getASpecifier</a></td><td></td><td><span>from <a href="../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$getATemplateArgument.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::getATemplateArgument">getATemplateArgument</a></td><td><span class="qldoc-summary"><p>Gets a template argument used to instantiate this declaration from a template.  When called on a template, this will return a template parameter type for  both typed and non-typed parameters.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$getATemplateArgumentKind.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::getATemplateArgumentKind">getATemplateArgumentKind</a></td><td><span class="qldoc-summary"><p>Gets a template argument used to instantiate this declaration from a template.  When called on a template, this will return a non-typed template  parameter value.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../Type.qll/predicate.Type$Type$getATypeNameUse.0.html" class="ref-link ref-predicate" title="Member predicate Type::getATypeNameUse">getATypeNameUse</a></td><td><span class="qldoc-summary"><p>Gets as many places as possible where this type is used by name in the source after macros have been replaced  (in particular, therefore, this will find type name uses caused by macros). Note that all type name uses within  instantiations are currently excluded - this is too draconian in the absence of indexing prototype instantiations  of functions, and is likely to improve in the future. At present, the method takes the conservative approach of  giving valid type name uses, but not necessarily <em>all</em> type name uses.</p>
</span></td><td><span>from <a href="../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.TypedefType$TypedefType$getAlignment.0.html" class="ref-link ref-predicate" title="Member predicate TypedefType::getAlignment">getAlignment</a></td><td><span class="qldoc-summary"><p>Gets the alignment of this type in bytes.</p>
</span></td><td><span>from <a href="type.TypedefType$TypedefType.html" class="ref-link ref-type" title="Class TypedefType">TypedefType</a></span></td></tr><tr><td><a href="../Type.qll/predicate.Type$Type$getAnAttribute.0.html" class="ref-link ref-predicate" title="Member predicate Type::getAnAttribute">getAnAttribute</a></td><td><span class="qldoc-summary"><p>Gets an attribute of this type.</p>
</span></td><td><span>from <a href="../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.TypedefType$TypedefType$getBaseType.0.html" class="ref-link ref-predicate" title="Member predicate TypedefType::getBaseType">getBaseType</a></td><td><span class="qldoc-summary"><p>Gets the base type of this typedef type.</p>
</span></td><td><span>from <a href="type.TypedefType$TypedefType.html" class="ref-link ref-type" title="Class TypedefType">TypedefType</a></span></td></tr><tr><td><span class="deprecated"><a href="../Element.qll/predicate.Element$ElementBase$getCanonicalQLClass.0.html" class="ref-link ref-predicate" title="Member predicate ElementBase::getCanonicalQLClass">getCanonicalQLClass</a></span></td><td><span class="qldoc-summary"><p>DEPRECATED: use <code>getAPrimaryQlClass</code> instead.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$ElementBase.html" class="ref-link ref-type" title="Class ElementBase">ElementBase</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$getDeclaringType.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::getDeclaringType">getDeclaringType</a></td><td><span class="qldoc-summary"><p>Gets the class where this member is declared, if it is a member.  For templates, both the template itself and all instantiations of  the template are considered to have the same declaring class.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../UserType.qll/predicate.UserType$UserType$getDefinition.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getDefinition">getDefinition</a></td><td><span class="qldoc-summary"><p>Gets the declaration entry corresponding to this declaration that is a  definition, if any.</p>
</span></td><td><span>from <a href="../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../UserType.qll/predicate.UserType$UserType$getDefinitionLocation.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getDefinitionLocation">getDefinitionLocation</a></td><td><span class="qldoc-summary"><p>Gets the location of the definition, if any.</p>
</span></td><td><span>from <a href="../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$getDescription.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::getDescription">getDescription</a></td><td><span class="qldoc-summary"><p>Gets a description of this <code>Declaration</code> for display purposes.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../UserType.qll/predicate.UserType$UserType$getEnclosingAccessHolder.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getEnclosingAccessHolder">getEnclosingAccessHolder</a></td><td><span class="qldoc-summary"><p>Gets the nearest enclosing <code>AccessHolder</code>.</p>
</span></td><td><span>from <a href="../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$getEnclosingElement.0.html" class="ref-link ref-predicate" title="Member predicate Element::getEnclosingElement">getEnclosingElement</a></td><td><span class="qldoc-summary"><p>Gets the closest <code>Element</code> enclosing this one.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../UserType.qll/predicate.UserType$UserType$getEnclosingFunction.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getEnclosingFunction">getEnclosingFunction</a></td><td><span class="qldoc-summary"><p>Gets the function that directly encloses this type (if any).</p>
</span></td><td><span>from <a href="../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$getFile.0.html" class="ref-link ref-predicate" title="Member predicate Element::getFile">getFile</a></td><td><span class="qldoc-summary"><p>Gets the primary file where this element occurs.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../UserType.qll/predicate.UserType$UserType$getLocation.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getLocation">getLocation</a></td><td><span class="qldoc-summary"><p>Gets the preferred location of this declaration, if any.</p>
</span></td><td><span>from <a href="../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../UserType.qll/predicate.UserType$UserType$getName.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getName">getName</a></td><td><span class="qldoc-summary"><p>Gets the name of this type.</p>
</span></td><td><span>from <a href="../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$getNamespace.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::getNamespace">getNamespace</a></td><td><span class="qldoc-summary"><p>Gets the innermost namespace which contains this declaration.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$getNumberOfTemplateArguments.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::getNumberOfTemplateArguments">getNumberOfTemplateArguments</a></td><td><span class="qldoc-summary"><p>Gets the number of template arguments for this declaration.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$getParentScope.0.html" class="ref-link ref-predicate" title="Member predicate Element::getParentScope">getParentScope</a></td><td><span class="qldoc-summary"><p>Gets the parent scope of this <code>Element</code>, if any.  A scope is a <code>Type</code> (<code>Class</code> / <code>Enum</code>), a <code>Namespace</code>, a <code>BlockStmt</code>, a <code>Function</code>,  or certain kinds of <code>Statement</code>.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="predicate.TypedefType$TypedefType$getPointerIndirectionLevel.0.html" class="ref-link ref-predicate" title="Member predicate TypedefType::getPointerIndirectionLevel">getPointerIndirectionLevel</a></td><td><span class="qldoc-summary"><p>Gets the pointer indirection level of this type.</p>
</span></td><td><span>from <a href="type.TypedefType$TypedefType.html" class="ref-link ref-type" title="Class TypedefType">TypedefType</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$getQualifiedName.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::getQualifiedName">getQualifiedName</a></td><td><span class="qldoc-summary"><p>Gets the name of the declaration, fully qualified with its  namespace and declaring type.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../UserType.qll/predicate.UserType$UserType$getSimpleName.0.html" class="ref-link ref-predicate" title="Member predicate UserType::getSimpleName">getSimpleName</a></td><td><span class="qldoc-summary"><p>Gets the simple name of this type, without any template parameters.  For example  if the name of the type is <code>&quot;myType&lt;int&gt;&quot;</code>, the simple name is just <code>&quot;myType&quot;</code>.</p>
</span></td><td><span>from <a href="../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="predicate.TypedefType$TypedefType$getSize.0.html" class="ref-link ref-predicate" title="Member predicate TypedefType::getSize">getSize</a></td><td><span class="qldoc-summary"><p>Gets the size of this type in bytes.</p>
</span></td><td><span>from <a href="type.TypedefType$TypedefType.html" class="ref-link ref-type" title="Class TypedefType">TypedefType</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$getTemplateArgument.1.html" class="ref-link ref-predicate" title="Member predicate Declaration::getTemplateArgument">getTemplateArgument</a></td><td><span class="qldoc-summary"><p>Gets the <code>i</code>th template argument used to instantiate this declaration from a  template.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$getTemplateArgumentKind.1.html" class="ref-link ref-predicate" title="Member predicate Declaration::getTemplateArgumentKind">getTemplateArgumentKind</a></td><td><span class="qldoc-summary"><p>Gets the <code>i</code>th template argument value used to instantiate this declaration  from a template. When called on a template, this will return the <code>i</code>th template  parameter value if it exists.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="predicate.TypedefType$TypedefType$getUnderlyingType.0.html" class="ref-link ref-predicate" title="Member predicate TypedefType::getUnderlyingType">getUnderlyingType</a></td><td><span class="qldoc-summary"><p>Gets this type after typedefs have been resolved.</p>
</span></td><td><span>from <a href="type.TypedefType$TypedefType.html" class="ref-link ref-type" title="Class TypedefType">TypedefType</a></span></td></tr><tr><td><a href="../Type.qll/predicate.Type$Type$getUnspecifiedType.0.html" class="ref-link ref-predicate" title="Member predicate Type::getUnspecifiedType">getUnspecifiedType</a></td><td><span class="qldoc-summary"><p>Gets this type after specifiers have been deeply stripped and typedefs have been resolved.</p>
</span></td><td><span>from <a href="../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$hasDeclaringType.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::hasDeclaringType">hasDeclaringType</a></td><td><span class="qldoc-summary"><p>Holds if this declaration is a member of a class/struct/union.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$hasDefinition.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::hasDefinition">hasDefinition</a></td><td><span class="qldoc-summary"><p>Holds if the declaration has a definition.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$hasGlobalName.1.html" class="ref-link ref-predicate" title="Member predicate Declaration::hasGlobalName">hasGlobalName</a></td><td><span class="qldoc-summary"><p>Holds if this declaration has the given name in the global namespace.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$hasGlobalOrStdName.1.html" class="ref-link ref-predicate" title="Member predicate Declaration::hasGlobalOrStdName">hasGlobalOrStdName</a></td><td><span class="qldoc-summary"><p>Holds if this declaration has the given name in the global namespace or the <code>std</code> namespace.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../UserType.qll/predicate.UserType$UserType$hasName.1.html" class="ref-link ref-predicate" title="Member predicate UserType::hasName">hasName</a></td><td></td><td><span>from <a href="../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$hasQualifiedName.1.html" class="ref-link ref-predicate" title="Member predicate Declaration::hasQualifiedName">hasQualifiedName</a></td><td><span class="qldoc-summary"><p>DEPRECATED: Prefer <code>hasGlobalName</code> or the 2-argument or 3-argument  <code>hasQualifiedName</code> predicates. To get the exact same results as this  predicate in all edge cases, use <code>getQualifiedName()</code>.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$hasQualifiedName.3.html" class="ref-link ref-predicate" title="Member predicate Declaration::hasQualifiedName">hasQualifiedName</a></td><td><span class="qldoc-summary"><p>Holds if this declaration has a fully-qualified name with a name-space  component of <code>namespaceQualifier</code>, a declaring type of <code>typeQualifier</code>,  and a base name of <code>baseName</code>. Template parameters and arguments are  stripped from all components. Missing components are <code>&quot;&quot;</code>.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$hasQualifiedName.2.html" class="ref-link ref-predicate" title="Member predicate Declaration::hasQualifiedName">hasQualifiedName</a></td><td><span class="qldoc-summary"><p>Holds if this declaration has a fully-qualified name with a name-space  component of <code>namespaceQualifier</code>, no declaring type, and a base name of  <code>baseName</code>.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../UserType.qll/predicate.UserType$UserType$hasSpecifier.1.html" class="ref-link ref-predicate" title="Member predicate UserType::hasSpecifier">hasSpecifier</a></td><td></td><td><span>from <a href="../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$AccessHolder$inMemberOrFriendOf.1.html" class="ref-link ref-predicate" title="Member predicate AccessHolder::inMemberOrFriendOf">inMemberOrFriendOf</a></td><td><span class="qldoc-summary"><p>Holds if <code>this</code> can access private members of class <code>c</code>.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$AccessHolder.html" class="ref-link ref-type" title="Class AccessHolder">AccessHolder</a></span></td></tr><tr><td><a href="predicate.TypedefType$TypedefType$internal_getAnAdditionalSpecifier.0.html" class="ref-link ref-predicate" title="Member predicate TypedefType::internal_getAnAdditionalSpecifier">internal_getAnAdditionalSpecifier</a></td><td><span class="qldoc-summary"><p>Internal &ndash; should be <code>protected</code> when QL supports such a flag. Subtypes  override this to recursively get specifiers that are not attached directly  to this <code>@type</code> in the database but arise through type aliases such as  <code>typedef</code> and <code>decltype</code>.</p>
</span></td><td><span>from <a href="type.TypedefType$TypedefType.html" class="ref-link ref-type" title="Class TypedefType">TypedefType</a></span></td></tr><tr><td><a href="predicate.TypedefType$TypedefType$involvesReference.0.html" class="ref-link ref-predicate" title="Member predicate TypedefType::involvesReference">involvesReference</a></td><td><span class="qldoc-summary"><p>Holds if this type involves a reference.</p>
</span></td><td><span>from <a href="type.TypedefType$TypedefType.html" class="ref-link ref-type" title="Class TypedefType">TypedefType</a></span></td></tr><tr><td><a href="../Type.qll/predicate.Type$Type$involvesTemplateParameter.0.html" class="ref-link ref-predicate" title="Member predicate Type::involvesTemplateParameter">involvesTemplateParameter</a></td><td><span class="qldoc-summary"><p>Holds if this type involves a template parameter.</p>
</span></td><td><span>from <a href="../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$isAffectedByMacro.0.html" class="ref-link ref-predicate" title="Member predicate Element::isAffectedByMacro">isAffectedByMacro</a></td><td><span class="qldoc-summary"><p>Holds if this element is affected in any way by a macro. All elements  that are totally or partially generated by a macro are included, so  this is a super-set of <code>isInMacroExpansion</code>.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../UserType.qll/predicate.UserType$UserType$isAnonymous.0.html" class="ref-link ref-predicate" title="Member predicate UserType::isAnonymous">isAnonymous</a></td><td><span class="qldoc-summary"><p>Holds if this type is anonymous.</p>
</span></td><td><span>from <a href="../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../Type.qll/predicate.Type$Type$isConst.0.html" class="ref-link ref-predicate" title="Member predicate Type::isConst">isConst</a></td><td><span class="qldoc-summary"><p>Holds if this type is const.</p>
</span></td><td><span>from <a href="../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.TypedefType$TypedefType$isDeeplyConst.0.html" class="ref-link ref-predicate" title="Member predicate TypedefType::isDeeplyConst">isDeeplyConst</a></td><td><span class="qldoc-summary"><p>Holds if this type is constant and only contains constant types.  For instance, a <code>char *const</code> is a constant type, but not deeply constant,  because while the pointer can&rsquo;t be modified the character can. The type  <code>const char *const*</code> is a deeply constant type though - both the pointer  and what it points to are immutable.</p>
</span></td><td><span>from <a href="type.TypedefType$TypedefType.html" class="ref-link ref-type" title="Class TypedefType">TypedefType</a></span></td></tr><tr><td><a href="predicate.TypedefType$TypedefType$isDeeplyConstBelow.0.html" class="ref-link ref-predicate" title="Member predicate TypedefType::isDeeplyConstBelow">isDeeplyConstBelow</a></td><td><span class="qldoc-summary"><p>Holds if this type is constant and only contains constant types, excluding  the type itself. It is implied by Type.isDeeplyConst() and is just used to  implement that predicate.  For example, <code>const char *const</code> is deeply constant and deeply constant below,  but <code>const char *</code> is only deeply constant below (the pointer can be changed,  but not the underlying char). <code>char *const</code> is neither (it is just <code>const</code>).</p>
</span></td><td><span>from <a href="type.TypedefType$TypedefType.html" class="ref-link ref-type" title="Class TypedefType">TypedefType</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$isDefined.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::isDefined">isDefined</a></td><td><span class="qldoc-summary"><p>DEPRECATED: Use <code>hasDefinition</code> instead.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$isFromTemplateInstantiation.1.html" class="ref-link ref-predicate" title="Member predicate Element::isFromTemplateInstantiation">isFromTemplateInstantiation</a></td><td><span class="qldoc-summary"><p>Holds if this <code>Element</code> is a part of a template instantiation (but not  the template itself).</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$isFromUninstantiatedTemplate.1.html" class="ref-link ref-predicate" title="Member predicate Element::isFromUninstantiatedTemplate">isFromUninstantiatedTemplate</a></td><td><span class="qldoc-summary"><p>Holds if this <code>Element</code> is part of a template <code>template</code> (not if it is  part of an instantiation of <code>template</code>). This means it is represented in  the database purely as syntax and without guarantees on the presence or  correctness of type-based operations such as implicit conversions.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../Element.qll/predicate.Element$Element$isInMacroExpansion.0.html" class="ref-link ref-predicate" title="Member predicate Element::isInMacroExpansion">isInMacroExpansion</a></td><td><span class="qldoc-summary"><p>Holds if this element comes from a macro expansion. Only elements that  are entirely generated by a macro are included - for elements that  partially come from a macro, see <code>isAffectedByMacro</code>.</p>
</span></td><td><span>from <a href="../Element.qll/type.Element$Element.html" class="ref-link ref-type" title="Class Element">Element</a></span></td></tr><tr><td><a href="../UserType.qll/predicate.UserType$UserType$isLocal.0.html" class="ref-link ref-predicate" title="Member predicate UserType::isLocal">isLocal</a></td><td><span class="qldoc-summary"><p>Holds if this is a local type (that is, a type that has a directly-enclosing  function).</p>
</span></td><td><span>from <a href="../UserType.qll/type.UserType$UserType.html" class="ref-link ref-type" title="Class UserType">UserType</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$isMember.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::isMember">isMember</a></td><td><span class="qldoc-summary"><p>Holds if this declaration is a member of a class/struct/union.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$isStatic.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::isStatic">isStatic</a></td><td><span class="qldoc-summary"><p>Holds if this declaration is static.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$isTopLevel.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::isTopLevel">isTopLevel</a></td><td><span class="qldoc-summary"><p>Holds if this declaration is a top-level declaration.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr><tr><td><a href="../Type.qll/predicate.Type$Type$isVolatile.0.html" class="ref-link ref-predicate" title="Member predicate Type::isVolatile">isVolatile</a></td><td><span class="qldoc-summary"><p>Holds if this type is volatile.</p>
</span></td><td><span>from <a href="../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../Type.qll/predicate.Type$Type$refersTo.1.html" class="ref-link ref-predicate" title="Member predicate Type::refersTo">refersTo</a></td><td><span class="qldoc-summary"><p>Holds if this type refers to type <code>t</code> (by default,  a type always refers to itself).</p>
</span></td><td><span>from <a href="../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="../Type.qll/predicate.Type$Type$refersToDirectly.1.html" class="ref-link ref-predicate" title="Member predicate Type::refersToDirectly">refersToDirectly</a></td><td><span class="qldoc-summary"><p>Holds if this type refers to type <code>t</code> directly.</p>
</span></td><td><span>from <a href="../Type.qll/type.Type$Type.html" class="ref-link ref-type" title="Class Type">Type</a></span></td></tr><tr><td><a href="predicate.TypedefType$TypedefType$resolveTypedefs.0.html" class="ref-link ref-predicate" title="Member predicate TypedefType::resolveTypedefs">resolveTypedefs</a></td><td><span class="qldoc-summary"><p>Gets this type with any typedefs resolved. For example, given  <code>typedef C T</code>, this would resolve <code>const T&amp;amp;</code> to <code>const C&amp;amp;</code>.  Note that this will only work if the resolved type actually appears  on its own elsewhere in the program.</p>
</span></td><td><span>from <a href="type.TypedefType$TypedefType.html" class="ref-link ref-type" title="Class TypedefType">TypedefType</a></span></td></tr><tr><td><a href="predicate.TypedefType$TypedefType$stripTopLevelSpecifiers.0.html" class="ref-link ref-predicate" title="Member predicate TypedefType::stripTopLevelSpecifiers">stripTopLevelSpecifiers</a></td><td><span class="qldoc-summary"><p>Gets this type after any top-level specifiers and typedefs have been stripped.</p>
</span></td><td><span>from <a href="type.TypedefType$TypedefType.html" class="ref-link ref-type" title="Class TypedefType">TypedefType</a></span></td></tr><tr><td><a href="predicate.TypedefType$TypedefType$stripType.0.html" class="ref-link ref-predicate" title="Member predicate TypedefType::stripType">stripType</a></td><td><span class="qldoc-summary"><p>Gets the type stripped of pointers, references and cv-qualifiers, and resolving typedefs.  For example, given <code>typedef const C&amp;amp; T</code>, <code>stripType</code> returns <code>C</code>.</p>
</span></td><td><span>from <a href="type.TypedefType$TypedefType.html" class="ref-link ref-type" title="Class TypedefType">TypedefType</a></span></td></tr><tr><td><a href="../Declaration.qll/predicate.Declaration$Declaration$toString.0.html" class="ref-link ref-predicate" title="Member predicate Declaration::toString">toString</a></td><td><span class="qldoc-summary"><p>Gets a textual representation of this element.</p>
</span></td><td><span>from <a href="../Declaration.qll/type.Declaration$Declaration.html" class="ref-link ref-type" title="Class Declaration">Declaration</a></span></td></tr></tbody></table></div></div><div><h2 class="subsection-heading" id="Charpred">Charpred</h2><div class="doc-block"><table><tbody><tr><td><a href="predicate.TypedefType$LocalTypedefType$LocalTypedefType.0.html" class="ref-link ref-predicate" title="Characteristic predicate LocalTypedefType::LocalTypedefType">LocalTypedefType</a></td><td></td></tr></tbody></table></div></div></div></div></div><footer id="content-footer">Copyright 2020 GitHub Software UK Ltd.<a title="Privacy statement and tracking preferences" target="_blank" href="https://docs.github.com/github/site-policy/github-privacy-statement">Privacy Statement</a></footer></body></html>